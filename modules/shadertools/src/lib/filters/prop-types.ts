// luma.gl, MIT license

/** 
 * For use by shader module and shader pass writers to describe the types of the 
 * properties they expose (properties ultimately map to uniforms).
 */
export type PropType = {
  type?: string;
  max?: number;
  min?: number;
  value?: any;
} | number;

/**
 * Internal property validators generated by processing the prop types , 
 * The `validate()` method can be used to validate the type of properties passed in to
 * shader module or shader pass
 */
export type PropValidator = {
  type: string;
  value: any;
  max?: number;
  min?: number;
  private?: boolean;
  validate?(value: any, propDef: PropValidator): boolean;
};

const DEFAULT_PROP_VALIDATORS: Record<string, {validate: (value: unknown, propType: PropType) => boolean}> = {
  number: {
    validate(value: unknown, propType: PropType) {
      return (
        Number.isFinite(value) &&
        typeof propType === 'object' &&
        (!('max' in propType) || value <= propType.max) &&
        (!('min' in propType) || value >= propType.min)
      );
    }
  },
  array: {
    validate(value: unknown, propType: PropType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};

/**
 * Parse a list of property types into property definitions that can be used to validate
 * values passed in by applications.
 * @param propTypes 
 * @returns 
 */

export function parsePropTypes(propTypes: Record<string, PropType>): Record<string, PropValidator> {
  const propValidators: Record<string, PropValidator> = {};
  for (const [name, propType] of Object.entries(propTypes)) {
    propValidators[name] = createPropValidator(propType);
  }
  return propValidators;
}

/**
 * Creates a property validator for a prop type. Either contains:
 * - a valid prop type object ({type, ...})
 * - or just a default value, in which case type and name inference is used
 */
function createPropValidator(propType: PropType): PropValidator {
  let type = getTypeOf(propType);
  if (type !== 'object') {
    return {type, value: propType, ...DEFAULT_PROP_VALIDATORS[type]};
  }
  if (typeof propType === 'object') {
    if (!propType) {
      return {type: 'object', value: null};
    }
    if ('type' in propType) {
    // @ts-expect-error
    return {...propType, ...DEFAULT_PROP_VALIDATORS[propType.type]};
    }
    if (!('value' in propType)) {
      // If no type and value this object is likely the value
      return {type: 'object', value: propType};
    }
    type = getTypeOf(propType.value);
    // @ts-expect-error
    return {type, ...propType, ...DEFAULT_PROP_VALIDATORS[type]};
  }
}

/** 
 * "improved" version of javascript typeof that can distinguish arrays and null values
 */
function getTypeOf(value: unknown): string {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }
  return typeof value;
}
