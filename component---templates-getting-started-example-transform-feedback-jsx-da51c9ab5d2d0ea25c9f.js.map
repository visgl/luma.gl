{"version":3,"sources":["webpack:///../modules/shadertools/src/utils/shader-utils.js","webpack:///../modules/engine/src/transform/buffer-transform.js","webpack:///../modules/webgl/src/glsl-utils/get-shader-version.js","webpack:///../modules/shadertools/src/modules/transform/transform.js","webpack:///../modules/engine/src/transform/transform-shader-utils.js","webpack:///../modules/engine/src/transform/texture-transform.js","webpack:///../modules/engine/src/transform/transform.js","webpack:///../examples/getting-started/transform-feedback/app.js","webpack:///./templates/getting-started/example-transform-feedback.jsx"],"names":["FS100","FS_GLES","FS300","getQualifierDetails","line","qualifiers","Array","words","qualifier","type","definition","name","getPassthroughFS","version","input","inputType","output","outputValue","variable","assert","convertToVec4","BufferTransform","props","this","gl","currentIndex","feedbackMap","varyings","bindings","resources","_initialize","Object","setupResources","binding","_setupTransformFeedback","updateModelProps","getDrawOptions","opts","sourceBuffers","transformFeedback","attributes","swap","update","_setupBuffers","getBuffer","feedbackBuffers","bufferOrParams","varyingName","getData","buffer","delete","length","isWebGL2","_getFeedbackBuffers","feedbackName","sourceName","bufferOrRef","sourceBuffer","byteLength","usage","accessor","_createNewBuffer","bufferName","_updateBindings","program","model","buffers","_updateBinding","_swapBuffers","nextIndex","dstName","_getNextIndex","getShaderVersion","source","v","parseInt","Number","vs","fs","SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","sourceTextureMap","targetTextureVarying","targetTexture","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","updated","attributeData","getAttributeDefinition","textureMap","updatedLine","textureName","samplerName","sizeName","uniformDeclerations","getSamplerDeclerations","channels","typeToChannelSuffix","sampleInstruction","inject","processAttributeDefinition","combineInjects","qualaiferDetails","getVaryingType","SRC_TEX_PARAMETER_OVERRIDES","GL","TextureTransform","_swapTexture","updatedModelProps","_processVertexShader","sourceTextures","framebuffer","uniforms","parameters","discard","hasSourceTextures","sizeUniforms","width","height","getSizeUniforms","_setupTextures","getTargetTexture","packed","pixels","readPixelsToArray","ArrayType","channelCount","typeToChannelCount","packedPixels","packCount","i","j","getFramebuffer","ownTexture","elementIDBuffer","_targetTextureVarying","hasTargetTexture","_createTargetTexture","textureOrReference","refTexture","_targetRefTexName","_sourceTextures","_targetTexture","_updateElementIDBuffer","elementCount","elementIds","Float32Array","array","setData","data","size","_swapTextures","attachments","resizeAttachments","id","_setSourceTextureParameters","index","_createNewTexture","texture","cloneTextureFrom","pixelStore","combinedInject","modules","transform","Transform","bufferTransform","textureTransform","isSupported","run","clearRenderTarget","updatedOpts","_updateDrawOptions","color","swapped","resourceTransform","setVertexCount","_buildResourceTransforms","_updateModelProps","drawMode","vertexCount","updatedProps","isObjectEmpty","canCreateBufferTransform","canCreateTextureTransform","AppAnimationLoop","debug","getInfo","onInitialize","demoNotSupported","positionBuffer","position","colorBuffer","onRender","clear","onFinalize","getAltText","AnimationLoop","window","animationLoop","Example","render","pageContext","exampleConfig","React","Component"],"mappings":"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","file":"component---templates-getting-started-example-transform-feedback-jsx-da51c9ab5d2d0ea25c9f.js","sourcesContent":["import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n","import {isWebGL2} from '@luma.gl/gltools';\nimport {Buffer, TransformFeedback} from '@luma.gl/webgl';\nimport {assert} from '@luma.gl/webgl';\n\nexport default class BufferTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this.feedbackMap = {};\n    this.varyings = null; // varyings array\n    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  setupResources(opts) {\n    for (const binding of this.bindings) {\n      this._setupTransformFeedback(binding, opts);\n    }\n  }\n\n  updateModelProps(props = {}) {\n    const {varyings} = this;\n    if (varyings.length > 0) {\n      props = Object.assign({}, props, {varyings});\n    }\n    return props;\n  }\n\n  getDrawOptions(opts = {}) {\n    const binding = this.bindings[this.currentIndex];\n    const {sourceBuffers, transformFeedback} = binding;\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n\n    return {attributes, transformFeedback};\n  }\n\n  swap() {\n    if (this.feedbackMap) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupBuffers(opts);\n  }\n\n  // returns current feedbackBuffer of given name\n  getBuffer(varyingName) {\n    const {feedbackBuffers} = this.bindings[this.currentIndex];\n    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;\n    if (!bufferOrParams) {\n      return null;\n    }\n    return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;\n  }\n\n  getData({varyingName} = {}) {\n    const buffer = this.getBuffer(varyingName);\n    if (buffer) {\n      return buffer.getData();\n    }\n    return null;\n  }\n\n  // Delete owned resources.\n  delete() {\n    for (const name in this.resources) {\n      this.resources[name].delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    this._setupBuffers(props);\n    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);\n    if (this.varyings.length > 0) {\n      // if writting to buffers make sure it is WebGL2\n      assert(isWebGL2(this.gl));\n    }\n  }\n\n  // auto create feedback buffers if requested\n  _getFeedbackBuffers(props) {\n    const {sourceBuffers = {}} = props;\n    const feedbackBuffers = {};\n    if (this.bindings[this.currentIndex]) {\n      // this gurantees a partial feedback buffer set doesn't update\n      // previously set buffers during auto creation mode.\n      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);\n    }\n    if (this.feedbackMap) {\n      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object\n      for (const sourceName in this.feedbackMap) {\n        const feedbackName = this.feedbackMap[sourceName];\n        if (sourceName in sourceBuffers) {\n          feedbackBuffers[feedbackName] = sourceName;\n        }\n      }\n    }\n    Object.assign(feedbackBuffers, props.feedbackBuffers);\n    for (const bufferName in feedbackBuffers) {\n      const bufferOrRef = feedbackBuffers[bufferName];\n      if (typeof bufferOrRef === 'string') {\n        // Create new buffer with same layout and settings as source buffer\n        const sourceBuffer = sourceBuffers[bufferOrRef];\n        const {byteLength, usage, accessor} = sourceBuffer;\n        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {\n          byteLength,\n          usage,\n          accessor\n        });\n      }\n    }\n\n    return feedbackBuffers;\n  }\n\n  _setupBuffers(props = {}) {\n    const {sourceBuffers = null} = props;\n    Object.assign(this.feedbackMap, props.feedbackMap);\n    const feedbackBuffers = this._getFeedbackBuffers(props);\n    this._updateBindings({sourceBuffers, feedbackBuffers});\n  }\n\n  _setupTransformFeedback(binding, {model}) {\n    const {program} = model;\n    binding.transformFeedback = new TransformFeedback(this.gl, {\n      program,\n      buffers: binding.feedbackBuffers\n    });\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this.feedbackMap) {\n      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceBuffers,\n        feedbackBuffers\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    if (!binding) {\n      return {\n        sourceBuffers: Object.assign({}, opts.sourceBuffers),\n        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)\n      };\n    }\n    Object.assign(binding.sourceBuffers, opts.sourceBuffers);\n    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);\n    if (binding.transformFeedback) {\n      binding.transformFeedback.setBuffers(binding.feedbackBuffers);\n    }\n    return binding;\n  }\n\n  _swapBuffers(opts) {\n    if (!this.feedbackMap) {\n      return null;\n    }\n    const sourceBuffers = Object.assign({}, opts.sourceBuffers);\n    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);\n    for (const srcName in this.feedbackMap) {\n      const dstName = this.feedbackMap[srcName];\n      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];\n      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];\n\n      // make sure the new destination buffer is a Buffer object\n      assert(feedbackBuffers[dstName] instanceof Buffer);\n    }\n    return {sourceBuffers, feedbackBuffers};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewBuffer(name, opts) {\n    const buffer = new Buffer(this.gl, opts);\n    if (this.resources[name]) {\n      this.resources[name].delete();\n    }\n    this.resources[name] = buffer;\n    return buffer;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n}\n","// returns GLSL shader version of given shader string\nexport default function getShaderVersion(source) {\n  let version = 100;\n  const words = source.match(/[^\\s]+/g);\n  if (words.length >= 2 && words[0] === '#version') {\n    const v = parseInt(words[1], 10);\n    if (Number.isFinite(v)) {\n      version = v;\n    }\n  }\n  return version;\n}\n","// Private shader module used by `Transform`\n\nconst vs = `\\\nattribute float transform_elementID;\n\n// returns half of pixel size, used to move the pixel position to center of the pixel.\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\n// returns current elements pixel indeces [x, y],\n// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  // Add safe offset (half of pixel height) before doing floor\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\n\n// returns current elementID's texture co-ordianate\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\n\n// returns current elementID's position\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  // Change from [0 1] range to [-1 1]\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\n\n// returns current elementID's pixel value\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n`;\n\nexport default {\n  name: 'transform',\n  vs,\n  fs: null\n};\n","import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n","import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];\n\n    const attributes = Object.assign({}, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {_sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.sourceBuffers) ||\n    !isObjectEmpty(props.feedbackBuffers) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import {AnimationLoop, Transform, Model} from '@luma.gl/engine';\nimport {Buffer, clear} from '@luma.gl/webgl';\nimport {isWebGL2} from '@luma.gl/gltools';\n\nconst INFO_HTML = `\nAnimation via transform feedback.\n`;\n\nconst ALT_TEXT = \"THIS DEMO REQUIRES WEBGL 2, BUT YOUR BROWSER DOESN'T SUPPORT IT\";\n\nconst transformVs = `\\\n#version 300 es\n#define SIN2 0.03489949\n#define COS2 0.99939082\n\nin vec2 position;\n\nout vec2 vPosition;\nvoid main() {\n    mat2 rotation = mat2(\n        COS2, SIN2,\n        -SIN2, COS2\n    );\n    vPosition = rotation * position;\n}\n`;\n\nconst renderVs = `\\\n#version 300 es\n\nin vec2 position;\nin vec3 color;\n\nout vec3 vColor;\nvoid main() {\n    vColor = color;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\n\nconst renderFs = `\\\n#version 300 es\nprecision highp float;\n\nin vec3 vColor;\n\nout vec4 fragColor;\nvoid main() {\n    fragColor = vec4(vColor, 1.0);\n}\n`;\n\nexport default class AppAnimationLoop extends AnimationLoop {\n  constructor() {\n    super({debug: true});\n  }\n\n  static getInfo() {\n    return INFO_HTML;\n  }\n\n  onInitialize({gl}) {\n    this.demoNotSupported = !isWebGL2(gl);\n    if (this.demoNotSupported) {\n      return {};\n    }\n\n    const positionBuffer = new Buffer(gl, new Float32Array([-0.5, -0.5, 0.5, -0.5, 0.0, 0.5]));\n\n    const transform = new Transform(gl, {\n      vs: transformVs,\n      sourceBuffers: {\n        position: positionBuffer\n      },\n      feedbackMap: {\n        position: 'vPosition'\n      },\n      elementCount: 3\n    });\n\n    const colorBuffer = new Buffer(\n      gl,\n      new Float32Array([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0])\n    );\n\n    const model = new Model(gl, {\n      vs: renderVs,\n      fs: renderFs,\n      attributes: {\n        position: transform.getBuffer('vPosition'),\n        color: colorBuffer\n      },\n      vertexCount: 3\n    });\n\n    return {transform, model};\n  }\n\n  onRender({gl, transform, model}) {\n    if (this.demoNotSupported) {\n      return;\n    }\n\n    transform.run();\n\n    clear(gl, {color: [0, 0, 0, 1]});\n    model.setAttributes({position: transform.getBuffer('vPosition')}).draw();\n\n    transform.swap();\n  }\n\n  onFinalize({transform, model}) {\n    if (transform) {\n      transform.delete();\n    }\n    if (model) {\n      model.delete();\n    }\n  }\n\n  getAltText() {\n    return ALT_TEXT;\n  }\n}\n\n/* global window */\nif (typeof window !== 'undefined' && !window.website) {\n  const animationLoop = new AppAnimationLoop();\n  animationLoop.start();\n}\n","import React from 'react';\nimport AnimationLoopExamplePage from '../../src/components/animation-loop-example-page';\nimport AnimationLoop from '../../../examples/getting-started/transform-feedback/app';\n\nexport default class Example extends React.Component {\n  render() {\n    const { pageContext } = this.props;\n    const exampleConfig = (pageContext && pageContext.exampleConfig) || {};\n    return (\n      <AnimationLoopExamplePage AnimationLoop={AnimationLoop} exampleConfig={exampleConfig} />\n    );\n  }\n}\n"],"sourceRoot":""}