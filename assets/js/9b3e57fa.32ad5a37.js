"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[4809],{6974:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api-reference/shadertools/shader-modules/fp64","title":"fp64 (64-bit Floating Point)","description":"Provides basic 64-bit math support in GPU shaders:","source":"@site/../docs/api-reference/shadertools/shader-modules/fp64.md","sourceDirName":"api-reference/shadertools/shader-modules","slug":"/api-reference/shadertools/shader-modules/fp64","permalink":"/docs/api-reference/shadertools/shader-modules/fp64","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/shadertools/shader-modules/fp64.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"fp32 (32-bit Floating Point)","permalink":"/docs/api-reference/shadertools/shader-modules/fp32"},"next":{"title":"pbrMaterial","permalink":"/docs/api-reference/shadertools/shader-modules/pbr-material"}}');var i=n(4848),r=n(8453);const o={},a="fp64 (64-bit Floating Point)",c={},d=[{value:"Precision",id:"precision",level:2},{value:"Performance Implications",id:"performance-implications",level:2},{value:"References",id:"references",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"fp64-64-bit-floating-point",children:"fp64 (64-bit Floating Point)"})}),"\n",(0,i.jsx)(t.p,{children:"Provides basic 64-bit math support in GPU shaders:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Function"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"add_fp64"}),"(vec2 a, vec2 b)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"sub_fp64"}),"(vec2 a, vec2 b)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"mul_fp64"}),"(vec2 a, vec2 b)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"div_fp64"}),"(vec2 a, vec2 b)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"sqrt_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"exp_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"log_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"sin_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"cos_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{children:["vec2 ",(0,i.jsx)(t.code,{children:"tan_fp64"}),"(vec2 a)"]}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"precision",children:"Precision"}),"\n",(0,i.jsxs)(t.p,{children:["WebGL does not expose native 64-bit floating point number support of\nmodern desktop GPUs to developers. As an alternative, this module uses\ntwo 32-bit native floating point number to extend and preserve significant\ndigits and uses algorithms similar to those used in many multiple precision\nmath libraries to achieve precision close to what IEEE-754 double precision\nfloating point numbers provide. Generally speaking, this mechanism provide\n46 significant digits in mantissa (48 overall) within the normal range of\n32-bit single precision float point numbers. This transfers to ~ ",(0,i.jsx)(t.code,{children:"1x10^-15"}),"\nrelative error within ~ ",(0,i.jsx)(t.code,{children:"1.2x10^-38"})," and ",(0,i.jsx)(t.code,{children:"1.7x10^+38"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The error bound as tested on 2015 MacBook Pro with AMD Radeon R9 M370X GPU:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Addition and subtraction: < 1 ulp\nMultiplication: ~1.5 ulps\nDivision: ~2 ulps\nSquare root: ~2.6 ulps\nExponential: ~2.6 ulps\nLogarithm: ~11.6 ulps (depends on the accuracy of native log() function)\nTrigonometry: ~5 ulps\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note: ",(0,i.jsx)(t.code,{children:"ulp"})," = ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Unit_in_the_last_place",children:"unit of least precision"})]}),"\n",(0,i.jsx)(t.h2,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,i.jsx)(t.p,{children:'Since 64-bit floating point math is emulated using the multiple precision\narithmetic, it costs significantly more GPU cycles than native 32-bit math\n(more than an order of magnitude, not to mention the non-IEEE compliant\n"fast-math" functions that most GPUs use to trade accuracy for speed).'}),"\n",(0,i.jsx)(t.p,{children:"However, by using 64-bit math only in accuracy critical paths,\nthe performance impact of using 64-bit calculations will normally be\nsignificantly less than an order of magnitude."}),"\n",(0,i.jsx)(t.p,{children:"For many applications, the amount of time spent in e.g.\nthe vertex shading stage is only part of the time spent in the whole the\nrendering pipeline."}),"\n",(0,i.jsx)(t.p,{children:"There will be a memory impact too, in that all vertex attributes and uniform data\nthat uses 64-bit maths require double storage space in JavaScirpt. Same as mentioned\nabove, since a layer usually has some attributes that do not require 64-bit maths,the\ntotal memory impact normally be somewhat less than 2x."}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"http://crd-legacy.lbl.gov/~dhbailey/mpdist",children:"http://crd-legacy.lbl.gov/~dhbailey/mpdist"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://gmplib.org",children:"https://gmplib.org"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);