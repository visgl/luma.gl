"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[3989],{6329:(e,r,d)=>{d.r(r),d.d(r,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"api-reference/engine/model","title":"Model","description":"The Model class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface.","source":"@site/../docs/api-reference/engine/model.md","sourceDirName":"api-reference/engine","slug":"/api-reference/engine/model","permalink":"/docs/api-reference/engine/model","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/engine/model.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"VertexArray","permalink":"/docs/api-reference/core/resources/vertex-array"},"next":{"title":"ShaderInputs","permalink":"/docs/api-reference/engine/shader-inputs"}}');var s=d(4848),i=d(8453);const t={},c="Model",o={},l=[{value:"Usage",id:"usage",level:2},{value:"Provide attribute data using Buffer",id:"provide-attribute-data-using-buffer",level:3},{value:"Instanced rendering",id:"instanced-rendering",level:3},{value:"Async textures",id:"async-textures",level:3},{value:"Types",id:"types",level:2},{value:"<code>ModelProps</code>",id:"modelprops",level:3},{value:"Properties",id:"properties",level:2},{value:"<code>id: string</code>",id:"id-string",level:3},{value:"<code>device: Device</code>",id:"device-device",level:3},{value:"<code>parameters: RenderPipelineParameters</code>",id:"parameters-renderpipelineparameters",level:3},{value:"<code>topology: PrimitiveTopology</code>",id:"topology-primitivetopology",level:3},{value:"<code>bufferLayout: BufferLayout[]</code>",id:"bufferlayout-bufferlayout",level:3},{value:"<code>isInstanced: boolean | undefined</code>",id:"isinstanced-boolean--undefined",level:3},{value:"<code>instanceCount: number</code>",id:"instancecount-number",level:3},{value:"<code>vertexCount: number</code>",id:"vertexcount-number",level:3},{value:"<code>indexBuffer: Buffer | null</code>",id:"indexbuffer-buffer--null",level:3},{value:"<code>bindings: Record&lt;string, Binding | AsyncTexture&gt;</code>",id:"bindings-recordstring-binding--asynctexture",level:3},{value:"<code>vertexArray: VertexArray</code>",id:"vertexarray-vertexarray",level:3},{value:"<code>transformFeedback: TransformFeedback | null</code>",id:"transformfeedback-transformfeedback--null",level:3},{value:"<code>pipeline: RenderPipeline</code>",id:"pipeline-renderpipeline",level:3},{value:"<code>pipelineFactory: PipelineFactory</code>",id:"pipelinefactory-pipelinefactory",level:3},{value:"<code>shaderFactory: ShaderFactory</code>",id:"shaderfactory-shaderfactory",level:3},{value:"<code>userData: Record&lt;string, any&gt;</code>",id:"userdata-recordstring-any",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(device: Device, props: ModelProps)</code>",id:"constructordevice-device-props-modelprops",level:3},{value:"<code>destroy(): void</code>",id:"destroy-void",level:3},{value:"<code>needsRedraw(): false | string</code>",id:"needsredraw-false--string",level:3},{value:"<code>setNeedsRedraw(reason: string): void</code>",id:"setneedsredrawreason-string-void",level:3},{value:"<code>predraw(): void</code>",id:"predraw-void",level:3},{value:"<code>draw(renderPass: RenderPass): boolean</code>",id:"drawrenderpass-renderpass-boolean",level:3},{value:"<code>setGeometry(geometry: Geometry | GPUGeometry | null): void</code>",id:"setgeometrygeometry-geometry--gpugeometry--null-void",level:3},{value:"<code>setTopology(topology: PrimitiveTopology): void</code>",id:"settopologytopology-primitivetopology-void",level:3},{value:"<code>setBufferLayout(bufferLayout: BufferLayout[]): void</code>",id:"setbufferlayoutbufferlayout-bufferlayout-void",level:3},{value:"<code>setParameters(parameters: RenderPipelineParameters): void</code>",id:"setparametersparameters-renderpipelineparameters-void",level:3},{value:"<code>setInstanceCount(instanceCount: number): void</code>",id:"setinstancecountinstancecount-number-void",level:3},{value:"<code>setVertexCount(vertexCount: number): void</code>",id:"setvertexcountvertexcount-number-void",level:3},{value:"<code>setShaderInputs(shaderInputs: ShaderInputs): void</code>",id:"setshaderinputsshaderinputs-shaderinputs-void",level:3},{value:"<code>updateShaderInputs(): void</code>",id:"updateshaderinputs-void",level:3},{value:"<code>setBindings(bindings: Record&lt;string, Binding | AsyncTexture&gt;): void</code>",id:"setbindingsbindings-recordstring-binding--asynctexture-void",level:3},{value:"<code>setTransformFeedback(transformFeedback: TransformFeedback | null): void</code>",id:"settransformfeedbacktransformfeedback-transformfeedback--null-void",level:3},{value:"<code>setIndexBuffer(indexBuffer: Buffer | null): void</code>",id:"setindexbufferindexbuffer-buffer--null-void",level:3},{value:"<code>setAttributes(buffers: Record&lt;string, Buffer&gt;, options?): void</code>",id:"setattributesbuffers-recordstring-buffer-options-void",level:3},{value:"<code>setConstantAttributes(attributes: Record&lt;string, TypedArray&gt;, options?): void</code>",id:"setconstantattributesattributes-recordstring-typedarray-options-void",level:3}];function a(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"model",children:"Model"})}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"Model"})," class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Model"})," manages the following responsibilities:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Render pipeline creation and reuse"})," - builds GPU pipelines and recreates them when render state changes."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Attributes"})," - manages vertex attributes and can create buffers from typed arrays."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Bindings"})," - handles textures, samplers and uniform buffers."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Uniforms"})," - supports typed uniform buffers."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Async texture handling"})," - accepts ",(0,s.jsx)(r.code,{children:"DynamicTexture"})," bindings and defers rendering until textures have loaded."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Shader module injection"})," - assembles GLSL or WGSL shaders from modules."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Debugging"})," - detailed draw call logging and optional shader source display."]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"Model"})," class integrates:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["The ",(0,s.jsx)(r.code,{children:"@luma.gl/shadertools"})," shader module system: ",(0,s.jsxs)(r.a,{href:"/docs/api-reference/shadertools/shader-assembler",children:["see ",(0,s.jsx)(r.code,{children:"Shader Assembly"})]}),"."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"ShaderInputs"})," for uniform and binding management."]}),"\n",(0,s.jsxs)(r.li,{children:["The geometry helpers - accepts a ",(0,s.jsx)(r.a,{href:"/docs/api-reference/engine/geometry",children:(0,s.jsx)(r.code,{children:"Geometry"})})," instance (or mesh) plus any additional attributes for instanced rendering."]}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"import {Model} from `@luma.gl/engine`;\n"})}),"\n",(0,s.jsx)(r.p,{children:"One of the simplest way to provide attribute data is by using a Geometry object."}),"\n",(0,s.jsx)(r.p,{children:"Create model object by passing shaders, uniforms, geometry and render it by passing updated uniforms."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"import {Model, CubeGeometry} from `@luma.gl/engine`;\n\nconst model = new Model(device, {\n  source: WGSL_SHADER,\n  vs: GLSL_VERTEX_SHADER,\n  fs: GLSL_FRAGMENT_SHADER,\n  geometry: new CubeGeometry(),\n  bindings: {\n    uSampler: texture\n  },\n})\n"})}),"\n",(0,s.jsx)(r.h3,{id:"provide-attribute-data-using-buffer",children:"Provide attribute data using Buffer"}),"\n",(0,s.jsxs)(r.p,{children:["When using ",(0,s.jsx)(r.code,{children:"Buffer"})," objects, data remains on GPU and same ",(0,s.jsx)(r.code,{children:"Buffer"})," object can be shared between multiple models."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"// construct the model.\nconst model = new Model(device, {\n  vs: VERTEX_SHADER,\n  fs: FRAGMENT_SHADER,\n  topology: 'triangle-list',\n  vertexCount: 3,\n  attributes: {\n    attributeName1: bufferObject,\n    attributeName2: device.createBuffer(new Float32Array(...))\n  },\n  bindings: {uSampler: texture},\n})\n"})}),"\n",(0,s.jsx)(r.p,{children:"On each frame, update any uniform buffers or bindings and issue a draw call:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"model.setBindings({uSampler: texture});\nmodel.draw(renderPass);\n"})}),"\n",(0,s.jsx)(r.p,{children:"Debug shader source (even when shader successful)"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"// construct the model.\nconst model = new Model(device, {\n  vs: VERTEX_SHADER,\n  fs: FRAGMENT_SHADER,\n  debugShaders: 'always'\n});\n"})}),"\n",(0,s.jsx)(r.h3,{id:"instanced-rendering",children:"Instanced rendering"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"model.setInstanceCount(numInstances);\nmodel.draw(renderPass);\n"})}),"\n",(0,s.jsx)(r.h3,{id:"async-textures",children:"Async textures"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"const texture = new AsyncTexture(device, {url});\nconst model = new Model(device, {\n  vs: VERTEX_SHADER,\n  fs: FRAGMENT_SHADER,\n  geometry: new CubeGeometry(),\n  bindings: {uSampler: texture}\n});\n"})}),"\n",(0,s.jsx)(r.h2,{id:"types",children:"Types"}),"\n",(0,s.jsx)(r.h3,{id:"modelprops",children:(0,s.jsx)(r.code,{children:"ModelProps"})}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Property"}),(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"source"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"string"})}),(0,s.jsx)(r.td,{children:"WGSL source code containing both vertex and fragment stages."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"vs?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"string"})}),(0,s.jsx)(r.td,{children:"GLSL vertex shader source."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"fs?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"string"})}),(0,s.jsx)(r.td,{children:"GLSL fragment shader source."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"modules"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ShaderModule[]"})}),(0,s.jsx)(r.td,{children:"Shader modules to apply."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"defines"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Record<string, boolean>"})}),(0,s.jsx)(r.td,{children:"Module defines passed to shader assembler."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"shaderInputs?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ShaderInputs"})}),(0,s.jsx)(r.td,{children:"Pre-created uniform/binding store."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"bindings?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Record<string, Binding, AsyncTexture>"})}),(0,s.jsx)(r.td,{children:"Textures, samplers and uniform buffers."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"parameters?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"RenderPipelineParameters"})}),(0,s.jsx)(r.td,{children:"Pipeline parameters baked into the pipeline."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"geometry?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Geometry"})}),(0,s.jsx)(r.td,{children:"Geometry or mesh providing attributes and indices."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"isInstanced?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"boolean"})}),(0,s.jsx)(r.td,{children:"Use instanced rendering (auto-detected)."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"instanceCount?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"number"})}),(0,s.jsx)(r.td,{children:"Number of instances to render."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"vertexCount?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"number"})}),(0,s.jsx)(r.td,{children:"Number of vertices to render."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"indexBuffer?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Buffer"})}),(0,s.jsx)(r.td,{children:"Index buffer for indexed rendering."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"attributes?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Record<string, Buffer>"})}),(0,s.jsx)(r.td,{children:"Buffer-valued attributes."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"constantAttributes?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"Record<string, TypedArray>"})}),(0,s.jsx)(r.td,{children:"Constant attributes (WebGL only)."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"disableWarnings?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"boolean"})}),(0,s.jsx)(r.td,{children:"Suppress warnings for unused attributes or bindings."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"varyings?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"string[]"})}),(0,s.jsx)(r.td,{children:"WebGL transform feedback varyings."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"transformFeedback?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"TransformFeedback"})}),(0,s.jsx)(r.td,{children:"WebGL transform feedback object."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"debugShaders?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"'never' | 'errors' | 'warnings' | 'always'"})}),(0,s.jsx)(r.td,{children:"Display shader sources for debugging."})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"pipelineFactory?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"PipelineFactory"})}),(0,s.jsxs)(r.td,{children:["Factory used to create ",(0,s.jsx)(r.code,{children:"RenderPipeline"})," instances."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"shaderFactory?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ShaderFactory"})}),(0,s.jsxs)(r.td,{children:["Factory used to create ",(0,s.jsx)(r.code,{children:"Shader"})," instances."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"shaderAssembler?"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ShaderAssembler"})}),(0,s.jsx)(r.td,{children:"Assembles GLSL or WGSL from modules."})]})]})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"ModelProps"})," also include ",(0,s.jsx)(r.a,{href:"/docs/api-reference/core/resources/render-pipeline",children:(0,s.jsx)(r.code,{children:"RenderPipelineProps"})})," such as ",(0,s.jsx)(r.code,{children:"id"}),", ",(0,s.jsx)(r.code,{children:"shaderLayout"}),", ",(0,s.jsx)(r.code,{children:"bufferLayout"}),", ",(0,s.jsx)(r.code,{children:"topology"})," and ",(0,s.jsx)(r.code,{children:"userData"}),"."]}),"\n",(0,s.jsx)(r.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(r.h3,{id:"id-string",children:(0,s.jsx)(r.code,{children:"id: string"})}),"\n",(0,s.jsx)(r.p,{children:"Model identifier."}),"\n",(0,s.jsx)(r.h3,{id:"device-device",children:(0,s.jsx)(r.code,{children:"device: Device"})}),"\n",(0,s.jsx)(r.p,{children:"Device that created this model."}),"\n",(0,s.jsx)(r.h3,{id:"parameters-renderpipelineparameters",children:(0,s.jsx)(r.code,{children:"parameters: RenderPipelineParameters"})}),"\n",(0,s.jsx)(r.p,{children:"Pipeline parameters such as blending and depth testing."}),"\n",(0,s.jsx)(r.h3,{id:"topology-primitivetopology",children:(0,s.jsx)(r.code,{children:"topology: PrimitiveTopology"})}),"\n",(0,s.jsx)(r.p,{children:"Primitive topology used when drawing."}),"\n",(0,s.jsx)(r.h3,{id:"bufferlayout-bufferlayout",children:(0,s.jsx)(r.code,{children:"bufferLayout: BufferLayout[]"})}),"\n",(0,s.jsx)(r.p,{children:"Vertex buffer layout."}),"\n",(0,s.jsx)(r.h3,{id:"isinstanced-boolean--undefined",children:(0,s.jsx)(r.code,{children:"isInstanced: boolean | undefined"})}),"\n",(0,s.jsx)(r.p,{children:"Whether instanced rendering is enabled."}),"\n",(0,s.jsx)(r.h3,{id:"instancecount-number",children:(0,s.jsx)(r.code,{children:"instanceCount: number"})}),"\n",(0,s.jsx)(r.p,{children:"Number of instances to draw."}),"\n",(0,s.jsx)(r.h3,{id:"vertexcount-number",children:(0,s.jsx)(r.code,{children:"vertexCount: number"})}),"\n",(0,s.jsx)(r.p,{children:"Number of vertices to draw."}),"\n",(0,s.jsx)(r.h3,{id:"indexbuffer-buffer--null",children:(0,s.jsx)(r.code,{children:"indexBuffer: Buffer | null"})}),"\n",(0,s.jsx)(r.p,{children:"Index buffer used for indexed drawing."}),"\n",(0,s.jsx)(r.h3,{id:"bindings-recordstring-binding--asynctexture",children:(0,s.jsx)(r.code,{children:"bindings: Record<string, Binding | AsyncTexture>"})}),"\n",(0,s.jsx)(r.p,{children:"Currently bound textures, samplers and uniform buffers."}),"\n",(0,s.jsx)(r.h3,{id:"vertexarray-vertexarray",children:(0,s.jsx)(r.code,{children:"vertexArray: VertexArray"})}),"\n",(0,s.jsx)(r.p,{children:"Vertex array object tracking attribute bindings."}),"\n",(0,s.jsx)(r.h3,{id:"transformfeedback-transformfeedback--null",children:(0,s.jsx)(r.code,{children:"transformFeedback: TransformFeedback | null"})}),"\n",(0,s.jsx)(r.p,{children:"Transform feedback object (WebGL2 only)."}),"\n",(0,s.jsx)(r.h3,{id:"pipeline-renderpipeline",children:(0,s.jsx)(r.code,{children:"pipeline: RenderPipeline"})}),"\n",(0,s.jsx)(r.p,{children:"Underlying GPU pipeline."}),"\n",(0,s.jsx)(r.h3,{id:"pipelinefactory-pipelinefactory",children:(0,s.jsx)(r.code,{children:"pipelineFactory: PipelineFactory"})}),"\n",(0,s.jsx)(r.p,{children:"Factory used to create pipelines."}),"\n",(0,s.jsx)(r.h3,{id:"shaderfactory-shaderfactory",children:(0,s.jsx)(r.code,{children:"shaderFactory: ShaderFactory"})}),"\n",(0,s.jsx)(r.p,{children:"Factory used to create shaders."}),"\n",(0,s.jsx)(r.h3,{id:"userdata-recordstring-any",children:(0,s.jsx)(r.code,{children:"userData: Record<string, any>"})}),"\n",(0,s.jsx)(r.p,{children:"Application-specific data."}),"\n",(0,s.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(r.h3,{id:"constructordevice-device-props-modelprops",children:(0,s.jsx)(r.code,{children:"constructor(device: Device, props: ModelProps)"})}),"\n",(0,s.jsxs)(r.p,{children:["Create a new ",(0,s.jsx)(r.code,{children:"Model"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"destroy-void",children:(0,s.jsx)(r.code,{children:"destroy(): void"})}),"\n",(0,s.jsx)(r.p,{children:"Release GPU resources associated with the model."}),"\n",(0,s.jsx)(r.h3,{id:"needsredraw-false--string",children:(0,s.jsx)(r.code,{children:"needsRedraw(): false | string"})}),"\n",(0,s.jsxs)(r.p,{children:["Returns the reason string if the model has requested a redraw, or ",(0,s.jsx)(r.code,{children:"false"})," if no redraw is needed. Calling this method clears the flag."]}),"\n",(0,s.jsx)(r.h3,{id:"setneedsredrawreason-string-void",children:(0,s.jsx)(r.code,{children:"setNeedsRedraw(reason: string): void"})}),"\n",(0,s.jsxs)(r.p,{children:["Mark the model as needing to be redrawn. The optional ",(0,s.jsx)(r.code,{children:"reason"})," string is remembered until ",(0,s.jsx)(r.code,{children:"needsRedraw()"})," is called."]}),"\n",(0,s.jsx)(r.h3,{id:"predraw-void",children:(0,s.jsx)(r.code,{children:"predraw(): void"})}),"\n",(0,s.jsx)(r.p,{children:"Update uniform buffers and pipeline state prior to drawing."}),"\n",(0,s.jsx)(r.h3,{id:"drawrenderpass-renderpass-boolean",children:(0,s.jsx)(r.code,{children:"draw(renderPass: RenderPass): boolean"})}),"\n",(0,s.jsx)(r.p,{children:"Render the model once to the supplied render pass."}),"\n",(0,s.jsx)(r.h3,{id:"setgeometrygeometry-geometry--gpugeometry--null-void",children:(0,s.jsx)(r.code,{children:"setGeometry(geometry: Geometry | GPUGeometry | null): void"})}),"\n",(0,s.jsx)(r.p,{children:"Set the geometry for this model."}),"\n",(0,s.jsx)(r.h3,{id:"settopologytopology-primitivetopology-void",children:(0,s.jsx)(r.code,{children:"setTopology(topology: PrimitiveTopology): void"})}),"\n",(0,s.jsx)(r.p,{children:"Update the primitive topology."}),"\n",(0,s.jsx)(r.h3,{id:"setbufferlayoutbufferlayout-bufferlayout-void",children:(0,s.jsx)(r.code,{children:"setBufferLayout(bufferLayout: BufferLayout[]): void"})}),"\n",(0,s.jsx)(r.p,{children:"Update the buffer layout."}),"\n",(0,s.jsx)(r.h3,{id:"setparametersparameters-renderpipelineparameters-void",children:(0,s.jsx)(r.code,{children:"setParameters(parameters: RenderPipelineParameters): void"})}),"\n",(0,s.jsx)(r.p,{children:"Change render pipeline parameters."}),"\n",(0,s.jsx)(r.h3,{id:"setinstancecountinstancecount-number-void",children:(0,s.jsx)(r.code,{children:"setInstanceCount(instanceCount: number): void"})}),"\n",(0,s.jsx)(r.p,{children:"Specify how many instances to render."}),"\n",(0,s.jsx)(r.h3,{id:"setvertexcountvertexcount-number-void",children:(0,s.jsx)(r.code,{children:"setVertexCount(vertexCount: number): void"})}),"\n",(0,s.jsx)(r.p,{children:"Specify how many vertices to render."}),"\n",(0,s.jsx)(r.h3,{id:"setshaderinputsshaderinputs-shaderinputs-void",children:(0,s.jsx)(r.code,{children:"setShaderInputs(shaderInputs: ShaderInputs): void"})}),"\n",(0,s.jsxs)(r.p,{children:["Set the ",(0,s.jsx)(r.code,{children:"ShaderInputs"})," instance."]}),"\n",(0,s.jsx)(r.h3,{id:"updateshaderinputs-void",children:(0,s.jsx)(r.code,{children:"updateShaderInputs(): void"})}),"\n",(0,s.jsxs)(r.p,{children:["Update internal uniform buffers and bindings from ",(0,s.jsx)(r.code,{children:"shaderInputs"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"setbindingsbindings-recordstring-binding--asynctexture-void",children:(0,s.jsx)(r.code,{children:"setBindings(bindings: Record<string, Binding | AsyncTexture>): void"})}),"\n",(0,s.jsx)(r.p,{children:"Set textures, samplers and uniform buffers."}),"\n",(0,s.jsx)(r.h3,{id:"settransformfeedbacktransformfeedback-transformfeedback--null-void",children:(0,s.jsx)(r.code,{children:"setTransformFeedback(transformFeedback: TransformFeedback | null): void"})}),"\n",(0,s.jsx)(r.p,{children:"Attach an optional transform feedback object."}),"\n",(0,s.jsx)(r.h3,{id:"setindexbufferindexbuffer-buffer--null-void",children:(0,s.jsx)(r.code,{children:"setIndexBuffer(indexBuffer: Buffer | null): void"})}),"\n",(0,s.jsx)(r.p,{children:"Specify the index buffer."}),"\n",(0,s.jsx)(r.h3,{id:"setattributesbuffers-recordstring-buffer-options-void",children:(0,s.jsx)(r.code,{children:"setAttributes(buffers: Record<string, Buffer>, options?): void"})}),"\n",(0,s.jsx)(r.p,{children:"Set buffer-valued attributes."}),"\n",(0,s.jsx)(r.h3,{id:"setconstantattributesattributes-recordstring-typedarray-options-void",children:(0,s.jsx)(r.code,{children:"setConstantAttributes(attributes: Record<string, TypedArray>, options?): void"})}),"\n",(0,s.jsx)(r.p,{children:"Set constant-valued attributes (WebGL only)."})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,r,d)=>{d.d(r,{R:()=>t,x:()=>c});var n=d(6540);const s={},i=n.createContext(s);function t(e){const r=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);