"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[849],{6164:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","href":"/docs/","label":"Overview","docId":"README","unlisted":false},{"type":"link","href":"/docs/whats-new","label":"What\'s New","docId":"whats-new","unlisted":false},{"type":"link","href":"/docs/upgrade-guide","label":"Upgrade Guide","docId":"upgrade-guide","unlisted":false},{"type":"category","label":"Tutorials","items":[{"type":"link","href":"/docs/tutorials/","label":"Setup","docId":"tutorials/README","unlisted":false},{"type":"link","href":"/docs/tutorials/hello-triangle","label":"Hello Triangle","docId":"tutorials/hello-triangle","unlisted":false},{"type":"link","href":"/docs/tutorials/hello-cube","label":"Hello Cube","docId":"tutorials/hello-cube","unlisted":false},{"type":"link","href":"/docs/tutorials/lighting","label":"Lighting","docId":"tutorials/lighting","unlisted":false},{"type":"link","href":"/docs/tutorials/hello-instancing","label":"Hello Instancing","docId":"tutorials/hello-instancing","unlisted":false},{"type":"link","href":"/docs/tutorials/shader-modules","label":"Shader Modules","docId":"tutorials/shader-modules","unlisted":false},{"type":"link","href":"/docs/tutorials/shader-hooks","label":"Shader Hooks","docId":"tutorials/shader-hooks","unlisted":false},{"type":"link","href":"/docs/tutorials/transform-feedback","label":"Transform Feedback","docId":"tutorials/transform-feedback","unlisted":false},{"type":"link","href":"/docs/tutorials/external-webgl-context","label":"External WebGL Contexts with MapLibre","docId":"tutorials/external-webgl-context","unlisted":false},{"type":"link","href":"/docs/tutorials/whats-next","label":"What\'s Next?","docId":"tutorials/whats-next","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Guide","items":[{"type":"link","href":"/docs/api-guide/","label":"API Overview","docId":"api-guide/README","unlisted":false},{"type":"category","label":"Background","items":[{"type":"link","href":"/docs/api-guide/background/api-design","label":"API Design Philosophy","docId":"api-guide/background/api-design","unlisted":false},{"type":"link","href":"/docs/api-guide/background/learning-resources","label":"Learning Resources","docId":"api-guide/background/learning-resources","unlisted":false},{"type":"link","href":"/docs/api-guide/background/webgpu-vs-webgl","label":"WebGPU vs WebGL","docId":"api-guide/background/webgpu-vs-webgl","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"GPU Programming","items":[{"type":"link","href":"/docs/api-guide/gpu/gpu-initialization","label":"GPU Initialization","docId":"api-guide/gpu/gpu-initialization","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-resources","label":"GPU Resources","docId":"api-guide/gpu/gpu-resources","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-memory","label":"GPU Memory","docId":"api-guide/gpu/gpu-memory","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-buffers","label":"Using GPU Buffers","docId":"api-guide/gpu/gpu-buffers","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-textures","label":"Using GPU Textures","docId":"api-guide/gpu/gpu-textures","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-rendering","label":"How GPU Rendering Works","docId":"api-guide/gpu/gpu-rendering","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-parameters","label":"Using GPU Parameters","docId":"api-guide/gpu/gpu-parameters","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-bindings","label":"Understanding Bindings","docId":"api-guide/gpu/gpu-bindings","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-attributes","label":"Attributes","docId":"api-guide/gpu/gpu-attributes","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-uniforms","label":"Uniforms","docId":"api-guide/gpu/gpu-uniforms","unlisted":false},{"type":"link","href":"/docs/api-guide/gpu/gpu-storage-buffers","label":"Storage Buffers","docId":"api-guide/gpu/gpu-storage-buffers","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Shader Programming","items":[{"type":"link","href":"/docs/api-guide/shaders/shader-modules","label":"Shader Modules","docId":"api-guide/shaders/shader-modules","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Engine Programming","items":[{"type":"link","href":"/docs/api-guide/engine/","label":"Engine Programming","docId":"api-guide/engine/engine","unlisted":false},{"type":"link","href":"/docs/api-guide/engine/redraw","label":"Redraw detection","docId":"api-guide/engine/redraw","unlisted":false},{"type":"link","href":"/docs/api-guide/engine/shader-inputs","label":"Shader Inputs","docId":"api-guide/engine/shader-inputs","unlisted":false},{"type":"link","href":"/docs/api-guide/engine/interactivity","label":"Interactivity","docId":"api-guide/engine/interactivity","unlisted":false},{"type":"link","href":"/docs/api-guide/engine/scenegraph","label":"Scenegraphs","docId":"api-guide/engine/scenegraph","unlisted":false},{"type":"link","href":"/docs/api-guide/engine/transforms","label":"GPU Computations and Transforms","docId":"api-guide/engine/transforms","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","href":"/docs/api-reference/","label":"Overview","docId":"api-reference/README","unlisted":false},{"type":"category","label":"@luma.gl/core","items":[{"type":"link","href":"/docs/api-reference/core/","label":"Overview","docId":"api-reference/core/README","unlisted":false},{"type":"link","href":"/docs/api-reference/core/luma","label":"luma","docId":"api-reference/core/luma","unlisted":false},{"type":"link","href":"/docs/api-reference/core/adapter","label":"Adapter","docId":"api-reference/core/adapter","unlisted":false},{"type":"link","href":"/docs/api-reference/core/device","label":"Device","docId":"api-reference/core/device","unlisted":false},{"type":"link","href":"/docs/api-reference/core/device-info","label":"DeviceInfo","docId":"api-reference/core/device-info","unlisted":false},{"type":"link","href":"/docs/api-reference/core/device-features","label":"DeviceFeatures","docId":"api-reference/core/device-features","unlisted":false},{"type":"link","href":"/docs/api-reference/core/device-limits","label":"DeviceLimits","docId":"api-reference/core/device-limits","unlisted":false},{"type":"link","href":"/docs/api-reference/core/canvas-context","label":"CanvasContext","docId":"api-reference/core/canvas-context","unlisted":false},{"type":"link","href":"/docs/api-reference/core/parameters","label":"GPU Parameters","docId":"api-reference/core/parameters","unlisted":false},{"type":"link","href":"/docs/api-reference/core/bindings","label":"Bindings","docId":"api-reference/core/bindings","unlisted":false},{"type":"link","href":"/docs/api-reference/core/shader-layout","label":"ShaderLayout","docId":"api-reference/core/shader-layout","unlisted":false},{"type":"link","href":"/docs/api-reference/core/vertex-formats","label":"Vertex Formats","docId":"api-reference/core/vertex-formats","unlisted":false},{"type":"link","href":"/docs/api-reference/core/texture-formats","label":"Texture Formats","docId":"api-reference/core/texture-formats","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/buffer","label":"Buffer","docId":"api-reference/core/resources/buffer","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/compute-pass","label":"ComputePass","docId":"api-reference/core/resources/compute-pass","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/compute-pipeline","label":"ComputePipeline","docId":"api-reference/core/resources/compute-pipeline","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/fence","label":"Fence","docId":"api-reference/core/resources/fence","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/framebuffer","label":"Framebuffer","docId":"api-reference/core/resources/framebuffer","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/render-pass","label":"RenderPass","docId":"api-reference/core/resources/render-pass","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/render-pipeline","label":"RenderPipeline","docId":"api-reference/core/resources/render-pipeline","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/sampler","label":"Sampler","docId":"api-reference/core/resources/sampler","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/shader","label":"Shader","docId":"api-reference/core/resources/shader","unlisted":false},{"type":"link","href":"/docs/api-reference/core/shader-logs","label":"Shader Logs","docId":"api-reference/core/shader-logs","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/texture","label":"Texture","docId":"api-reference/core/resources/texture","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/texture-view","label":"TextureView","docId":"api-reference/core/resources/texture-view","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/transform-feedback","label":"TransformFeedback","docId":"api-reference/core/resources/transform-feedback","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/query-set","label":"QuerySet","docId":"api-reference/core/resources/query-set","unlisted":false},{"type":"link","href":"/docs/api-reference/core/resources/vertex-array","label":"VertexArray","docId":"api-reference/core/resources/vertex-array","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/engine","items":[{"type":"link","href":"/docs/api-reference/engine/model","label":"Model","docId":"api-reference/engine/model","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/shader-inputs","label":"ShaderInputs","docId":"api-reference/engine/shader-inputs","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/animation-loop","label":"AnimationLoop","docId":"api-reference/engine/animation-loop","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/animation-loop-template","label":"AnimationLoopTemplate","docId":"api-reference/engine/animation-loop-template","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/dynamic-texture","label":"DynamicTexture","docId":"api-reference/engine/dynamic-texture","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/load-image-bitmap","label":"loadImageBitmap","docId":"api-reference/engine/load-image-bitmap","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/geometry/geometries","label":"Built-in Geometries","docId":"api-reference/engine/geometry/geometries","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/geometry/","label":"Geometry","docId":"api-reference/engine/geometry/geometry","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/animation/key-frames","label":"KeyFrames","docId":"api-reference/engine/animation/key-frames","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/animation/timeline","label":"Timeline","docId":"api-reference/engine/animation/timeline","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/scenegraph/group-node","label":"GroupNode","docId":"api-reference/engine/scenegraph/group-node","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/scenegraph/model-node","label":"ModelNode","docId":"api-reference/engine/scenegraph/model-node","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/scenegraph/scenegraph-node","label":"ScenegraphNode","docId":"api-reference/engine/scenegraph/scenegraph-node","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/pipeline-factory","label":"PipelineFactory","docId":"api-reference/engine/pipeline-factory","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/shader-factory","label":"ShaderFactory","docId":"api-reference/engine/shader-factory","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/passes/shader-pass-renderer","label":"ShaderPassRenderer","docId":"api-reference/engine/passes/shader-pass-renderer","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/compute/swap","label":"Swap","docId":"api-reference/engine/compute/swap","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/compute/computation","label":"Computation","docId":"api-reference/engine/compute/computation","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/compute/buffer-transform","label":"BufferTransform","docId":"api-reference/engine/compute/buffer-transform","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/compute/texture-transform","label":"TextureTransform","docId":"api-reference/engine/compute/texture-transform","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/gpgpu/gpu-point-in-polygon","label":"GPUPointInPolygon","docId":"api-reference/engine/gpgpu/gpu-point-in-polygon","unlisted":false},{"type":"link","href":"/docs/api-reference/engine/gpgpu/histopyramid","label":"Histopyramid","docId":"api-reference/engine/gpgpu/histopyramid","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/gltf","items":[{"type":"link","href":"/docs/api-reference/gltf/","label":"Overview","docId":"api-reference/gltf/README","unlisted":false},{"type":"link","href":"/docs/api-reference/gltf/gltf-extensions","label":"glTF Extensions","docId":"api-reference/gltf/gltf-extensions","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/shadertools","items":[{"type":"category","label":"Shader Modules","items":[{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/fp32","label":"fp32 (32-bit Floating Point)","docId":"api-reference/shadertools/shader-modules/fp32","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/fp64","label":"fp64 (64-bit Floating Point)","docId":"api-reference/shadertools/shader-modules/fp64","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/pbr-material","label":"pbrMaterial","docId":"api-reference/shadertools/shader-modules/pbr-material","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/phong-material","label":"phongMaterial","docId":"api-reference/shadertools/shader-modules/phong-material","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/gouraud-material","label":"gouraudMaterial","docId":"api-reference/shadertools/shader-modules/gouraud-material","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/picking","label":"picking","docId":"api-reference/shadertools/shader-modules/picking","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-modules/project","label":"project","docId":"api-reference/shadertools/shader-modules/project","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Shader Passes","items":[{"type":"link","href":"/docs/api-reference/shadertools/shader-passes/image-processing","label":"Image Processing","docId":"api-reference/shadertools/shader-passes/image-processing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","href":"/docs/api-reference/shadertools/","label":"Overview","docId":"api-reference/shadertools/README","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-module","label":"ShaderModule","docId":"api-reference/shadertools/shader-module","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-assembler","label":"ShaderAssembler","docId":"api-reference/shadertools/shader-assembler","unlisted":false},{"type":"link","href":"/docs/api-reference/shadertools/shader-info","label":"Shader Parsing","docId":"api-reference/shadertools/shader-info","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/test-utils","items":[{"type":"link","href":"/docs/api-reference/test-utils/","label":"Overview","docId":"api-reference/test-utils/README","unlisted":false},{"type":"link","href":"/docs/api-reference/test-utils/snapshot-test-runner","label":"SnapshotTestRunner","docId":"api-reference/test-utils/snapshot-test-runner","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgl","items":[{"type":"link","href":"/docs/api-reference/webgl/","label":"@luma.gl/webgl","docId":"api-reference/webgl/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgpu","items":[{"type":"link","href":"/docs/api-reference/webgpu/","label":"Overview","docId":"api-reference/webgpu/README","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer Guide","items":[{"type":"link","href":"/docs/developer-guide/","label":"Developer Guide","docId":"developer-guide/README","unlisted":false},{"type":"link","href":"/docs/developer-guide/installing","label":"Installing","docId":"developer-guide/installing","unlisted":false},{"type":"link","href":"/docs/developer-guide/debugging","label":"Debugging","docId":"developer-guide/debugging","unlisted":false},{"type":"link","href":"/docs/developer-guide/testing","label":"Testing","docId":"developer-guide/testing","unlisted":false},{"type":"link","href":"/docs/developer-guide/profiling","label":"Profiling","docId":"developer-guide/profiling","unlisted":false},{"type":"link","href":"/docs/developer-guide/bundling","label":"Bundling","docId":"developer-guide/bundling","unlisted":false},{"type":"link","href":"/docs/developer-guide/contributing","label":"Contributing","docId":"developer-guide/contributing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Legacy Guides","items":[{"type":"link","href":"/docs/legacy/porting-guide","label":"Porting Guide","docId":"legacy/porting-guide","unlisted":false},{"type":"link","href":"/docs/legacy/legacy-upgrade-guide","label":"Legacy Upgrade Guide","docId":"legacy/legacy-upgrade-guide","unlisted":false},{"type":"link","href":"/docs/legacy/legacy-whats-new","label":"Legacy What\'s New","docId":"legacy/legacy-whats-new","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"api-guide/background/api-design":{"id":"api-guide/background/api-design","title":"API Design Philosophy","description":"This article provides some background on luma.gl\'s API design philosophy.","sidebar":"defaultSidebar"},"api-guide/background/learning-resources":{"id":"api-guide/background/learning-resources","title":"Learning Resources","description":"WebGPU","sidebar":"defaultSidebar"},"api-guide/background/webgpu-vs-webgl":{"id":"api-guide/background/webgpu-vs-webgl","title":"WebGPU vs WebGL","description":"This page is a collection of developer notes on the differences between WebGPU and WebGL.","sidebar":"defaultSidebar"},"api-guide/engine/engine":{"id":"api-guide/engine/engine","title":"Engine Programming","description":"The @luma.gl/engine modules provides higher-level 3D engine functionality that makes it easier to build 3D applications.","sidebar":"defaultSidebar"},"api-guide/engine/interactivity":{"id":"api-guide/engine/interactivity","title":"Interactivity","description":"Event Management","sidebar":"defaultSidebar"},"api-guide/engine/redraw":{"id":"api-guide/engine/redraw","title":"Redraw detection","description":"luma.gl components track when they need to be redrawn. A number of classes expose a common pair of methods:","sidebar":"defaultSidebar"},"api-guide/engine/scenegraph":{"id":"api-guide/engine/scenegraph","title":"Scenegraphs","description":"The luma.gl engine provides a set of Scenegraph classes to organize Models into a hierarchy.","sidebar":"defaultSidebar"},"api-guide/engine/shader-inputs":{"id":"api-guide/engine/shader-inputs","title":"Shader Inputs","description":"Managing shader inputs (uniforms and bindings) is a big part of the responsibility of any GPU framework.","sidebar":"defaultSidebar"},"api-guide/engine/transforms":{"id":"api-guide/engine/transforms","title":"GPU Computations and Transforms","description":"Some operations can be very efficiently executed on the GPU.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-attributes":{"id":"api-guide/gpu/gpu-attributes","title":"Attributes","description":"Note that while attributes is a structured and performant mechanism to provide columnar data to shaders that works on both WebGPU and WebGL, they are rather rigid and have a number of limitations. In WebGPU a more significantly more flexible approach is to use storage buffers.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-bindings":{"id":"api-guide/gpu/gpu-bindings","title":"Understanding Bindings","description":"luma.gl offers support for setting up (\\"binding\\") data required by the GPU during shader execution, including:","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-buffers":{"id":"api-guide/gpu/gpu-buffers","title":"Using GPU Buffers","description":"Buffer Operations","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-initialization":{"id":"api-guide/gpu/gpu-initialization","title":"GPU Initialization","description":"Adapter","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-memory":{"id":"api-guide/gpu/gpu-memory","title":"GPU Memory","description":"Memory on GPU is managed through Buffer and Texture resources.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-parameters":{"id":"api-guide/gpu/gpu-parameters","title":"Using GPU Parameters","description":"luma.gl provides a unified API for controlling GPU parameters providing control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-rendering":{"id":"api-guide/gpu/gpu-rendering","title":"How GPU Rendering Works","description":"Note that the luma.gl documentation includes a series of tutorials that explain how to render with the luma.gl API.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-resources":{"id":"api-guide/gpu/gpu-resources","title":"GPU Resources","description":"A key role of the Device class is to let the application create GPU resources.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-storage-buffers":{"id":"api-guide/gpu/gpu-storage-buffers","title":"Storage Buffers","description":"storage buffers represent a flexible mechanism for providing data to shaders, they are not available in WebGL, so applications may need to consider fallbacks.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-textures":{"id":"api-guide/gpu/gpu-textures","title":"Using GPU Textures","description":"While the idea behind textures is simple in principle (a grid of pixels stored on GPU memory), GPU Textures are surprisingly complex objects.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-uniforms":{"id":"api-guide/gpu/gpu-uniforms","title":"Uniforms","description":"Uniforms are shader variables whose values can be set from JavaScript.","sidebar":"defaultSidebar"},"api-guide/README":{"id":"api-guide/README","title":"API Overview","description":"The luma.gl API enables the creation of portable GPU applications that can run on top of either WebGPU, or WebGL 2.","sidebar":"defaultSidebar"},"api-guide/shaders/shader-modules":{"id":"api-guide/shaders/shader-modules","title":"Shader Modules","description":"luma.device provides a shader module system (through the @luma.device/shadertools module) that allows you build modular shaders. The system is built around a shader \\"assembler\\", and addresses the lack of a module/import system in the GLSL and WGSL languages. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.","sidebar":"defaultSidebar"},"api-reference/core/adapter":{"id":"api-reference/core/adapter","title":"Adapter","description":"An Adapter is a factory that creates Device instances for a specific backend (e.g. WebGPU or WebGL).","sidebar":"defaultSidebar"},"api-reference/core/bindings":{"id":"api-reference/core/bindings","title":"Bindings","description":"A key responsibility of any GPU API is to enable the application to","sidebar":"defaultSidebar"},"api-reference/core/buffer-layout":{"id":"api-reference/core/buffer-layout","title":"BufferLayout","description":"The bufferLayout type provides information about how the application is planning to"},"api-reference/core/canvas-context":{"id":"api-reference/core/canvas-context","title":"CanvasContext","description":"A CanvasContext holds a connection between a GPU Device and canvas, (either an HTML ` element, aka HTMLCanvasELement, or an OffscreenCanvas`).","sidebar":"defaultSidebar"},"api-reference/core/device":{"id":"api-reference/core/device","title":"Device","description":"The Device class manages the application\'s connection with the GPU,","sidebar":"defaultSidebar"},"api-reference/core/device-features":{"id":"api-reference/core/device-features","title":"DeviceFeatures","description":"The luma.gl Device provides a device \\"feature\\" system that allows applications","sidebar":"defaultSidebar"},"api-reference/core/device-info":{"id":"api-reference/core/device-info","title":"DeviceInfo","description":"The device.info field holds a small DeviceInfo object that provides information about the device, such as driver, GPU, shading language etc.","sidebar":"defaultSidebar"},"api-reference/core/device-limits":{"id":"api-reference/core/device-limits","title":"DeviceLimits","description":"The device.limits field contains limits object that indicates what the current platform supports.","sidebar":"defaultSidebar"},"api-reference/core/luma":{"id":"api-reference/core/luma","title":"luma","description":"The luma namespace provides luma.gl applications","sidebar":"defaultSidebar"},"api-reference/core/parameters":{"id":"api-reference/core/parameters","title":"GPU Parameters","description":"GPU parameters provide control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"defaultSidebar"},"api-reference/core/README":{"id":"api-reference/core/README","title":"Overview","description":"The @luma.gl/core module provides an abstract API that enables application code","sidebar":"defaultSidebar"},"api-reference/core/resources/buffer":{"id":"api-reference/core/resources/buffer","title":"Buffer","description":"Holds a block of GPU memory. The length of a buffer cannot be changed after creation.","sidebar":"defaultSidebar"},"api-reference/core/resources/command-encoder":{"id":"api-reference/core/resources/command-encoder","title":"CommandEncoder","description":"A command encoder offering GPU memory copying operations."},"api-reference/core/resources/compute-pass":{"id":"api-reference/core/resources/compute-pass","title":"ComputePass","description":"WebGPU only","sidebar":"defaultSidebar"},"api-reference/core/resources/compute-pipeline":{"id":"api-reference/core/resources/compute-pipeline","title":"ComputePipeline","description":"ComputePipeline is only available on WebGPU. Note on WebGL you can still perform","sidebar":"defaultSidebar"},"api-reference/core/resources/external-texture":{"id":"api-reference/core/resources/external-texture","title":"ExternalTexture","description":"WebGPU only."},"api-reference/core/resources/fence":{"id":"api-reference/core/resources/fence","title":"Fence","description":"A GPU->CPU synchronization primitive that signals / resolves when any GPU commands submitted prior to the Fence have completed.","sidebar":"defaultSidebar"},"api-reference/core/resources/framebuffer":{"id":"api-reference/core/resources/framebuffer","title":"Framebuffer","description":"A Framebuffer holds textures that will be used as render targets for RenderPipelines","sidebar":"defaultSidebar"},"api-reference/core/resources/query-set":{"id":"api-reference/core/resources/query-set","title":"QuerySet","description":"This page is incomplete.","sidebar":"defaultSidebar"},"api-reference/core/resources/render-pass":{"id":"api-reference/core/resources/render-pass","title":"RenderPass","description":"Usage","sidebar":"defaultSidebar"},"api-reference/core/resources/render-pipeline":{"id":"api-reference/core/resources/render-pipeline","title":"RenderPipeline","description":"A RenderPipeline contains a matched pair of vertex and fragment shaders that can be exectued on the GPU by calling RenderPipeline.draw(). handle compilation and linking of shaders, and store uniform values. They provide draw call which allows the application to run the shaders on specified input data.","sidebar":"defaultSidebar"},"api-reference/core/resources/resource":{"id":"api-reference/core/resources/resource","title":"Resource","description":"Resource is the abstract base class for GPU objects created by a Device. It standardizes common fields such as identifiers and backend handles that are shared across buffers, textures, passes, and similar GPU resources."},"api-reference/core/resources/sampler":{"id":"api-reference/core/resources/sampler","title":"Sampler","description":"A Sampler is an immutable object that holds a set of sampling parameters for texture access.","sidebar":"defaultSidebar"},"api-reference/core/resources/shader":{"id":"api-reference/core/resources/shader","title":"Shader","description":"The Shader class holds a compiled shader.","sidebar":"defaultSidebar"},"api-reference/core/resources/texture":{"id":"api-reference/core/resources/texture","title":"Texture","description":"A Texture are GPU objects that contain one or more images that all have the same image format, that can be accessed from shaders.","sidebar":"defaultSidebar"},"api-reference/core/resources/texture-view":{"id":"api-reference/core/resources/texture-view","title":"TextureView","description":"A TextureView is a view onto some subset of the texture subresources defined by a particular Texture.","sidebar":"defaultSidebar"},"api-reference/core/resources/transform-feedback":{"id":"api-reference/core/resources/transform-feedback","title":"TransformFeedback","description":"WebGPU not supported","sidebar":"defaultSidebar"},"api-reference/core/resources/vertex-array":{"id":"api-reference/core/resources/vertex-array","title":"VertexArray","description":"A VertexArray stores a set of vertex attribute bindings, including the index buffer.","sidebar":"defaultSidebar"},"api-reference/core/shader-layout":{"id":"api-reference/core/shader-layout","title":"ShaderLayout","description":"A ShaderLayout object describes the static structure a `RenderPipeline, \\"location\\" and structure of binding points of shaders,","sidebar":"defaultSidebar"},"api-reference/core/shader-logs":{"id":"api-reference/core/shader-logs","title":"Shader Logs","description":"Shader compilation and linking logs contain important information about .","sidebar":"defaultSidebar"},"api-reference/core/texture-formats":{"id":"api-reference/core/texture-formats","title":"Texture Formats","description":"The term \\"texture format\\" here refers to how pixels are stored in memory, which is an important property of a GPU Texture","sidebar":"defaultSidebar"},"api-reference/core/uniform-buffer-layout":{"id":"api-reference/core/uniform-buffer-layout","title":"UniformBufferLayout","description":"A helper class that lets the application describe the contents of a uniform block and then perform setUniforms({uniform: value}) calls on it, manipulating individual values without concern for memory layout requirements."},"api-reference/core/uniform-store":{"id":"api-reference/core/uniform-store","title":"UniformStore","description":"A uniform store holds uniform values for a set of different uniform buffers,"},"api-reference/core/vertex-formats":{"id":"api-reference/core/vertex-formats","title":"Vertex Formats","description":"The format of a vertex attribute indicates how data in a vertex buffer is laid out,","sidebar":"defaultSidebar"},"api-reference/engine/animation-loop":{"id":"api-reference/engine/animation-loop","title":"AnimationLoop","description":"Manages an animation loop and optionally a WebGL context and a WebGL canvas. It provides a number of features related to initialization and animation of a WebGL context.","sidebar":"defaultSidebar"},"api-reference/engine/animation-loop-template":{"id":"api-reference/engine/animation-loop-template","title":"AnimationLoopTemplate","description":"AnimationLoopTemplate is a helper class that creates and manages the application\'s render loop.","sidebar":"defaultSidebar"},"api-reference/engine/animation/key-frames":{"id":"api-reference/engine/animation/key-frames","title":"KeyFrames","description":"Manages key frame animation data. Associates time points with arbitrary data and provides methods to access key times and data, and an interpolation factor, based on the current time.","sidebar":"defaultSidebar"},"api-reference/engine/animation/timeline":{"id":"api-reference/engine/animation/timeline","title":"Timeline","description":"Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods (play, pause) assume that the update method is being called once per frame with a \\"global time\\". This automatically done for AnimationLoop.timeline object.","sidebar":"defaultSidebar"},"api-reference/engine/compute/buffer-transform":{"id":"api-reference/engine/compute/buffer-transform","title":"BufferTransform","description":"WebGPU not supported","sidebar":"defaultSidebar"},"api-reference/engine/compute/computation":{"id":"api-reference/engine/compute/computation","title":"Computation","description":"The Computation class is a high-level class in the luma.gl API. It brings together all GPU functionality needed to run GPU compute shaders, in a single, easy-to-use interface.","sidebar":"defaultSidebar"},"api-reference/engine/compute/swap":{"id":"api-reference/engine/compute/swap","title":"Swap","description":"Swap is a helper class to support buffer and texture management when doing repeated transformations or computations on a block of data (memory). Swap enables a sequence of repeated / successive data transformations to be run by reusing just two resources (two buffers or two textures), effectively supporting a simple double buffering techniques.","sidebar":"defaultSidebar"},"api-reference/engine/compute/texture-transform":{"id":"api-reference/engine/compute/texture-transform","title":"TextureTransform","description":"TextureTransform is responsible for managing resources and state required for reading from and/or writing to Texture objects. It auto creates Texture objects when requested, creates Framebuffer objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.","sidebar":"defaultSidebar"},"api-reference/engine/compute/transform-needs-update":{"id":"api-reference/engine/compute/transform-needs-update","title":"Transform","description":"This page needs update for luma.gl v9"},"api-reference/engine/dynamic-texture":{"id":"api-reference/engine/dynamic-texture","title":"DynamicTexture","description":"DynamicTexture was called AsyncTexture in v9.1","sidebar":"defaultSidebar"},"api-reference/engine/geometry/geometries":{"id":"api-reference/engine/geometry/geometries","title":"Built-in Geometries","description":"@luma.gl/engine provides several built in geometry primitives (subclasses of Geometry). The generated geometry instances will have indices and POSITION, NORMAL and TEXCOORD_0 attributes.","sidebar":"defaultSidebar"},"api-reference/engine/geometry/geometry":{"id":"api-reference/engine/geometry/geometry","title":"Geometry","description":"The Geometry class holds a collection of vertex array attributes representing a geometric primitive.","sidebar":"defaultSidebar"},"api-reference/engine/gpgpu/gpu-point-in-polygon":{"id":"api-reference/engine/gpgpu/gpu-point-in-polygon","title":"GPUPointInPolygon","description":"GPUPointInPolygon provides GPU accelerated PIP (Point-In-Polygon) testing functionality. A given set of 2D points and one or more 2D polygons, it computes, whether each point is inside or outside of any polygon.","sidebar":"defaultSidebar"},"api-reference/engine/gpgpu/histopyramid":{"id":"api-reference/engine/gpgpu/histopyramid","title":"Histopyramid","description":"Histopyramid aka Histogram Pyramid provides an efficient way of converting sparse matrix (represented by a texture) into list of coordinates (points). Where each active cell in the matrix can contribute to 1 or more points. All operations of the algorithm can be executed in parallel hence are performed on the GPU.","sidebar":"defaultSidebar"},"api-reference/engine/load-image-bitmap":{"id":"api-reference/engine/load-image-bitmap","title":"loadImageBitmap","description":"A simple small utility to load images from URLs. The loaded ImageBitmaps can be used to create textures.","sidebar":"defaultSidebar"},"api-reference/engine/model":{"id":"api-reference/engine/model","title":"Model","description":"The Model class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface.","sidebar":"defaultSidebar"},"api-reference/engine/passes/shader-pass-renderer":{"id":"api-reference/engine/passes/shader-pass-renderer","title":"ShaderPassRenderer","description":"A ShaderPassRenderer takes an source texture and applies a sequence of ShaderPasses and returns an output texture that can be rendered to the screen.","sidebar":"defaultSidebar"},"api-reference/engine/pipeline-factory":{"id":"api-reference/engine/pipeline-factory","title":"PipelineFactory","description":"The PipelineFactory class provides a createRenderPipeline() method that caches and reuses render pipelines.","sidebar":"defaultSidebar"},"api-reference/engine/README":{"id":"api-reference/engine/README","title":"Overview","description":"The @luma.gl/engine module contains a set of basic 3D framework classes intended"},"api-reference/engine/scenegraph/group-node":{"id":"api-reference/engine/scenegraph/group-node","title":"GroupNode","description":"A GroupNode is a subclass of ScenegraphNode that holds a list of ScenegraphNode children. Since . A GroupNode can be a child of another GroupNode and thus be used to create hierarchical scene graphs.","sidebar":"defaultSidebar"},"api-reference/engine/scenegraph/model-node":{"id":"api-reference/engine/scenegraph/model-node","title":"ModelNode","description":"ModelNode is simply a ScenegraphNode that contains a Model for drawing.","sidebar":"defaultSidebar"},"api-reference/engine/scenegraph/scenegraph-node":{"id":"api-reference/engine/scenegraph/scenegraph-node","title":"ScenegraphNode","description":"The ScenegraphNode is a base class for objects in the luma.gl scene graph, such as Model, Group and Camera. It holds the transformation matrix (i.e. the position, orientation and scale) of the object.","sidebar":"defaultSidebar"},"api-reference/engine/shader-factory":{"id":"api-reference/engine/shader-factory","title":"ShaderFactory","description":"The ShaderFactory class provides a createShader() method that caches and reuses Shader resources.","sidebar":"defaultSidebar"},"api-reference/engine/shader-inputs":{"id":"api-reference/engine/shader-inputs","title":"ShaderInputs","description":"ShaderInputs holds uniform and binding values for one or more shader modules,","sidebar":"defaultSidebar"},"api-reference/gltf/gltf-extensions":{"id":"api-reference/gltf/gltf-extensions","title":"glTF Extensions","description":"Below is a table covering most published glTF 2.0 extensions (both Khronos KHR and vendor\u2010specific EXT/MSFT_ etc.) and whether luma.gl currently offers \u201cbuilt in\u201d handling for them.","sidebar":"defaultSidebar"},"api-reference/gltf/README":{"id":"api-reference/gltf/README","title":"Overview","description":"The @luma.gl/gltf modules utilities for turning glTF data into a","sidebar":"defaultSidebar"},"api-reference/README":{"id":"api-reference/README","title":"Overview","description":"luma.gl is packaged and published as a suite of composable npm modules, so that applications can choose what functionality they need.","sidebar":"defaultSidebar"},"api-reference/shadertools/README":{"id":"api-reference/shadertools/README","title":"Overview","description":"@luma.gl/shadertools provides:","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-assembler":{"id":"api-reference/shadertools/shader-assembler","title":"ShaderAssembler","description":"The functionality of the shadertools module shader system is primarily exposed","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-conventions":{"id":"api-reference/shadertools/shader-conventions","title":"Shader Modules","description":"This describes informal conventions that luma.gl applies to its shaders."},"api-reference/shadertools/shader-info":{"id":"api-reference/shadertools/shader-info","title":"Shader Parsing","description":"It is sometimes useful to be able to inspect shader source code","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-module":{"id":"api-reference/shadertools/shader-module","title":"ShaderModule","description":"In luma.gl, reusable shader modules are defined by objects that conform to the ShaderModule type.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/fp32":{"id":"api-reference/shadertools/shader-modules/fp32","title":"fp32 (32-bit Floating Point)","description":"Provides \\"improved\\" 32-bit math support to GPU shaders on certain platforms,","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/fp64":{"id":"api-reference/shadertools/shader-modules/fp64","title":"fp64 (64-bit Floating Point)","description":"Provides basic 64-bit math support in GPU shaders:","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/gouraud-material":{"id":"api-reference/shadertools/shader-modules/gouraud-material","title":"gouraudMaterial","description":"The goraudMaterial shader module provides functions to apply gouraud shading (per vertex) to your geometry.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/gpu-picking":{"id":"api-reference/shadertools/shader-modules/gpu-picking","title":"gpuPicking","description":"Provides support for GPU-based picking."},"api-reference/shadertools/shader-modules/lights":{"id":"api-reference/shadertools/shader-modules/lights","title":"lights","description":"The lights` shader module collects uniforms describing the lights in a scene."},"api-reference/shadertools/shader-modules/pbr-material":{"id":"api-reference/shadertools/shader-modules/pbr-material","title":"pbrMaterial","description":"Implements Physically Based Shading of a microfacet surface defined by a glTF material.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/phong-material":{"id":"api-reference/shadertools/shader-modules/phong-material","title":"phongMaterial","description":"This phongMaterial shader module provides functions to apply phong shading (per fragment) to your geometry.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/picking":{"id":"api-reference/shadertools/shader-modules/picking","title":"picking","description":"The picking shader module in @luma.gl/shadertools is deprecated. Use the picking modules in @luma.gl/engine instead.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/project":{"id":"api-reference/shadertools/shader-modules/project","title":"project","description":"A basic projection module.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-passes/image-processing":{"id":"api-reference/shadertools/shader-passes/image-processing","title":"Image Processing","description":"Screen space effects packaged as reusable shader modules in @luma.gl/effects based on the glfx library.","sidebar":"defaultSidebar"},"api-reference/test-utils/README":{"id":"api-reference/test-utils/README","title":"Overview","description":"@luma.gl/test-utils contains support for testing luma.gl programs.","sidebar":"defaultSidebar"},"api-reference/test-utils/snapshot-test-runner":{"id":"api-reference/test-utils/snapshot-test-runner","title":"SnapshotTestRunner","description":"Client-side utility for browser-based WebGL render tests.","sidebar":"defaultSidebar"},"api-reference/webgl/README":{"id":"api-reference/webgl/README","title":"@luma.gl/webgl","description":"WebGL Device Adapter","sidebar":"defaultSidebar"},"api-reference/webgpu/README":{"id":"api-reference/webgpu/README","title":"Overview","description":"WebGPU Device Adapter","sidebar":"defaultSidebar"},"developer-guide/bundling":{"id":"developer-guide/bundling","title":"Bundling","description":"Optimizing for Bundle Size","sidebar":"defaultSidebar"},"developer-guide/contributing":{"id":"developer-guide/contributing","title":"Contributing","description":"luma.gl welcomes contributions from the community. Smaller fixes","sidebar":"defaultSidebar"},"developer-guide/debugging":{"id":"developer-guide/debugging","title":"Debugging","description":"Why GPU Debugging can be hard","sidebar":"defaultSidebar"},"developer-guide/editing":{"id":"developer-guide/editing","title":"Editing","description":"Shader Syntax Highlighting"},"developer-guide/installing":{"id":"developer-guide/installing","title":"Installing","description":"luma.gl is published as a suite of npm modules. Each module responsible for a particular part of the rendering stack.","sidebar":"defaultSidebar"},"developer-guide/profiling":{"id":"developer-guide/profiling","title":"Profiling","description":"GPU programming is all about performance, so having tools to systematically","sidebar":"defaultSidebar"},"developer-guide/README":{"id":"developer-guide/README","title":"Developer Guide","description":"This developer guide focuses on the practicalities of developing with the luma.gl framework,","sidebar":"defaultSidebar"},"developer-guide/testing":{"id":"developer-guide/testing","title":"Testing","description":"Testing webgl programs can be tricky...","sidebar":"defaultSidebar"},"faq":{"id":"faq","title":"FAQ","description":"How do I draw to the screen in luma.gl?"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"Refer to the developer guide to learn how to install luma.gl."},"legacy/legacy-upgrade-guide":{"id":"legacy/legacy-upgrade-guide","title":"Legacy Upgrade Guide","description":"This page contains upgrade guides for older luma.gl releases (up through v8.5). For upgrading to luma.gl v9, refer to the main Upgrade Guide.","sidebar":"defaultSidebar"},"legacy/legacy-whats-new":{"id":"legacy/legacy-whats-new","title":"Legacy What\'s New","description":"This page contains release notes for older luma.gl releases (up through v8.5). For luma.gl v9, refer to the main Whats\' New page.","sidebar":"defaultSidebar"},"legacy/porting-guide":{"id":"legacy/porting-guide","title":"Porting Guide","description":"Given that the changes in the v9 API are quite extensive, this separate porting guide is provided to hopefully help plan the upgrade process.","sidebar":"defaultSidebar"},"README":{"id":"README","title":"Overview","description":"luma.gl is a modern GPU toolkit for the Web, focused on processing and visualization of big data.","sidebar":"defaultSidebar"},"tutorials/external-webgl-context":{"id":"tutorials/external-webgl-context","title":"External WebGL Contexts with MapLibre","description":"This guide shows how to connect luma.gl to a WebGL context that is created and owned by MapLibre GL JS. It uses the webgl2Adapter.attach API to wrap the map\'s context in a WebGLDevice and keep a WebGLCanvasContext synchronized with MapLibre\'s canvas.","sidebar":"defaultSidebar"},"tutorials/hello-cube":{"id":"tutorials/hello-cube","title":"Hello Cube","description":"This tutorial demonstrates how to render a spinning textured cube using luma.gl\'s cross-platform rendering APIs.","sidebar":"defaultSidebar"},"tutorials/hello-instancing":{"id":"tutorials/hello-instancing","title":"Hello Instancing","description":"This tutorial illustrates instanced drawing with luma.gl using both WGSL and GLSL shaders and also shows how a custom luma.gl shader module can be used to pass colors.","sidebar":"defaultSidebar"},"tutorials/hello-triangle":{"id":"tutorials/hello-triangle","title":"Hello Triangle","description":"This tutorial demonstrates how to draw a triangle using luma.gl\'s cross-platform rendering APIs.","sidebar":"defaultSidebar"},"tutorials/lighting":{"id":"tutorials/lighting","title":"Lighting","description":"Add Phong shading to a textured cube using luma.gl\'s shader module system.","sidebar":"defaultSidebar"},"tutorials/README":{"id":"tutorials/README","title":"Setup","description":"These tutorial pages were originally added before the current luma.gl v9 API was released.","sidebar":"defaultSidebar"},"tutorials/shader-hooks":{"id":"tutorials/shader-hooks","title":"Shader Hooks","description":"Shader hooks let shader modules inject code into designated points in a shader. This example defines an OFFSET_POSITION hook that two modules use to shift geometry left or right.","sidebar":"defaultSidebar"},"tutorials/shader-modules":{"id":"tutorials/shader-modules","title":"Shader Modules","description":"This tutorial shows how to build reusable shader functionality with luma.gl\'s shader modules. The example below defines a custom color module that injects an HSV-to-RGB function into two different models.","sidebar":"defaultSidebar"},"tutorials/transform":{"id":"tutorials/transform","title":"Transform","description":"This tutorial uses BufferTransform to update per-instance data on the GPU and render thousands of wandering triangles. The compute shader runs in a transform feedback pass before each draw."},"tutorials/transform-feedback":{"id":"tutorials/transform-feedback","title":"Transform Feedback","description":"This tutorial demonstrates animating geometry using transform feedback via the BufferTransform class. A compute shader rotates triangle vertices on the GPU each frame.","sidebar":"defaultSidebar"},"tutorials/whats-next":{"id":"tutorials/whats-next","title":"What\'s Next?","description":"The tutorial pages have not yet been updated for luma.gl v9.","sidebar":"defaultSidebar"},"upgrade-guide":{"id":"upgrade-guide","title":"Upgrade Guide","description":"The upgrade guide lists breaking changes in each major and minor version of the luma.gl API, and provides information on how to update applications.","sidebar":"defaultSidebar"},"whats-new":{"id":"whats-new","title":"What\'s New","description":"This page contains news for recent luma.gl releases. For older releases (through v8.5) refer to the Legacy What\'s New page.","sidebar":"defaultSidebar"}}}}')}}]);