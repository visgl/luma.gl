/*! For license information please see 5b67d059.415ae962.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[3989],{4657:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var d=n(4848),s=n(8453);const i={},t="Model",c={id:"api-reference/engine/model",title:"Model",description:"The Model class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface.",source:"@site/../docs/api-reference/engine/model.md",sourceDirName:"api-reference/engine",slug:"/api-reference/engine/model",permalink:"/docs/api-reference/engine/model",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/engine/model.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"VertexArray",permalink:"/docs/api-reference/core/resources/vertex-array"},next:{title:"ShaderInputs",permalink:"/docs/api-reference/engine/shader-inputs"}},o={},l=[{value:"Usage",id:"usage",level:2},{value:"Provide attribute data using Buffer",id:"provide-attribute-data-using-buffer",level:3},{value:"Types",id:"types",level:2},{value:"<code>ModelProps</code>",id:"modelprops",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>renderPipeline: RenderPipeline</code>",id:"renderpipeline-renderpipeline",level:3},{value:"instanceCount: number",id:"instancecount-number",level:3},{value:"vertexCount: number",id:"vertexcount-number",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(device: Device, props: ModelProps)</code>",id:"constructordevice-device-props-modelprops",level:3},{value:"<code>destroy(): void</code>",id:"destroy-void",level:3},{value:"<code>draw(options: DrawOptions): boolean</code>",id:"drawoptions-drawoptions-boolean",level:3},{value:"<code>setVertexCount(): void</code>",id:"setvertexcount-void",level:3},{value:"<code>setInstanceCount(); void</code>",id:"setinstancecount-void",level:3},{value:"<code>setGeometry(); void</code>",id:"setgeometry-void",level:3},{value:"<code>setAttributes(attributes: object, options?): void</code>",id:"setattributesattributes-object-options-void",level:3},{value:"<code>setUniforms(uniforms: object): void</code> (Deprecated)",id:"setuniformsuniforms-object-void-deprecated",level:3},{value:"<code>updateModuleSettings(moduleSettings: object): void</code> (Deprecated)",id:"updatemodulesettingsmodulesettings-object-void-deprecated",level:3}];function a(e){const r={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(r.h1,{id:"model",children:"Model"}),"\n",(0,d.jsxs)(r.p,{children:["The ",(0,d.jsx)(r.code,{children:"Model"})," class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface."]}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"Model"})," manages the following responsibilities:"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"render pipeline creation"})," -"]}),"\n",(0,d.jsx)(r.li,{children:(0,d.jsx)(r.strong,{children:"attributes"})}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"bindings"})," these can reference textures and uniform buffers"]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"uniforms"})," WebGL only uniforms"]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"async texture handling"})," - Model can accept AsyncTextures as bindings, deferring rendering until textures have loaded."]}),"\n",(0,d.jsx)(r.li,{children:(0,d.jsx)(r.strong,{children:"shader module injection"})}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.strong,{children:"debugging"})," - Detailed debug logging of draw calls by setting ",(0,d.jsx)(r.code,{children:"luma.log.level"})," in the browser console."]}),"\n"]}),"\n",(0,d.jsxs)(r.p,{children:["The ",(0,d.jsx)(r.code,{children:"Model"})," class integrates:"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:["The ",(0,d.jsx)(r.code,{children:"@luma.gl/shadertools"})," shader module system: ",(0,d.jsxs)(r.a,{href:"/docs/api-reference/shadertools/shader-assembler",children:["see ",(0,d.jsx)(r.code,{children:"Shader Assembly"})]}),"."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"ShaderInputs"})," for uniform and binding managment."]}),"\n",(0,d.jsxs)(r.li,{children:["The ",(0,d.jsx)(r.code,{children:"Geometry"})," classes - accepts a [",(0,d.jsx)(r.code,{children:"Mesh"}),"] or a ",(0,d.jsx)(r.a,{href:"/docs/api-reference/engine/geometry",children:(0,d.jsx)(r.code,{children:"Geometry"})})," instance, plus any additional attributes for instanced rendering)"]}),"\n"]}),"\n",(0,d.jsx)(r.h2,{id:"usage",children:"Usage"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-typescript",children:"import {Model} from `@luma.gl/engine`;\n"})}),"\n",(0,d.jsx)(r.p,{children:"One of the simplest way to provide attribute data is by using a Geometry object."}),"\n",(0,d.jsx)(r.p,{children:"Create model object by passing shaders, uniforms, geometry and render it by passing updated uniforms."}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-typescript",children:"import {Model, CubeGeometry} from `@luma.gl/engine`;\n\nconst model = new Model(device, {\n  source: WGSL_SHADER,\n  vs: GLSL_VERTEX_SHADER,\n  fs: GLSL_FRAGMENT_SHADER,\n  geometry: new CubeGeometry(),\n  bindings: {\n    uSampler: texture\n  },\n})\n"})}),"\n",(0,d.jsx)(r.h3,{id:"provide-attribute-data-using-buffer",children:"Provide attribute data using Buffer"}),"\n",(0,d.jsxs)(r.p,{children:["When using ",(0,d.jsx)(r.code,{children:"Buffer"})," objects, data remains on GPU and same ",(0,d.jsx)(r.code,{children:"Buffer"})," object can be shared between multiple models."]}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-typescript",children:"// construct the model.\nconst model = new Model(device, {\n  vs: VERTEX_SHADER,\n  fs: FRAGMENT_SHADER,\n  topology: 'triangle-list',\n  vertexCount: 3,\n  attributes: {\n    attributeName1: bufferObject,\n    attributeName2: device.createBuffer(new Float32Array(...))\n  },\n  uniforms: {uSampler: texture},\n})\n"})}),"\n",(0,d.jsxs)(r.p,{children:["On each frame, call the ",(0,d.jsx)(r.code,{children:"model.draw()"})," function after updating any uniforms (typically matrices)."]}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-ts",children:"model.setUniforms({\n  uPMatrix: currentProjectionMatrix,\n  uMVMatrix: current ModelViewMatrix\n});\nmodel.draw();\n"})}),"\n",(0,d.jsx)(r.p,{children:"Debug shader source (even when shader successful)"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-ts",children:"// construct the model.\nconst model = new Model(device, {\n  vs: VERTEX_SHADER,\n  fs: FRAGMENT_SHADER,\n  debugShaders: 'always'\n});\n"})}),"\n",(0,d.jsx)(r.h2,{id:"types",children:"Types"}),"\n",(0,d.jsx)(r.h3,{id:"modelprops",children:(0,d.jsx)(r.code,{children:"ModelProps"})}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"Property"}),(0,d.jsx)(r.th,{children:"Type"}),(0,d.jsx)(r.th,{children:"Description"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"source"})}),(0,d.jsxs)(r.td,{children:[(0,d.jsx)(r.code,{children:"Shader"})," | ",(0,d.jsx)(r.em,{children:"string"})]}),(0,d.jsx)(r.td,{children:"A WGSL shader object, or WGSL source as a string."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"vs?"})}),(0,d.jsxs)(r.td,{children:[(0,d.jsx)(r.code,{children:"Shader"})," | ",(0,d.jsx)(r.em,{children:"string"})]}),(0,d.jsx)(r.td,{children:"A GLSL vertex shader object, or GLSL source as a string."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"fs?"})}),(0,d.jsxs)(r.td,{children:[(0,d.jsx)(r.code,{children:"Shader"})," | ",(0,d.jsx)(r.em,{children:"string"})]}),(0,d.jsx)(r.td,{children:"A GLSL fragment shader object, or GLSL source as a string."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"modules"})}),(0,d.jsx)(r.td,{}),(0,d.jsx)(r.td,{children:"shader modules to be applied (shadertools)."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"shaderInputs?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"ShaderInputs"})}),(0,d.jsx)(r.td,{children:"Pre-created, typed shaderInputs."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"onBeforeRender?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Function"})}),(0,d.jsx)(r.td,{children:"function to be called before every time this model is drawn."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"onAfterRender?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Function"})}),(0,d.jsx)(r.td,{children:"function to be called after every time this model is drawn."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"debugShaders?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"'error' | 'never' | 'warnings' | 'always'"})}),(0,d.jsxs)(r.td,{children:["Specify in what triggers the display shader compilation log (default: ",(0,d.jsx)(r.code,{children:"'error'"}),")."]})]})]})]}),"\n",(0,d.jsx)(r.p,{children:"Less commonly used properties:"}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"Property"}),(0,d.jsx)(r.th,{children:"Type"}),(0,d.jsx)(r.th,{children:"Description"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"pipelineFactory?"})}),(0,d.jsx)(r.td,{}),(0,d.jsxs)(r.td,{children:[(0,d.jsx)(r.code,{children:"PipelineFactory"})," to use for program creation and caching."]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"varyings?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"string[]"})}),(0,d.jsx)(r.td,{children:"WebGL: Array of vertex shader output variables (used in TransformFeedback flow)."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"bufferMode?"})}),(0,d.jsx)(r.td,{}),(0,d.jsx)(r.td,{children:"WebGL: Mode for recording vertex shader outputs (used in TransformFeedback flow)."})]})]})]}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"ModelProps"})," also include ",(0,d.jsx)(r.a,{href:"/docs/api-reference/core/resources/render-pipeline",children:(0,d.jsx)(r.code,{children:"RenderPipelineProps"})}),", which are passed through to the ",(0,d.jsx)(r.code,{children:"RenderPipeline"})," constructor, e.g:"]}),"\n",(0,d.jsxs)(r.table,{children:[(0,d.jsx)(r.thead,{children:(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.th,{children:"Property"}),(0,d.jsx)(r.th,{children:"Type"}),(0,d.jsx)(r.th,{children:"Description"})]})}),(0,d.jsxs)(r.tbody,{children:[(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"layout"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"ShaderLayout"})}),(0,d.jsx)(r.td,{children:"Describes how shader attributes and bindings are laid out."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"topology?"})}),(0,d.jsx)(r.td,{}),(0,d.jsxs)(r.td,{children:[(0,d.jsx)(r.code,{children:"'point-list'"}),", ",(0,d.jsx)(r.code,{children:"'line-list'"}),", ",(0,d.jsx)(r.code,{children:"'line-strip'"}),", ",(0,d.jsx)(r.code,{children:"'triangle-list'"})," or ",(0,d.jsx)(r.code,{children:"'triangle-strip'"}),","]})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"parameters?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"RenderPipelineParameters"})}),(0,d.jsx)(r.td,{})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"vertexCount?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"number"})}),(0,d.jsx)(r.td,{})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"instanceCount?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"number"})}),(0,d.jsx)(r.td,{})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"moduleSettings?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Record<string, any>"})}),(0,d.jsx)(r.td,{children:"any values required by shader modules (will be mapped to uniforms)."})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"uniforms?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Record<string, any>"})}),(0,d.jsx)(r.td,{children:"any non-binding uniform values"})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"bindings?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Record<string, any>"})}),(0,d.jsx)(r.td,{})]}),(0,d.jsxs)(r.tr,{children:[(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"buffers?"})}),(0,d.jsx)(r.td,{children:(0,d.jsx)(r.code,{children:"Record<string, Buffer>"})}),(0,d.jsx)(r.td,{})]})]})]}),"\n",(0,d.jsx)(r.h2,{id:"fields",children:"Fields"}),"\n",(0,d.jsx)(r.h3,{id:"renderpipeline-renderpipeline",children:(0,d.jsx)(r.code,{children:"renderPipeline: RenderPipeline"})}),"\n",(0,d.jsxs)(r.p,{children:["The model's ",(0,d.jsx)(r.code,{children:"RenderPipeline"})," instance"]}),"\n",(0,d.jsx)(r.h3,{id:"instancecount-number",children:"instanceCount: number"}),"\n",(0,d.jsx)(r.p,{children:"default value is 0."}),"\n",(0,d.jsx)(r.h3,{id:"vertexcount-number",children:"vertexCount: number"}),"\n",(0,d.jsxs)(r.p,{children:["when not provided will be deduced from ",(0,d.jsx)(r.code,{children:"geometry"})," object."]}),"\n",(0,d.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsx)(r.h3,{id:"constructordevice-device-props-modelprops",children:(0,d.jsx)(r.code,{children:"constructor(device: Device, props: ModelProps)"})}),"\n",(0,d.jsx)(r.p,{children:"The constructor for the Model class. Use this to create a new Model."}),"\n",(0,d.jsx)(r.h3,{id:"destroy-void",children:(0,d.jsx)(r.code,{children:"destroy(): void"})}),"\n",(0,d.jsx)(r.p,{children:"Free GPU resources associated with this model immediately, instead of waiting for garbage collection."}),"\n",(0,d.jsx)(r.h3,{id:"drawoptions-drawoptions-boolean",children:(0,d.jsx)(r.code,{children:"draw(options: DrawOptions): boolean"})}),"\n",(0,d.jsx)(r.p,{children:"Renders the model with provided uniforms, attributes and samplers"}),"\n",(0,d.jsx)(r.pre,{children:(0,d.jsx)(r.code,{className:"language-typescript",children:"model.draw({\n  renderPass,\n  moduleSettings = null,\n  uniforms = {},\n  attributes = {},\n  samplers = {},\n  parameters = {},\n  settings,\n  vertexArray = null,\n  transformFeedback = null\n});\n"})}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.code,{children:"Model.draw()"})," calls ",(0,d.jsx)(r.code,{children:"Program.draw()"})," but adds and extends the available parameters as follows:"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"moduleSettings"}),"=",(0,d.jsx)(r.code,{children:"null"})," (Object) - any uniforms needed by shader modules."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"attributes"}),"=",(0,d.jsx)(r.code,{children:"{}"})," (Object) - attribute definitions to be used for drawing. In additions to ",(0,d.jsx)(r.code,{children:"Buffer"})," and constant values, ",(0,d.jsx)(r.code,{children:"Model"}),"s can also accept typed arrays and attribute descriptor objects which it converts to buffers."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"uniforms"}),"=",(0,d.jsx)(r.code,{children:"{}"})," (Object) - uniform values to be used for drawing. In addition to normal uniform values, ",(0,d.jsx)(r.code,{children:"Model"})," can also accept function valued uniforms which will be evaluated before every draw call."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"animationProps"})," (Object) - if any function valued uniforms are set on the ",(0,d.jsx)(r.code,{children:"Model"}),", ",(0,d.jsx)(r.code,{children:"animationProps"})," must be provided to the draw call. The ",(0,d.jsx)(r.code,{children:"animationProps"})," are passed as parameter to the uniform functions."]}),"\n"]}),"\n",(0,d.jsxs)(r.p,{children:["The remaining draw options are passed directly to ",(0,d.jsx)(r.code,{children:"Program.draw()"}),":"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"uniforms"}),"=",(0,d.jsx)(r.code,{children:"{}"})," (Object) - uniform values to be used for drawing."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"samplers"}),"=",(0,d.jsx)(r.code,{children:"{}"})," (Object) - texture mappings to be used for drawing."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"parameters"}),"=",(0,d.jsx)(r.code,{children:"{}"})," (Object) - temporary gl settings to be applied to this draw call."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"framebuffer"}),"=",(0,d.jsx)(r.code,{children:"null"})," (",(0,d.jsx)(r.code,{children:"Framebuffer"}),") - if provided, renders into the supplied framebuffer, otherwise renders to the default framebuffer."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"transformFeedback"})," - an instance ",(0,d.jsx)(r.code,{children:"TranformFeedback"})," object, that gets activated for this rendering."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"vertexArray"})," - an instance of ",(0,d.jsx)(r.code,{children:"VertexArray"})," object, that holds required buffer bindings for vertex shader inputs."]}),"\n"]}),"\n",(0,d.jsx)(r.p,{children:"Returns"}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"boolean"})," - ",(0,d.jsx)(r.code,{children:"true"})," if the model was drawn, ",(0,d.jsx)(r.code,{children:"false"})," if not (normally because resources were still being loaded). If false is returned, then the application should attempt to draw again next frame."]}),"\n"]}),"\n",(0,d.jsx)(r.h3,{id:"setvertexcount-void",children:(0,d.jsx)(r.code,{children:"setVertexCount(): void"})}),"\n",(0,d.jsx)(r.p,{children:"Sets the number of vertices"}),"\n",(0,d.jsx)(r.h3,{id:"setinstancecount-void",children:(0,d.jsx)(r.code,{children:"setInstanceCount(); void"})}),"\n",(0,d.jsx)(r.p,{children:"How many instances will be rendered"}),"\n",(0,d.jsx)(r.h3,{id:"setgeometry-void",children:(0,d.jsx)(r.code,{children:"setGeometry(); void"})}),"\n",(0,d.jsxs)(r.p,{children:["Use a ",(0,d.jsx)(r.code,{children:"Geometry"})," instance to define attribute buffers"]}),"\n",(0,d.jsx)(r.h3,{id:"setattributesattributes-object-options-void",children:(0,d.jsx)(r.code,{children:"setAttributes(attributes: object, options?): void"})}),"\n",(0,d.jsxs)(r.p,{children:["Sets map of attributes (via ",(0,d.jsx)(r.a,{href:"/docs/api-reference/core/resources/vertex-array",children:"VertexArray.setAttributes"}),")"]}),"\n",(0,d.jsxs)(r.ul,{children:["\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"attributes"})," (Object) - map of attribute names to values."]}),"\n",(0,d.jsxs)(r.li,{children:[(0,d.jsx)(r.code,{children:"options.ignoreMissingAttributes"})," (boolean) - if ",(0,d.jsx)(r.code,{children:"true"}),", allows the function to silently ignore missing attributes."]}),"\n"]}),"\n",(0,d.jsxs)(r.h3,{id:"setuniformsuniforms-object-void-deprecated",children:[(0,d.jsx)(r.code,{children:"setUniforms(uniforms: object): void"})," (Deprecated)"]}),"\n",(0,d.jsxs)(r.p,{children:["Global uniforms key, value. Only works on WebGL, for portable code, use uniform buffers and ",(0,d.jsx)(r.code,{children:"model.setBindings()"})," instead."]}),"\n",(0,d.jsxs)(r.h3,{id:"updatemodulesettingsmodulesettings-object-void-deprecated",children:[(0,d.jsx)(r.code,{children:"updateModuleSettings(moduleSettings: object): void"})," (Deprecated)"]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,d.jsx)(r,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},1020:(e,r,n)=>{var d=n(6540),s=Symbol.for("react.element"),i=Symbol.for("react.fragment"),t=Object.prototype.hasOwnProperty,c=d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o={key:!0,ref:!0,__self:!0,__source:!0};function l(e,r,n){var d,i={},l=null,a=null;for(d in void 0!==n&&(l=""+n),void 0!==r.key&&(l=""+r.key),void 0!==r.ref&&(a=r.ref),r)t.call(r,d)&&!o.hasOwnProperty(d)&&(i[d]=r[d]);if(e&&e.defaultProps)for(d in r=e.defaultProps)void 0===i[d]&&(i[d]=r[d]);return{$$typeof:s,type:e,key:l,ref:a,props:i,_owner:c.current}}r.Fragment=i,r.jsx=l,r.jsxs=l},4848:(e,r,n)=>{e.exports=n(1020)},8453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>c});var d=n(6540);const s={},i=d.createContext(s);function t(e){const r=d.useContext(i);return d.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),d.createElement(i.Provider,{value:r},e.children)}}}]);