"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[4748],{631:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>n,metadata:()=>d,toc:()=>i});const d=JSON.parse('{"id":"api-guide/shaders/shader-modules","title":"Shader Modules","description":"luma.device provides a shader module system (through the @luma.device/shadertools module) that allows you build modular shaders. The system is built around a shader \\"assembler\\", and addresses the lack of a module/import system in the GLSL and WGSL languages. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.","source":"@site/../docs/api-guide/shaders/shader-modules.md","sourceDirName":"api-guide/shaders","slug":"/api-guide/shaders/shader-modules","permalink":"/docs/api-guide/shaders/shader-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-guide/shaders/shader-modules.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Storage Buffers","permalink":"/docs/api-guide/gpu/gpu-storage-buffers"},"next":{"title":"Engine Programming","permalink":"/docs/api-guide/engine/"}}');var a=r(4848),o=r(8453);const n={},t="Shader Modules",l={},i=[{value:"Usage",id:"usage",level:2},{value:"Structure of a Shader Module",id:"structure-of-a-shader-module",level:2},{value:"Shader Module Descriptors",id:"shader-module-descriptors",level:3}];function u(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"shader-modules",children:"Shader Modules"})}),"\n",(0,a.jsxs)(s.p,{children:["luma.device provides a shader module system (through the ",(0,a.jsx)(s.code,{children:"@luma.device/shadertools"}),' module) that allows you build modular shaders. The system is built around a shader "assembler", and addresses the lack of a module/import system in the GLSL and WGSL languages. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.']}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:'Enables you to import and "inject" prepackaged modules of shader code into your shaders.'}),"\n",(0,a.jsx)(s.li,{children:"Allows you to package up reusable GLSL and/or WGSL code as shader modules."}),"\n",(0,a.jsx)(s.li,{children:"Adds GPU detection and a measure of portability your shaders."}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsxs)(s.p,{children:["To add/inject existing modules into your shaders, just add the modules parameter to your ",(0,a.jsx)(s.code,{children:"assembleShaders"})," call:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"import {shaderModule} from 'library-of-shader-modules';\nconst {vs, fs, getUniforms, moduleMap} = assembleShaders(device, {\n  fs: '...',\n  vs: '...',\n  modules: [shaderModule],\n  ...\n})\n"})}),"\n",(0,a.jsx)(s.p,{children:"To create a new shader module, you need to create a descriptor object."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"const MY_SHADER_MODULE = {\n  name: 'my-shader-module',\n  vs: ....\n  fs: null,\n  inject: {},\n  dependencies: [],\n  deprecations: [],\n  getUniforms\n};\n"})}),"\n",(0,a.jsx)(s.p,{children:"This object can be used as shader module directly:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"assembleShaders(device, {..., modules: [MY_SHADER_MODULE]});\n"})}),"\n",(0,a.jsx)(s.h2,{id:"structure-of-a-shader-module",children:"Structure of a Shader Module"}),"\n",(0,a.jsxs)(s.p,{children:["The simplest shader modules just contain one or more reusable generic global GLSL / WGLS functions that can be included either in fragment or vertex shaders (or both). The shader assembles just adds the functions to the top of the assembled shader. The ",(0,a.jsx)(s.code,{children:"fp64"})," module is an example of this type of module."]}),"\n",(0,a.jsx)(s.p,{children:'More complex shader modules contain specific vertex and/or fragment shader "chunks". In this case the shader module defines vertex shader inputs and outputs requiring more sophisticated shader generation to wire up the inputs and outputs between shader stages.'}),"\n",(0,a.jsx)(s.h3,{id:"shader-module-descriptors",children:"Shader Module Descriptors"}),"\n",(0,a.jsx)(s.p,{children:"To define a new shader module, you create a descriptor object that brings together all the necessary pieces:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-typescript",children:"import type {ShaderModule} from '@luma.gl/shadertools';\n\nexport const myShaderModule = {\n  name: 'my-shader-module',\n  vs: '...',\n  fs: '...',\n  inject: {},\n  dependencies: [],\n  deprecations: [],\n  getUniforms\n} as const satisfies ShaderModule;\n"})}),"\n",(0,a.jsxs)(s.p,{children:["For details see the ",(0,a.jsx)(s.a,{href:"/docs/api-reference/shadertools/shader-module",children:(0,a.jsx)(s.code,{children:"ShaderModule"})})," type reference page."]}),"\n",(0,a.jsx)(s.p,{children:"Several functions are also available to initialize and use shader modules."})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>n,x:()=>t});var d=r(6540);const a={},o=d.createContext(a);function n(e){const s=d.useContext(o);return d.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:n(e.components),d.createElement(o.Provider,{value:s},e.children)}}}]);