/*! For license information please see f1bb7c72.499b2a77.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[3009],{482:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>a,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=o(4848),t=o(8453);const s={},r="GPUPointInPolygon",l={id:"api-reference/engine/gpgpu/gpu-point-in-polygon",title:"GPUPointInPolygon",description:"GPUPointInPolygon provides GPU accelerated PIP (Point-In-Polygon) testing functionality. A given set of 2D points and one or more 2D polygons, it computes, whether each point is inside or outside of any polygon.",source:"@site/../docs/api-reference/engine/gpgpu/gpu-point-in-polygon.md",sourceDirName:"api-reference/engine/gpgpu",slug:"/api-reference/engine/gpgpu/gpu-point-in-polygon",permalink:"/docs/api-reference/engine/gpgpu/gpu-point-in-polygon",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/engine/gpgpu/gpu-point-in-polygon.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"TextureTransform",permalink:"/docs/api-reference/engine/compute/texture-transform"},next:{title:"Histopyramid",permalink:"/docs/api-reference/engine/gpgpu/histopyramid"}},c={},d=[{value:"Sample Usage",id:"sample-usage",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"update(opts)",id:"updateopts",level:3},{value:"filter(opts)",id:"filteropts",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"gpupointinpolygon",children:"GPUPointInPolygon"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GPUPointInPolygon"})," provides GPU accelerated PIP (Point-In-Polygon) testing functionality. A given set of 2D points and one or more 2D polygons, it computes, whether each point is inside or outside of any polygon."]}),"\n",(0,i.jsx)(n.h2,{id:"sample-usage",children:"Sample Usage"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// construct data into required formats\nconst polygons =\n  [[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5]] // polygon vertices\n];\n\n// XY locations of 6 points\nconst points = [\n  0, 0,\n  5.0, -0.25,\n  0.25, -0.25,\n  0.25, 8.25,\n  -0.25, 0.25,\n  -3.45, 0.45\n];\n\nconst positionBuffer = device.createBuffer(new Float32Array(points));\nconst count = 6;\n// Allocate result buffer with enough space (2 floats for each point)\nconst filterValueIndexBuffer = device.createBuffer(count * 2 * 4);\n\nconst gpuPointInPolygon = new GPUPointInPolygon(device);\ngpuPointInPolygon.update({polygons});\ngpuPointInPolygon.filter({positionBuffer, filterValueIndexBuffer, count});\n\nconst results = filterValueIndexBuffer.getData();\n\n// results array contains 2 elements (filterValue, index) for each point, where\n// `filterValue` is '-1' if point in outside of polygons, otherwise index of the polygon in which it lies\n// `index` is the point index in `positionBuffer`\n"})}),"\n",(0,i.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"new GPUPointInPolygon(gl: WebGL2RenderingContext, props: Object);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Creates a new ",(0,i.jsx)(n.code,{children:"GPUPointInPolygon"})," object."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gl"})," - (WebGL2RenderingContext) - WebGL2 context."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.polygons"})," (",(0,i.jsx)(n.code,{children:"Array"}),", Optional) - Array of polygons, where each polygon is in following format:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Simple polygon"})," : [[x1, y1], [x2, y2], ...]"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Polygon with holes"})," : [\n[[x1, y1], [x2, y2], ...], // outer ring\n[[a1, b1], [a2, b2], ...], // hole - 1\n[[s1, t1], [s2, t2], ...], // hole - 2\n...\n]"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.textureSize"})," (",(0,i.jsx)(n.code,{children:"Number"}),", Optional) - Size of the texture to be used to create a polygon texture. Default value is 512."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"updateopts",children:"update(opts)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.polygons"})," (",(0,i.jsx)(n.code,{children:"Array"}),", Optional) - Array of polygons, where each polygon is in following format:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Simple polygon"})," : [[x1, y1], [x2, y2], ...]"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Polygon with holes"})," : [\n[[x1, y1], [x2, y2], ...] // outer ring\n[[a1, b1], [a2, b2], ...] // hole - 1\n[[s1, t1], [s2, t2], ...] // hole - 2\n]"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.textureSize"})," (",(0,i.jsx)(n.code,{children:"Number"}),", Optional) - Size of the texture to be used to create a polygon texture, that is used internally. Default value is 512."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["NOTE: Index of a polygon in ",(0,i.jsx)(n.code,{children:"opts.polygons"})," array is its id, and it is used to identify which polygon a point lies in the result buffer (check ",(0,i.jsx)(n.code,{children:"filterValueIndexBuffer below"}),"). A maximum of 256 values are supported for polygon id, i.e its valid range is [0, 255], if ",(0,i.jsx)(n.code,{children:"opts.polygons"})," size is more than 256, polygon id will be clamped to 255."]}),"\n",(0,i.jsx)(n.h3,{id:"filteropts",children:"filter(opts)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.positionBuffer"})," (",(0,i.jsx)(n.code,{children:"Buffer"}),") - Buffer object containing X, Y position of input points."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.count"})," (",(0,i.jsx)(n.code,{children:"Number"}),") - Number of points to be processed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"opts.filterValueIndexBuffer"})," (",(0,i.jsx)(n.code,{children:"Buffer"}),") - Buffer object to hold results for each input point. After the method is executed, this buffer contains two floats ",(0,i.jsx)(n.code,{children:"filterValue"})," and ",(0,i.jsx)(n.code,{children:"index"})," for each input point, where :","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"filterValue"})," is '-1' if point in outside of polygons, else index of the polygon in which it lies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"index"})," is the point index in ",(0,i.jsx)(n.code,{children:"positionBuffer"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["NOTE: If a point lies in the region that is overlapped by 2 or more polygons, ",(0,i.jsx)(n.code,{children:"filterValue"})," will be index of one of the polygons."]})]})}function a(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},1020:(e,n,o)=>{var i=o(6540),t=Symbol.for("react.element"),s=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,l=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,o){var i,s={},d=null,p=null;for(i in void 0!==o&&(d=""+o),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(p=n.ref),n)r.call(n,i)&&!c.hasOwnProperty(i)&&(s[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===s[i]&&(s[i]=n[i]);return{$$typeof:t,type:e,key:d,ref:p,props:s,_owner:l.current}}n.Fragment=s,n.jsx=d,n.jsxs=d},4848:(e,n,o)=>{e.exports=o(1020)},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>l});var i=o(6540);const t={},s=i.createContext(t);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);