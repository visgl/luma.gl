"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[5914],{2722:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api-reference/core/bindings","title":"Bindings","description":"A key responsibility of any GPU API is to enable the application to","source":"@site/../docs/api-reference/core/bindings.md","sourceDirName":"api-reference/core","slug":"/api-reference/core/bindings","permalink":"/docs/api-reference/core/bindings","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/core/bindings.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"GPU Parameters","permalink":"/docs/api-reference/core/parameters"},"next":{"title":"ShaderLayout","permalink":"/docs/api-reference/core/shader-layout"}}');var a=t(4848),o=t(8453);const r={},s="Bindings",c={},l=[{value:"ShaderLayout",id:"shaderlayout",level:2},{value:"Attributes",id:"attributes",level:3},{value:"Buffer Maps",id:"buffer-maps",level:3},{value:"Model usage",id:"model-usage",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"bindings",children:"Bindings"})}),"\n",(0,a.jsx)(n.p,{children:"A key responsibility of any GPU API is to enable the application to\nset up data so that it can be accessed by shaders. in luma.b"}),"\n",(0,a.jsx)(n.p,{children:"The terminology can be a little confusing. To make it easy to cross-reference other code and\ndocumentation, luma.gl attempts to roughly follow WebGPU / WGSL conventions. The following terms are used:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"layouts"})," - metadata for various shader connection points"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"attribute layout"})," - actual values for attributes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"attribute buffers"})," - actual values for attributes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"binding layout"})," - actual values for attributes"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"bindings"})," - actual values for"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"shaderlayout",children:"ShaderLayout"}),"\n",(0,a.jsx)(n.p,{children:"Shader code (whether in WGSL or GLSL) contains declarations of attributes,\nuniform blocks, samplers etc.\nCollectively, these define the data that needs to be bound before the\nshader can execute on the GPU. And since the bindings are performed on the CPU,\na certain amount of metadata is needed in JavaScript to describe what data\na specific shader or pair of shaders expects."}),"\n",(0,a.jsxs)(n.p,{children:["luma.gl defines the ",(0,a.jsx)(n.code,{children:"ShaderLayout"})," type to collect a description of a (pair of) shaders. A ",(0,a.jsx)(n.code,{children:"ShaderLayout"}),"\nis required when creating a ",(0,a.jsx)(n.code,{children:"RenderPipeline"})," or ",(0,a.jsx)(n.code,{children:"ComputePipeline"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Shaders expose numeric bindings, however in applications, named bindings tend to be more convenient."}),"\n",(0,a.jsxs)(n.p,{children:["Note: ",(0,a.jsx)(n.code,{children:"ShaderLayout"}),"s can be created manually (by reading the shader code),\nor be automatically generated by parsing shader source code or using e.g. the WebGL program introspection APIs."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type ShaderLayout = {\n  attributes: {\n    {name: 'instancePositions', location: 0, format: 'float32x2', stepMode: 'instance'},\n    {name: 'instanceVelocities', location: 1, format: 'float32x2', stepMode: 'instance'},\n    {name: 'vertexPositions', location: 2, format: 'float32x2', stepMode: 'vertex'}\n  },\n\n  bindings?: {\n    {name: 'projectionUniforms', location: 0, type: 'uniforms'},\n    {name: 'textureSampler', location: 1, type: 'sampler'},\n    {name: 'texture', location: 2, type: 'texture'}\n  }\n}\n\ndevice.createRenderPipeline({\n  layout,\n  attributes,\n  bindings\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"attributes",children:"Attributes"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const shaderLayout: ShaderLayout = {\n  attributes: [\n    {name: 'instancePositions', location: 0, format: 'float32x2', stepMode: 'instance'},\n    {name: 'instanceVelocities', location: 1, format: 'float32x2', stepMode: 'instance'},\n    {name: 'vertexPositions', location: 2, format: 'float32x2', stepMode: 'vertex'}\n  ],\n  ...\n};\n"})}),"\n",(0,a.jsx)(n.h3,{id:"buffer-maps",children:"Buffer Maps"}),"\n",(0,a.jsx)(n.p,{children:"Buffer mapping is an optional mechanism that enables more sophisticated GPU attribute buffer layouts."}),"\n",(0,a.jsx)(n.p,{children:"Buffer mappings offer control of GPU buffer vertex formats, as well as offsets, strides, interleaving etc."}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["Pipeline attribute layouts are immutable and need to be defined when a pipeline is created. All buffers subsequently supplied to that pipeline need to conform to any buffer mapping properties specified during pipeline creation (e.g. the vertex format may be locked to ",(0,a.jsx)(n.code,{children:"unorm8x4"}),")."]})}),"\n",(0,a.jsx)(n.p,{children:"The bufferLayout field in the example below specifies that"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const bufferLayout: BufferLayout = {\n  {name: 'instanceColors', format: 'unorm8x4'},\n  {name: 'instanceVelocities', format: 'interleaved', attributes: [\n    {name: 'instancePositions'}\n    {name: 'instanceVelocities'}\n  ]},\n  ...\n};\n\ndevice.createRenderPipeline({\n  shaderLayout,\n  // We want to use \"non-standard\" buffers: two attributes interleaved in same buffer\n  bufferLayout: [\n    {name: 'instanceColors', format: 'unorm8x4'},\n  ],\n  attributes: {},\n  bindings: {}\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"model-usage",children:"Model usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"new Model(device, {\n  attributeLayout:\n    instancePositions: {location: 0, format: 'float32x2', stepMode: 'instance'},\n    instanceVelocities: {location: 1, format: 'float32x2', stepMode: 'instance'},\n    vertexPositions: {location: 2, format: 'float32x2', stepMode: 'vertex'}\n  };\n})\n"})}),"\n",(0,a.jsx)(n.p,{children:"WGSL vertex shader"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>;\n};\n@binding(0), @group(0) var<uniform> uniforms : Uniforms; // BINDING 0\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>;\n  @location(0) fragUV : vec2<f32>;\n  @location(1) fragPosition: vec4<f32>;\n};\n\n@stage(vertex)\nfn main(@location(0) position : vec4<f32>,\n        @location(1) uv : vec2<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * position;\n  output.fragUV = uv;\n  output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n  return output;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"WGSL FRAGMENT SHADER"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"@group(0), @binding(1) var mySampler: sampler; // BINDING 1\n@group(0), @binding(2) var myTexture: texture_2d<f32>; // BINDING 2\n\n@stage(fragment)\nfn main(@location(0) fragUV: vec2<f32>,\n        @location(1) fragPosition: vec4<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fragUV) * fragPosition;\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);