"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[7361],{6665:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"api-reference/gltf/README","title":"Overview","description":"The @luma.gl/gltf modules utilities for turning glTF data into a","source":"@site/../docs/api-reference/gltf/README.md","sourceDirName":"api-reference/gltf","slug":"/api-reference/gltf/","permalink":"/docs/api-reference/gltf/","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/gltf/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Histopyramid","permalink":"/docs/api-reference/engine/gpgpu/histopyramid"},"next":{"title":"glTF Extensions","permalink":"/docs/api-reference/gltf/gltf-extensions"}}');var l=r(4848),a=r(8453);const i={},t="Overview",o={},d=[{value:"Installing",id:"installing",level:2},{value:"Usage",id:"usage",level:2},{value:"API",id:"api",level:2},{value:"<code>createScenegraphsFromGLTF()</code>",id:"createscenegraphsfromgltf",level:4},{value:"<code>GLTFAnimator</code>",id:"gltfanimator",level:4},{value:"<code>loadPBREnvironment()</code>",id:"loadpbrenvironment",level:4},{value:"<code>parsePBRMaterial()</code>",id:"parsepbrmaterial",level:4},{value:"Relationship to other modules",id:"relationship-to-other-modules",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"@luma.gl/gltf"})," modules utilities for turning glTF data into a\n",(0,l.jsx)(n.a,{href:"/docs/api-reference/engine/scenegraph/scenegraph-node",children:"luma.gl scenegraph"})," ."]}),"\n",(0,l.jsx)(n.h2,{id:"installing",children:"Installing"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"npm install @luma.gl/gltf\n"})}),"\n",(0,l.jsxs)(n.p,{children:["You will also typically need the ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," loader."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"npm install @loaders.gl/gltf\n"})}),"\n",(0,l.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,l.jsx)(n.p,{children:"Loading a glTF file and instantiating scenegraphs"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"import {load} from '@loaders.gl/core';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\nimport {luma} from '@luma.gl/core';\nimport {webglAdapter} from '@luma.gl/webgl';\nimport {createScenegraphsFromGLTF} from '@luma.gl/gltf';\n\nconst device = await luma.createDevice({\n  type: 'webgl',\n  adapters: [webglAdapter]               // supply a device adapter\n});\n\nconst gltf = await load('model.glb', GLTFLoader, {gltf: {postProcess: true}});\nconst {scenes, animator} = createScenegraphsFromGLTF(device, gltf);\n\n// `scenes` is an array of GroupNode instances. Add them to your scenegraph.\nfor (const scene of scenes) {\n  root.add(scene);\n}\n\n// Move animations forward each frame:\nfunction renderFrame(timeMs: number) {\n  animator.setTime(timeMs);\n  requestAnimationFrame(renderFrame);\n}\nrequestAnimationFrame(renderFrame);\n"})}),"\n",(0,l.jsx)(n.p,{children:"Typical flow:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Use ",(0,l.jsx)(n.code,{children:"GTLFLoader"})," from the ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," module to load a glTF/GLB file."]}),"\n",(0,l.jsxs)(n.li,{children:["Use the ",(0,l.jsx)(n.code,{children:"postProcessGLTF()"})," function from the ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," module further process and prepare the raw glTF."]}),"\n",(0,l.jsxs)(n.li,{children:["Pass the processed glTF to the ",(0,l.jsx)(n.code,{children:"createScenegraphsFromGLTF()"})," function, which returns an array of ",(0,l.jsx)(n.a,{href:"/docs/api-reference/engine/",children:(0,l.jsx)(n.code,{children:"GroupNode"})})," scenes and a ",(0,l.jsx)(n.code,{children:"GLTFAnimator"})," instances.4. Add the resulting nodes to your own scenegraph and update the",(0,l.jsx)(n.code,{children:"GLTFAnimator"})," each frame to animate the nodes."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,l.jsx)(n.h4,{id:"createscenegraphsfromgltf",children:(0,l.jsx)(n.code,{children:"createScenegraphsFromGLTF()"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"createScenegraphsFromGLTF(device, gltf[, options])\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Creates scenegraph nodes and returns ",(0,l.jsx)(n.code,{children:"{scenes, animator}"}),"."]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"device"}),"- a Device instance created from @luma.gl/core."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"gltf"}),"- a GLTFPostprocessed object (data returned by ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," when postProcess: true is enabled)."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"options"}),"- optional, see below."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The returned scenes array contains a GroupNode for each glTF scene\nin the file. The optional animator is an instance of GLTFAnimator\nthat can be used to update active animations (animator.setTime(ms))."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"type ParseGLTFOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"modelOptions"}),"- additional options that will be passed when constructing any ModelNode instances for primitives in the glTF."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"pbrDebug "})," - set to true to enable extra PBR debugging information."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"imageBasedLightingEnvironment"}),"- a PBREnvironment object (as returned by loadPBREnvironment()) to\nsupply textures for PBR image-based lighting."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"lights"}),"- true by default. If false, lights declared in the glTF\n(KHR_lights_punctual) will not be instantiated."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"useTangents"}),"- compute/propagate tangents when possible. Useful when the glTF contains normal-mapped materials."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"gltfanimator",children:(0,l.jsx)(n.code,{children:"GLTFAnimator"})}),"\n",(0,l.jsxs)(n.p,{children:["Animation support: the ",(0,l.jsx)(n.code,{children:"GLTFAnimator "}),"class encapsulates all animations found in the glTF\nand provides a simple API for advancing them:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"const { animator } = createScenegraphsFromGLTF(device, gltf);\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"animator.setTime(timeMs)"}),"  - timeMs is the current clock time in ms"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:".getAnimations()"})," returns an array of internal animator objects if the application needs to manage them individually."]}),"\n"]}),"\n",(0,l.jsx)(n.h4,{id:"loadpbrenvironment",children:(0,l.jsx)(n.code,{children:"loadPBREnvironment()"})}),"\n",(0,l.jsx)(n.p,{children:"Image Based Lighting Utilities"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"import {loadPBREnvironment} from '@luma.gl/gltf';\n\ntype PBREnvironmentProps = {\n  brdfLutUrl: string;\n  getTexUrl: (type: 'diffuse' | 'specular', faceIndex: number, lod: number) => string;\n  specularMipLevels?: number;\n};\n\nloadPBREnvironment(device, props)\n"})}),"\n",(0,l.jsx)(n.p,{children:"Creates a set of textures suitable for physically based rendering:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"const env = loadPBREnvironment(device, {\n  brdfLutUrl: '/path/brdfLUT.png',\n  getTexUrl: (name, face, mip) => `/env/${name}/${face}/${mip}.jpg`,\n  specularMipLevels: 10\n});\n"})}),"\n",(0,l.jsx)(n.p,{children:"The returned object:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"type PBREnvironment = {\n  brdfLutTexture: AsyncTexture;\n  diffuseEnvSampler: AsyncTexture;\n  specularEnvSampler: AsyncTexture;\n};\n"})}),"\n",(0,l.jsx)(n.p,{children:"Pass the object through ParseGLTFOptions.imageBasedLightingEnvironment\nto cause the newly created ModelNodes to use the supplied IBL textures."}),"\n",(0,l.jsx)(n.h4,{id:"parsepbrmaterial",children:(0,l.jsx)(n.code,{children:"parsePBRMaterial()"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"parsePBRMaterial(device, gltfMaterial, attributes, options)\n"})}),"\n",(0,l.jsx)(n.p,{children:"Low-level helper which interprets the glTF material definition and\nreturns a ParsedPBRMaterial object containing shader parameters.\nNormally this is called automatically by parseGLTF/createScenegraphsFromGLTF\nbut it can be invoked directly when applications need to construct a\nmaterial programmatically."}),"\n",(0,l.jsx)(n.h2,{id:"relationship-to-other-modules",children:"Relationship to other modules"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Relies on ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," for reading .gltf/.glb scene files."]}),"\n",(0,l.jsxs)(n.li,{children:["Produces scenegraph nodes from ",(0,l.jsx)(n.code,{children:"@luma.gl/engine"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["Expects a Device from ",(0,l.jsx)(n.code,{children:"@luma.gl/core"})," (",(0,l.jsx)(n.code,{children:"@luma.gl/webgl"})," or\n",(0,l.jsx)(n.code,{children:"@luma.gl/webgpu"})," device adapters are required for rendering)."]}),"\n",(0,l.jsxs)(n.li,{children:["Material and lighting implementations reuse features from\n",(0,l.jsx)(n.code,{children:"@luma.gl/shadertools"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Notes:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["All scenegraph objects created by @luma.gl/gltf are ordinary\n",(0,l.jsx)(n.code,{children:"@luma.gl/engine"})," scengraph nodes and can be freely manpipulated or intermixed with manually\nconstructed nodes."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["glTF files containing extension data (e.g. Draco compressed meshes,\ncustom PBR materials, or meshopt compression) need to be processed by\nthe ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})," ",(0,l.jsx)(n.code,{children:"GLTFLoader"})," which processes the relevant extensions."]}),"\n",(0,l.jsx)(n.p,{children:"See also"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"GLTFLoader"})," in ",(0,l.jsx)(n.code,{children:"@loaders.gl/gltf"})]}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"@luma.gl/engine"})}),"\n"]}),"\n",(0,l.jsx)(n.h1,{id:"example-with-loadersgl",children:"Example with loaders.gl"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"load('model.glb', GLTFLoader, {\n  gltf: {\n    postProcess: true,\n    decompress: false         # set to true if draco-encoded\n  }\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>t});var s=r(6540);const l={},a=s.createContext(l);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);