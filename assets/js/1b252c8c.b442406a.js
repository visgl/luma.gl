"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[7359],{1606:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"whats-new","title":"What\'s New","description":"This page contains news for recent luma.gl releases. For older releases (through v8.5) refer to the Legacy What\'s New page.","source":"@site/../docs/whats-new.md","sourceDirName":".","slug":"/whats-new","permalink":"/docs/whats-new","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/whats-new.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Overview","permalink":"/docs/"},"next":{"title":"Upgrade Guide","permalink":"/docs/upgrade-guide"}}');var l=s(4848),i=s(8453);const d={},c="What's New",o={},t=[{value:"Version 9.3 (In Development)",id:"version-93-in-development",level:2},{value:"Version 9.2",id:"version-92",level:2},{value:"Version 9.1",id:"version-91",level:2},{value:"Version 9.0",id:"version-90",level:2},{value:"WebGPU Support",id:"webgpu-support",level:3},{value:"WebGL Support",id:"webgl-support",level:3},{value:"New module structure",id:"new-module-structure",level:3},{value:"General improvements",id:"general-improvements",level:3},{value:"New features",id:"new-features",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"whats-new",children:"What's New"})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.em,{children:["This page contains news for recent luma.gl releases. For older releases (through v8.5) refer to the ",(0,l.jsx)(n.a,{href:"/docs/legacy/legacy-upgrade-guide",children:"Legacy What's New"})," page."]})}),"\n",(0,l.jsx)(n.h2,{id:"version-93-in-development",children:"Version 9.3 (In Development)"}),"\n",(0,l.jsx)(n.p,{children:"Target Date: TBD"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/gltf"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"glTF Skeleton Animation Support"}),"\n",(0,l.jsx)(n.li,{children:"glTF Mesh Target Animation Support"}),"\n",(0,l.jsx)(n.li,{children:"glTF and PRB now supported on WebGPU"}),"\n",(0,l.jsx)(n.li,{children:"Improved documentation"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"version-92",children:"Version 9.2"}),"\n",(0,l.jsx)(n.p,{children:"Release Date: Sep 24, 2025"}),"\n",(0,l.jsx)(n.p,{children:"Production quality WebGPU backend"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"General"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"All luma.gl examples now run under both WebGPU and WebGL"}),"\n",(0,l.jsxs)(n.li,{children:["API updates to cover ",(0,l.jsx)(n.a,{href:"https://developer.chrome.com/docs/web-platform/webgpu/news",children:"new Chrome WebGPU features"})]}),"\n",(0,l.jsxs)(n.li,{children:["TypeScript v5.7, and all ",(0,l.jsx)(n.code,{children:'"strict"'})," TypeScript options are now enabled."]}),"\n",(0,l.jsx)(n.li,{children:"Documentation improvements"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/core"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["[",(0,l.jsx)(n.code,{children:"Buffer"}),"]"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["[",(0,l.jsx)(n.code,{children:"Buffer.mapAndReadAsync()"}),"] New method that reads directly from buffer memory without performing a copy."]}),"\n",(0,l.jsxs)(n.li,{children:["[",(0,l.jsx)(n.code,{children:"Buffer.mapAndWriteAsync()"}),"] New method that writes directly to buffer memory."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:["[",(0,l.jsx)(n.code,{children:"Texture"}),"]"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Texture"})," class refactors complete, see upgrade guide."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Shader type APIs have been improved."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"CommandEncoder"}),"/",(0,l.jsx)(n.code,{children:"CommandBuffer"})," API improvements"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Fence"})," - New synchronization primitive created with ",(0,l.jsx)(n.code,{children:"device.createFence()"})]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"CanvasContext"})," API simplifications (see upgrade guide)."]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.a,{href:"/docs/api-reference/core/texture-formats",children:"Texture Formats"}),". Adds support for the new texture formats added in Chrome 132 (currently require setting chrome://flags/#enable-unsafe-webgpu)"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"'r16unorm'"}),", ",(0,l.jsx)(n.code,{children:"'rg16unorm'"}),", ",(0,l.jsx)(n.code,{children:"'rgba16unorm'"})," (feature ",(0,l.jsx)(n.code,{children:"'chromium-experimental-unorm16-texture-formats'"}),")"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"'r16snorm'"}),", ",(0,l.jsx)(n.code,{children:"'rg16snorm'"}),", ",(0,l.jsx)(n.code,{children:"'rgba16snorm'"})," (feature ",(0,l.jsx)(n.code,{children:"'chromium-experimental-snorm16-texture-formats'"}),")"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.a,{href:"/docs/api-reference/core/vertex-formats",children:"Vertex Formats"})," (added in Chrome v133 and v119)"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Single component 8 and 16 bit formats are now supported by WebGPU: ",(0,l.jsx)(n.code,{children:"'uint8'"}),", ",(0,l.jsx)(n.code,{children:"'sint8'"}),", ",(0,l.jsx)(n.code,{children:"'unorm8'"}),", ",(0,l.jsx)(n.code,{children:"'snorm8'"}),", ",(0,l.jsx)(n.code,{children:"'uint16'"}),", ",(0,l.jsx)(n.code,{children:"'sint16'"}),", ",(0,l.jsx)(n.code,{children:"'unorm16'"}),", ",(0,l.jsx)(n.code,{children:"'snorm16'"}),", and ",(0,l.jsx)(n.code,{children:"'float16'"}),"."]}),"\n",(0,l.jsx)(n.li,{children:"Note: 3 component formats are still missing in WebGPU."}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"'unorm8x4-bgra'"})," - WebGPU only. Simplifies working with BGRA data."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"'unorm10-10-10-2"})," - Exposed since available in all WebGPU backends. Also supported by WebGL2."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/engine"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DynamicTexture"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"now supports mipmap generation for WebGPU textures"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/effects"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"More postprocessing effects ported to WGSL"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/shadertools"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"More shader modules ported to WGSL"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"version-91",children:"Version 9.1"}),"\n",(0,l.jsx)(n.p,{children:"Target Date: Dec, 2024"}),"\n",(0,l.jsx)(n.p,{children:"Enhanced WebGPU support."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Highlights"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["GPU backend management is streamlined via the new ",(0,l.jsx)(n.code,{children:"Adapter"})," API."]}),"\n",(0,l.jsxs)(n.li,{children:["GPU connection to HTML DOM (via ",(0,l.jsx)(n.code,{children:"canvas"})," elements) improved via ",(0,l.jsx)(n.code,{children:"CanvasContext"})," API changes."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Texture"}),"s are now immutable, however a new ",(0,l.jsx)(n.code,{children:"AsyncTexture"})," class offers a higher-level, mutable texture API."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ShaderModule"})," type safety improvements (shader uniforms can now be strictly typed in JavaScript)"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/core"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/api-reference/core/adapter",children:(0,l.jsx)(n.code,{children:"Adapter"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"New class for singleton objects representing pluggable GPU backends."}),"\n",(0,l.jsxs)(n.li,{children:["Singleton ",(0,l.jsx)(n.code,{children:"Adapter"})," objects are exported by the ",(0,l.jsx)(n.code,{children:"@luma.gl/webgpu"})," and ",(0,l.jsx)(n.code,{children:"@luma.gl/webgl"})," modules."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/api-reference/core/luma",children:(0,l.jsx)(n.code,{children:"luma"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Now relies on ",(0,l.jsx)(n.code,{children:"Adapter"})," instances to define which GPU backends are available."]}),"\n",(0,l.jsx)(n.li,{children:"Adapter can be supplied during device creation, avoiding the need for global registration of GPU backends."}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"CreateDeviceProps.adapters"})," prop to supply list of GPU backend adapters to ",(0,l.jsx)(n.code,{children:"luma.createDevice()"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.a,{href:"/docs/api-reference/core/luma#lumaregisteradapters",children:(0,l.jsx)(n.code,{children:"luma.registerAdapters()"})})," New method for global registration of adapters (in case it still desired)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Device"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DeviceProps.createCanvasContext"})," - New prop for creating a default ",(0,l.jsx)(n.code,{children:"CanvasContext"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DeviceProps.onResize"})," - New callback tracking size changes to ",(0,l.jsx)(n.code,{children:"CanvasContext"}),"s."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DeviceProps.onVisibilityChange"})," - New callback tracking visibility to ",(0,l.jsx)(n.code,{children:"CanvasContext"}),"s."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DeviceProps.onDevicePixelRatioChange"})," - New callback tracking device pixel resolution (DPR) changes to ",(0,l.jsx)(n.code,{children:"CanvasContext"}),"s."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"DeviceProps.debug*"})," - New debug options, please refer to ",(0,l.jsx)(n.code,{children:"DeviceProps"})," documentation."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"CanvasContext"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:'Now calculates exact "device pixel content box" size enabling pixel perfect sized drawing buffers (no moire etc).'}),"\n",(0,l.jsxs)(n.li,{children:["Now tracks size, visibility and DPR changes (see the new ",(0,l.jsx)(n.code,{children:"DeviceProps"})," callbacks)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Texture"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Textures are now immutable and synchronous. See upgrade guide, and the new ",(0,l.jsx)(n.code,{children:"AsyncTexture"})," class in ",(0,l.jsx)(n.code,{children:"@luma.gl/engine"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Texture.copyExternalImage()"})," New function that works on both WebGPU and WebGL."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Texture.copyImageData()"})," New function that works on both WebGPU and WebGL."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Sampler"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"SamplerProps.mipmapFilter"})," New value ",(0,l.jsx)(n.code,{children:"'none'"})," providing more explicit control over mipmap filtering."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RenderPipeline"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Parameters.blend"})," - New parameter that provides more explicit control over color blending activation."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RenderPass"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RenderPassProps.clearColors"})," - New prop enables specification of clear colors for multiple color attachments."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/engine"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"makeAnimationLoopTemplate"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Accepts a new ",(0,l.jsx)(n.code,{children:".adapters"})," prop. (Avoids need for global registration of adapters)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"AsyncTexture"}),"](/docs/api-reference/engine/dynamic-texture)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"New class allows that applications to work withcreate textures from a Promise."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ShaderPassRenderer"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["New class that helps applications apply a ",(0,l.jsx)(n.code,{children:"ShaderPass"})," list to a texture."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/shadertools"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["[",(0,l.jsx)(n.code,{children:"ShaderModule](/docs/api-reference/shadertools/shader-module)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"New improvements to type safety, in particular for uniforms and bindings."}),"\n",(0,l.jsxs)(n.li,{children:["New simplified API, no longer required to instantiate modules into ",(0,l.jsx)(n.code,{children:"ShaderModuleInstances"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"getShaderModuleUniforms(module: ShaderModule, ...)"})," New function"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"getShaderModuleDependencies(module: ShaderModule)"})," New function"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/webgl"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"webglAdapter"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"New object representing the WebGL backend"}),"\n",(0,l.jsx)(n.li,{children:"New: adds mock WEBGL1 extensions to WebGL2 contexts for better compatibility with old WebGL libraries"}),"\n",(0,l.jsx)(n.li,{children:"Big texture refactor to align WebGL implementation with WebGPU APIs"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RenderPipeline"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"WebGL render pipelines now support frame buffers with multiple color attachments."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RenderPass"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Now supports framebuffers with multiple color attachments."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"@luma.gl/webgpu"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"webgpuAdapter"})," New object representing the WebGPU backend"]}),"\n",(0,l.jsx)(n.li,{children:"Numerous under-the-hood improvements and bug fixes"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"version-90",children:"Version 9.0"}),"\n",(0,l.jsx)(n.p,{children:"Target Date: Feb 2024"}),"\n",(0,l.jsx)(n.admonition,{type:"caution",children:(0,l.jsxs)(n.p,{children:["luma.gl v9 contains significant API changes and requires existing luma.gl v8 applications to be ",(0,l.jsx)(n.a,{href:"/docs/upgrade-guide",children:"upgraded"}),"."]})}),"\n",(0,l.jsx)(n.p,{children:"luma.gl v9 is a major release that adds experimental WebGPU support to the luma.gl API."}),"\n",(0,l.jsx)(n.h3,{id:"webgpu-support",children:"WebGPU Support"}),"\n",(0,l.jsx)(n.p,{children:"The biggest change is that the core API is now portable (no longer WebGL-specific), and plug-in backends are provided for WebGL 2 and WebGPU:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Portable GPU API"}),": ",(0,l.jsx)(n.code,{children:"@luma.gl/core"})," now provides a portable GPU resource management API."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"WebGL bindings"}),": ",(0,l.jsx)(n.code,{children:"@luma.gl/webgl"})," now provides a WebGL backend for the core API."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"WebGPU bindings"}),": ",(0,l.jsx)(n.code,{children:"@luma.gl/webgpu"})," provides a new experimental WebGPU backend for the core API."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"webgl-support",children:"WebGL Support"}),"\n",(0,l.jsx)(n.p,{children:"luma.gl v9 drops support for WebGL 1 functionality."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"WebGL1"})," WebGL 1 support is dropped."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"GLSL 1.00"})," is no longer supported. GLSL shaders need to be ported to ",(0,l.jsx)(n.strong,{children:"GLSL 3.00"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"headless-gl"})," The Node.js WebGL 1 integration is no longer supported"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"On the upside this means that all features requiring WebGL 2 are now available and luma.gl also brings support for a range of new WebGL 2 extensions, see more below."}),"\n",(0,l.jsx)(n.h3,{id:"new-module-structure",children:"New module structure"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Module"}),(0,l.jsx)(n.th,{children:"Impact"}),(0,l.jsx)(n.th,{children:"Description"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/core"})})}),(0,l.jsx)(n.td,{children:"New API"}),(0,l.jsx)(n.td,{children:"The new portable luma.gl GPU API. Applications can run on both WebGPU and WebGL2 devices."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/engine"})})}),(0,l.jsx)(n.td,{children:"Light API updates"}),(0,l.jsxs)(n.td,{children:["Classic luma.gl engine classes ()",(0,l.jsx)(n.code,{children:"Model"}),", ",(0,l.jsx)(n.code,{children:"AnimationLoop"})," etc), which work portably on both WebGPU and WebGL 2."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/gltf"})})}),(0,l.jsx)(n.td,{children:"Renamed module"}),(0,l.jsxs)(n.td,{children:["New module that exports the glTF classes (moved from ",(0,l.jsx)(n.code,{children:"@luma.gl/experimental"}),")."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/shadertools"})})}),(0,l.jsx)(n.td,{children:"Light API updates"}),(0,l.jsx)(n.td,{children:"The shader assembler API and the shader module library."})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/webgl"})})}),(0,l.jsx)(n.td,{children:"WebGL backend"}),(0,l.jsxs)(n.td,{children:['Optional "GPU backend module". Importing this module enables the application to create WebGL 2 ',(0,l.jsx)(n.code,{children:"Device"}),"s."]})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/webgpu"})})}),(0,l.jsx)(n.td,{children:"WebGPU backend"}),(0,l.jsxs)(n.td,{children:['Experimental "GPU backend module". Importing this module enables the application to create WebGPU ',(0,l.jsx)(n.code,{children:"Device"}),"s."]})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"general-improvements",children:"General improvements"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"TypeScript"}),": All APIs now rigorously typed."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"ES modules"})," - Modern ES module and CommonJS entry points for maximum interoperability."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Website"})," - New Docusaurus website with more embedded live examples and improved documentation."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Debugging"})," - SpectorJS integration. Shader debugger UI."]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"new-features",children:"New features"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/core"})})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Exports the new ",(0,l.jsx)(n.code,{children:"Device"})," class is the entry point to the luma.gl API, used to create other GPU resources."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/engine"})})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["NEW: Scenegraph classes: ",(0,l.jsx)(n.code,{children:"ModelNode"}),", ",(0,l.jsx)(n.code,{children:"GroupNode"}),", ",(0,l.jsx)(n.code,{children:"ScenegraphNode"}),", moved from ",(0,l.jsx)(n.code,{children:"@luma.gl/experimental"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["NEW: ",(0,l.jsx)(n.code,{children:"ShaderInputs"})," - Class that manages uniform buffers for a ",(0,l.jsx)(n.code,{children:"Model"})]}),"\n",(0,l.jsxs)(n.li,{children:["NEW: ",(0,l.jsx)(n.code,{children:"ShaderFactory"})," - Creates and caches reusable ",(0,l.jsx)(n.code,{children:"Shader"})," resources"]}),"\n",(0,l.jsxs)(n.li,{children:["NEW: ",(0,l.jsx)(n.code,{children:"AnimationLoopTemplate"})," - Helper class for writing cleaner demos and applications in TypeScript."]}),"\n",(0,l.jsxs)(n.li,{children:["New ",(0,l.jsx)(n.code,{children:"Computation"})," - Class that manages a ",(0,l.jsx)(n.code,{children:"ComputePipeline"})," similar to ",(0,l.jsx)(n.code,{children:"Model"})," and ",(0,l.jsx)(n.code,{children:"Transform"}),"."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/gltf"})})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["New module that exports the glTF classes (moved from ",(0,l.jsx)(n.code,{children:"@luma.gl/experimental"}),")."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/shadertools"})})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"All shader modules now use uniform buffers."}),"\n",(0,l.jsxs)(n.li,{children:["New ",(0,l.jsx)(n.code,{children:"ShaderAssembler"})," class that provides a clean entry point to the shader module system."]}),"\n",(0,l.jsxs)(n.li,{children:["New ",(0,l.jsx)(n.code,{children:"CompilerMessage"})," type and ",(0,l.jsx)(n.code,{children:"formatCompilerLog"})," function for portable shader log handling."]}),"\n",(0,l.jsx)(n.li,{children:"Shader assembly now supports WGSL and single shader source (compute or single vertex+fragment WGSL shaders)"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:(0,l.jsx)(n.code,{children:"@luma.gl/webgl"})})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"The new bindings API now supports WebGL 2 Uniform Buffers."}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:['WebGL 2 Extension support: WebGL is not dead yet! Browsers (Chrome in particular)\nare actively developing "extensions" for WebGL 2,\nand luma.gl is exposing support for many of the new WebGL extensions through the\n',(0,l.jsx)(n.a,{href:"/docs/api-reference/core/device-features",children:(0,l.jsx)(n.code,{children:"DeviceFeatures"})})," API."]}),"\n",(0,l.jsxs)(n.p,{children:["New ",(0,l.jsx)(n.code,{children:"Device.features"})," that improve application performance in WebGL:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"compilation-status-async-webgl"}),": Asynchronous shader compilation and linking is used automatically by luma.gl and significantly speeds up applications that create many ",(0,l.jsx)(n.code,{children:"RenderPipelines"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["New ",(0,l.jsx)(n.code,{children:"Device.features"})," that enable additional color format support in WebGL:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"rgb9e5ufloat-renderable-webgl"}),": ",(0,l.jsx)(n.code,{children:"rgb9e5ufloat"})," is renderable."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"snorm8-renderable-webgl"}),": ",(0,l.jsx)(n.code,{children:"r,rg,rgba8snorm"})," are renderable."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"norm16-renderable-webgl"}),": ",(0,l.jsx)(n.code,{children:"r,rg,rgba16norm"})," are renderable."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"snorm16-renderable-webgl"}),": ",(0,l.jsx)(n.code,{children:"r,rg,rgba16snorm"})," are renderable."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["New ",(0,l.jsx)(n.code,{children:"Device.features"})," that expose new GPU parameters in WebGL:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"depth-clip-control"}),": ",(0,l.jsx)(n.code,{children:"parameters.unclippedDepth"})," - depth clipping can now be disabled."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"provoking-vertex-webgl"}),": ",(0,l.jsx)(n.code,{children:"parameters.provokingVertex"})," - controls which primitive vertex is used for flat shading."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"polygon-mode-webgl"}),": ",(0,l.jsx)(n.code,{children:"parameters.polygonMode"})," - enables wire frame rendering of polygons."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"polygon-mode-webgl"}),": ",(0,l.jsx)(n.code,{children:"parameters.polygonOffsetLine"})," - enables depth bias (polygon offset) for lines."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"shader-clip-cull-distance-webgl"}),": ",(0,l.jsx)(n.code,{children:"parameters.clipCullDistance0-7"}),", also see GLSL effects below."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["New ",(0,l.jsx)(n.code,{children:"Device.features"})," that enable new GLSL syntax"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"shader-noperspective-interpolation-webgl"}),": GLSL vertex outputs and fragment inputs may be declared with a ",(0,l.jsx)(n.code,{children:"noperspective"})," interpolation qualifier."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"shader-conservative-depth-webgl"}),": GLSL ",(0,l.jsx)(n.code,{children:"gl_FragDepth"})," qualifiers ",(0,l.jsx)(n.code,{children:"depth_any"})," ",(0,l.jsx)(n.code,{children:"depth_greater"})," ",(0,l.jsx)(n.code,{children:"depth_less"})," ",(0,l.jsx)(n.code,{children:"depth_unchanged"})," can enable early depth test optimizations."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"shader-clip-cull-distance-webgl"}),": Enables ",(0,l.jsx)(n.code,{children:"gl_ClipDistance[] / gl_CullDistance[]"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var r=s(6540);const l={},i=r.createContext(l);function d(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);