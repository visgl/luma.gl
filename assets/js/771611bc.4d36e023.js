/*! For license information please see 771611bc.4d36e023.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[7271],{3513:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var n=t(4848),s=t(8453);const o={},i="TextureTransform",d={id:"api-reference/engine/transform/texture-transform",title:"TextureTransform",description:"TextureTransform is an internal helper class for Transform, responsible for managing resources and state required for reading from and/or writing to Texture objects. It auto creates Texture objects when requested, creates Framebuffer objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.",source:"@site/../docs/api-reference/engine/transform/texture-transform.md",sourceDirName:"api-reference/engine/transform",slug:"/api-reference/engine/transform/texture-transform",permalink:"/docs/api-reference/engine/transform/texture-transform",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/engine/transform/texture-transform.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"BufferTransform",permalink:"/docs/api-reference/engine/transform/buffer-transform"},next:{title:"GroupNode",permalink:"/docs/api-reference/engine/scenegraph/group-node"}},c={},a=[{value:"Constructor",id:"constructor",level:2},{value:"Transform(gl : WebGL2RenderingContext, props: Object)",id:"transformgl--webgl2renderingcontext-props-object",level:3},{value:"Methods (Model props)",id:"methods-model-props",level:2},{value:"getDrawOptions(opts: Object) : Object",id:"getdrawoptionsopts-object--object",level:3},{value:"updateModelProps(props: Object) : Object",id:"updatemodelpropsprops-object--object",level:3},{value:"Methods (Resource management)",id:"methods-resource-management",level:2},{value:"swap()",id:"swap",level:3},{value:"update(props: Object)",id:"updateprops-object",level:3},{value:"Methods (Accessors)",id:"methods-accessors",level:2},{value:"getTargetTexture() : Texture",id:"gettargettexture--texture",level:3},{value:"getData([options : Object]) : ArrayBufferView",id:"getdataoptions--object--arraybufferview",level:3},{value:"getFramebuffer() : Framebuffer",id:"getframebuffer--framebuffer",level:3}];function l(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"texturetransform",children:"TextureTransform"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"TextureTransform"})," is an internal helper class for ",(0,n.jsx)(r.code,{children:"Transform"}),", responsible for managing resources and state required for reading from and/or writing to ",(0,n.jsx)(r.code,{children:"Texture"})," objects. It auto creates ",(0,n.jsx)(r.code,{children:"Texture"})," objects when requested, creates ",(0,n.jsx)(r.code,{children:"Framebuffer"})," objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds."]}),"\n",(0,n.jsxs)(r.p,{children:["NOTE: In following sections 'texture transform' is used to refer to 'reading from and/or writing to ",(0,n.jsx)(r.code,{children:"Texture"})," objects'."]}),"\n",(0,n.jsx)(r.h2,{id:"constructor",children:"Constructor"}),"\n",(0,n.jsx)(r.h3,{id:"transformgl--webgl2renderingcontext-props-object",children:"Transform(gl : WebGL2RenderingContext, props: Object)"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"gl"})," (",(0,n.jsx)(r.code,{children:"WebGLRenderingContext"}),") gl - context"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"})," (",(0,n.jsx)(r.code,{children:"Object"}),", Optional) - contains following data.","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"sourceTextures"})," (",(0,n.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,n.jsx)(r.code,{children:"Texture"})," object."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"targetTexture"})," (",(0,n.jsx)(r.code,{children:"Texture"}),"|",(0,n.jsx)(r.code,{children:"String"}),", Optional) - ",(0,n.jsx)(r.code,{children:"Texture"})," object to which data to be written. When it is a ",(0,n.jsx)(r.code,{children:"String"}),", it must be one of the source texture attributes name, a new texture object is cloned from it."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"targetTextureVarying"})," (",(0,n.jsx)(r.code,{children:"String"}),") : varying name used in vertex shader who's data should go into target texture."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"swapTexture"})," (",(0,n.jsx)(r.code,{children:"String"}),") : source texture attribute name, that is swapped with target texture every time ",(0,n.jsx)(r.code,{children:"swap()"})," is called."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"fs"})," (",(0,n.jsx)(r.code,{children:"String"}),", Optional) - fragment shader string, when rendering to a texture, fragments can be processed using this custom shader, when not specified, pass through fragment shader will be used."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"methods-model-props",children:"Methods (Model props)"}),"\n",(0,n.jsx)(r.h3,{id:"getdrawoptionsopts-object--object",children:"getDrawOptions(opts: Object) : Object"}),"\n",(0,n.jsxs)(r.p,{children:["Returns options required when performing ",(0,n.jsx)(r.code,{children:"Model.draw()"})," options."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"opts"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - Any existing ",(0,n.jsx)(r.code,{children:"opts.attributes"})," , ",(0,n.jsx)(r.code,{children:"opts.parameters"}),", and ",(0,n.jsx)(r.code,{children:"opts.uniforms"})," will be merged with new values."]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Returns an Object : attributes, framebuffer, uniforms, discard, parameters"}),"\n",(0,n.jsx)(r.h3,{id:"updatemodelpropsprops-object--object",children:"updateModelProps(props: Object) : Object"}),"\n",(0,n.jsxs)(r.p,{children:["Updates input ",(0,n.jsx)(r.code,{children:"props"})," object used to build ",(0,n.jsx)(r.code,{children:"Model"})," object, with data required for texture transform."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - props for building ",(0,n.jsx)(r.code,{children:"Model"})," object, it will updated with required options (",(0,n.jsx)(r.code,{children:"{vs, fs, modules, uniforms, inject}"}),") for texture transform."]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Returns updated object."}),"\n",(0,n.jsx)(r.h2,{id:"methods-resource-management",children:"Methods (Resource management)"}),"\n",(0,n.jsx)(r.h3,{id:"swap",children:"swap()"}),"\n",(0,n.jsxs)(r.p,{children:["If ",(0,n.jsx)(r.code,{children:"swapTexture"})," is provided during construction, performs source and feedback buffers swap as per the ",(0,n.jsx)(r.code,{children:"swapTexture"})," mapping."]}),"\n",(0,n.jsx)(r.h3,{id:"updateprops-object",children:"update(props: Object)"}),"\n",(0,n.jsx)(r.p,{children:"Updates bindings for source and target texture."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - contains following data.","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"sourceTextures"})," (",(0,n.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,n.jsx)(r.code,{children:"Texture"})," object."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"targetTexture"})," (",(0,n.jsx)(r.code,{children:"Texture"}),"|",(0,n.jsx)(r.code,{children:"String"}),", Optional) - ",(0,n.jsx)(r.code,{children:"Texture"})," object to which data to be written. When it is a ",(0,n.jsx)(r.code,{children:"String"}),", it must be one of the source texture attributes name, a new texture object is cloned from it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"methods-accessors",children:"Methods (Accessors)"}),"\n",(0,n.jsx)(r.h3,{id:"gettargettexture--texture",children:"getTargetTexture() : Texture"}),"\n",(0,n.jsx)(r.p,{children:"Returns current target texture object."}),"\n",(0,n.jsx)(r.h3,{id:"getdataoptions--object--arraybufferview",children:"getData([options : Object]) : ArrayBufferView"}),"\n",(0,n.jsx)(r.p,{children:"Reads and returns data from current target texture."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"options.packed"})," (Boolean, Optional, Default: false) - When true, data is packed to the actual size varyings. When false return array contains 4 values (R, G, B and A) for each element. Un-used element value will be 0 for R, G and B and 1 for A channel."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"getframebuffer--framebuffer",children:"getFramebuffer() : Framebuffer"}),"\n",(0,n.jsxs)(r.p,{children:["Returns current ",(0,n.jsx)(r.code,{children:"Framebuffer"})," object."]})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1020:(e,r,t)=>{var n=t(6540),s=Symbol.for("react.element"),o=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,d=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function a(e,r,t){var n,o={},a=null,l=null;for(n in void 0!==t&&(a=""+t),void 0!==r.key&&(a=""+r.key),void 0!==r.ref&&(l=r.ref),r)i.call(r,n)&&!c.hasOwnProperty(n)&&(o[n]=r[n]);if(e&&e.defaultProps)for(n in r=e.defaultProps)void 0===o[n]&&(o[n]=r[n]);return{$$typeof:s,type:e,key:a,ref:l,props:o,_owner:d.current}}r.Fragment=o,r.jsx=a,r.jsxs=a},4848:(e,r,t)=>{e.exports=t(1020)},8453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>d});var n=t(6540);const s={},o=n.createContext(s);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);