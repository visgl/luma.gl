"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[4991],{7396:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"api-guide/gpu/gpu-attributes","title":"Attributes","description":"Note that while attributes is a structured and performant mechanism to provide columnar data to shaders that works on both WebGPU and WebGL, they are rather rigid and have a number of limitations. In WebGPU a more significantly more flexible approach is to use storage buffers.","source":"@site/../docs/api-guide/gpu/gpu-attributes.md","sourceDirName":"api-guide/gpu","slug":"/api-guide/gpu/gpu-attributes","permalink":"/docs/api-guide/gpu/gpu-attributes","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-guide/gpu/gpu-attributes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Understanding Bindings","permalink":"/docs/api-guide/gpu/gpu-bindings"},"next":{"title":"Uniforms","permalink":"/docs/api-guide/gpu/gpu-uniforms"}}');var i=r(4848),a=r(8453);const o={},s="Attributes",d={},u=[{value:"Structure",id:"structure",level:2},{value:"VertexFormats",id:"vertexformats",level:2},{value:"Buffer Memory Layout",id:"buffer-memory-layout",level:2},{value:"Interleaved Data",id:"interleaved-data",level:2},{value:"Binding Buffers",id:"binding-buffers",level:2},{value:"Index Buffers",id:"index-buffers",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"attributes",children:"Attributes"})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["Note that while ",(0,i.jsx)(t.strong,{children:"attributes"})," is a structured and performant mechanism to provide columnar data to shaders that works on both WebGPU and WebGL, they are rather rigid and have a number of limitations. In WebGPU a more significantly more flexible approach is to use ",(0,i.jsx)(t.a,{href:"./gpu-storage-buffers",children:"storage buffers"}),"."]})}),"\n",(0,i.jsx)(t.p,{children:"The traditional 3D GPU execution model is that shaders work on vertexes, each vertex having a number of unique values such as position, normal, texture coordinates etc."}),"\n",(0,i.jsxs)(t.p,{children:["In this model, the purpose of GPU vertex ",(0,i.jsx)(t.strong,{children:"attributes"})," is to\nlet the application provide arrays of vertex data\ndescribing the 3D models that are to be rendered.\nEach attribute would be an array containing values for each vertex such as positions, normals, texture coordinates)."]}),"\n",(0,i.jsx)(t.p,{children:'More generally, in this model a GPU can be thought of as operating on "binary columnar tables", where:'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'Attributes are "columnar binary arrays" with the same number of elements that each contain one value for each row.'}),"\n",(0,i.jsx)(t.li,{children:"Each column is an array of either floating point values, or signed or unsigned integers."}),"\n",(0,i.jsx)(t.li,{children:"A row can use up either a single value, or represent a vector of 2, 3 or 4 elements."}),"\n",(0,i.jsx)(t.li,{children:"All rows in a column must be of the same format (single value or vector)"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"structure",children:"Structure"}),"\n",(0,i.jsx)(t.p,{children:"In luma.gl attribute structure is described by two complementary concepts:"}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"ShaderLayout"})," describes the static structure of attributes\ndeclared in the shader source code. This includes:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'the "location" (the index of the attribute in the GPU\'s attribute bank)'}),"\n",(0,i.jsx)(t.li,{children:"the type of the attribute declared in the shader (f32, i32, u32), and number of components."}),"\n",(0,i.jsx)(t.li,{children:"a step mode ('vertex' or 'instance')."}),"\n",(0,i.jsx)(t.li,{children:"whether calculations will be performed in integer or floating point arithmetic."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"BufferLayout"})," describes the dynamic structure of one buffer (the actual GPU memory)\nthat is expected be bound to the pipeline before ",(0,i.jsx)(t.code,{children:"draw()"})," or ",(0,i.jsx)(t.code,{children:"run()"})," is called.\nSpecifically it"]}),"\n",(0,i.jsx)(t.h2,{id:"vertexformats",children:"VertexFormats"}),"\n",(0,i.jsxs)(t.p,{children:["The format of a vertex attribute indicates how data from a vertex buffer\nwill be interpreted and exposed to the shader. Each format has a name that encodes\nthe order of components, bits per component, and vertex data type for the component.\nThe ",(0,i.jsx)(t.code,{children:"VertexFormat"})," type is a string union of all the defined vertex formats."]}),"\n",(0,i.jsxs)(t.p,{children:["See the ",(0,i.jsx)(t.a,{href:"/docs/api-reference/core/vertex-formats",children:"VertexFormat reference"})," for information about which formats are available.."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.a,{href:"https://www.w3.org/TR/webgpu/#vertex-state",children:"WebGPU"})," is more restrictive than WebGL in terms of supported data formats for vertex attributes."]}),"\n",(0,i.jsx)(t.h2,{id:"buffer-memory-layout",children:"Buffer Memory Layout"}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"BufferLayout"})," enumerates the attributes that will be read from the memory in each bound buffer."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"the data format of the memory in the buffer, i.e: the primitive data type (float, int, short, byte etc)"}),"\n",(0,i.jsx)(t.li,{children:'and the number of components per "row" or "vertex"'}),"\n",(0,i.jsx)(t.li,{children:"the data format also describes if the memory represents normalized integers."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Note that data formats are allowed to differ between attributes even when they are stored in the same GPU buffer."}),"\n",(0,i.jsx)(t.h2,{id:"interleaved-data",children:"Interleaved Data"}),"\n",(0,i.jsx)(t.p,{children:"While buffers supplied by applications to define attribute values often contain\nonly a contiguous block of memory for a single attribute, a buffer can also be set up to\ncontain the memory for multiple attributes, either in sequence, or interleaved."}),"\n",(0,i.jsx)(t.h2,{id:"binding-buffers",children:"Binding Buffers"}),"\n",(0,i.jsxs)(t.p,{children:["Attributes define binding points for memory arrays in the form of ",(0,i.jsx)(t.code,{children:"Buffer"}),"s."]}),"\n",(0,i.jsx)(t.p,{children:"The structure (memory layout and format) of these memory contained in these buffers.\nmust match the constraints imposed by the shader source code,\nand the structure of the data in the buffers must also be communicated to the GPU."}),"\n",(0,i.jsx)(t.h2,{id:"index-buffers",children:"Index Buffers"}),"\n",(0,i.jsx)(t.p,{children:"An index buffer can be provided to provide a list of indices into the vertex array attributes. This allows vertexes to be reordered, filtered out, or duplicated without copying / modifying any memory other than the index array."})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>s});var n=r(6540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);