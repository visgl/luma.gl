/*! For license information please see 0e99efda.076b002c.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[8256],{6202:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=i(4848),t=i(8453);const s={},o="Debugging",a={id:"developer-guide/debugging",title:"Debugging",description:"Why GPU Debugging can be hard",source:"@site/../docs/developer-guide/debugging.md",sourceDirName:"developer-guide",slug:"/developer-guide/debugging",permalink:"/docs/developer-guide/debugging",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/developer-guide/debugging.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Installing",permalink:"/docs/developer-guide/installing"},next:{title:"Testing",permalink:"/docs/developer-guide/testing"}},l={},d=[{value:"Why GPU Debugging can be hard",id:"why-gpu-debugging-can-be-hard",level:2},{value:"Debug Support Overview",id:"debug-support-overview",level:2},{value:"Debug flags",id:"debug-flags",level:2},{value:"Browser console debug API",id:"browser-console-debug-api",level:2},{value:"id strings",id:"id-strings",level:2},{value:"Logging",id:"logging",level:2},{value:"Shader compilation errors",id:"shader-compilation-errors",level:2},{value:"Buffer data inspection",id:"buffer-data-inspection",level:2},{value:"Parameter Validation",id:"parameter-validation",level:2},{value:"Resource Leak Detection",id:"resource-leak-detection",level:2},{value:"WebGL API tracing integration (WebGL only)",id:"webgl-api-tracing-integration-webgl-only",level:2},{value:"Spector.js integration (WebGL only)",id:"spectorjs-integration-webgl-only",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"debugging",children:"Debugging"}),"\n",(0,r.jsx)(n.h2,{id:"why-gpu-debugging-can-be-hard",children:"Why GPU Debugging can be hard"}),"\n",(0,r.jsx)(n.p,{children:"Debugging GPU code can be challenging. Standard CPU-side debugging tools like\nbreakpoints and single stepping are not available in GPU shaders.  when shaders fail, the result is often a blank screen that does not provide much information about what went wrong.\nIn addition, the error behind a failed render can be located in very different parts of the code:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"it can be in the shader code itself"}),"\n",(0,r.jsx)(n.li,{children:"but it can also be in the data that was provided to the GPU (attributes, bindings, uniforms etc)"}),"\n",(0,r.jsx)(n.li,{children:"or in one of the many GPU pipeline settings"}),"\n",(0,r.jsx)(n.li,{children:"or in the way the APIs were called."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"debug-support-overview",children:"Debug Support Overview"}),"\n",(0,r.jsx)(n.p,{children:"luma.gl provides a number of facilities for debugging your GPU code, to help you save time during development. These features include"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["All GPU objects have auto-populated but configurable ",(0,r.jsx)(n.code,{children:"id"})," fields."]}),"\n",(0,r.jsx)(n.li,{children:"Configurable logging of GPU operations, with optional verbose logs that display all values being passed to each draw call."}),"\n",(0,r.jsx)(n.li,{children:"Propagates detailed logs of errors and warnings during shader compilation."}),"\n",(0,r.jsx)(n.li,{children:"WebGL Parameter validation."}),"\n",(0,r.jsx)(n.li,{children:"Spector.js integration"}),"\n",(0,r.jsx)(n.li,{children:"Khronos WebGL debug integration - Synchronous WebGL error capture (optional module)."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"debug-flags",children:"Debug flags"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"luma.createDevice()"})," API accepts a number of debug parameters"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const device = luma.createDevice({\n  debugFramebuffers: true,\n  debugWebGL: true,\n  debugSpectorJS: true,\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"browser-console-debug-api",children:"Browser console debug API"}),"\n",(0,r.jsxs)(n.p,{children:["luma.gl exposes a global variable ",(0,r.jsx)(n.code,{children:"luma.log"})," that can be manipulated in your browser dev tools console window to activate debugging.\nA nice aspect of this system is that it keeps state when refreshing the browser page, meaning that you can change log level, refresh the browser tab and get logs while your program reinitializes."]}),"\n",(0,r.jsxs)(n.p,{children:["You can enable and disable debug features using the ",(0,r.jsx)(n.code,{children:"luma.log.set"})," feature. In your browser console tab, type:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.log.set('debug-webgl', true)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can also control the amount of logging you get by changing ",(0,r.jsx)(n.code,{children:"luma.log.level"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.log.level=1 \n"})}),"\n",(0,r.jsx)(n.h2,{id:"id-strings",children:"id strings"}),"\n",(0,r.jsxs)(n.p,{children:["Most classes in luma.gl allow you to supply an optional ",(0,r.jsx)(n.code,{children:"id"})," string to their constructors.\nThis allows you to later easily check in the debugger which object\n(which specific instance of that class) you are looking at when debugging code."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const program = device.createRenderPipeline({id: 'cube-program', ...});\nconst program = device.createRenderPipeline({id: 'pyramid-program', ...});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Apart from providing a human-readable ",(0,r.jsx)(n.code,{children:"id"})," field when inspecting objects in the debugger,",(0,r.jsx)(n.br,{}),"\n","the ",(0,r.jsx)(n.code,{children:"id"})," is used in the following ways:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["luma.gl's built-in logging (see next section) often includes the ",(0,r.jsx)(n.code,{children:"id"}),"s."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id"})," is copied into the WebGPU object ",(0,r.jsx)(n.code,{children:"label"})," field which is designed to support debugging."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id"})," is exposed to the WebGL Spector.js library (when activated, luma.gl sets the [",(0,r.jsx)(n.code,{children:"__SPECTOR_Metadata"}),"](",(0,r.jsx)(n.a,{href:"https://github.com/BabylonJS/Spector.js#custom-data",children:"https://github.com/BabylonJS/Spector.js#custom-data"})," field on WebGL object handles)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,r.jsxs)(n.p,{children:["luma.gl logs a number of activities which can be helpful to understanding what is happening.\nSet the global variable ",(0,r.jsx)(n.code,{children:"luma.log.level"})," (this can be done in the browser console at any time)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.log.level=1 \n"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.code,{children:"luma.log.level"})}),(0,r.jsx)(n.th,{children:"luma.gl will print"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"1"})}),(0,r.jsx)(n.td,{children:"modest amount of initialization information."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"3"})}),(0,r.jsx)(n.td,{children:"tables for uniforms and attributes providing information about their values and types before each render call. This can be extremely helpful for checking that shaders are getting valid inputs."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"shader-compilation-errors",children:"Shader compilation errors"}),"\n",(0,r.jsx)(n.p,{children:"luma.gl extract as much information as possible about shader compiler errors etc,\nand will throw exceptions with messages intended to help narrow down the problematic shader code when a shader fails to compile."}),"\n",(0,r.jsxs)(n.p,{children:["When running in the browser, luma.gl will open a shader source code viewer window inside the application's canvas.\nThis window shows both the shader source as well as any error messages and warnings from the shader compiler.\nIf available translated native source is also shown.\nNormally this window is shown only if errors occur. By setting ",(0,r.jsx)(n.code,{children:"Model.props.debugShaders: 'always'"})," the application can force\nthe debug window to always appear."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that luma.gl also injects and parses ",(0,r.jsx)(n.code,{children:"glslify"}),"-style ",(0,r.jsx)(n.code,{children:"#define SHADER_NAME"}),' "shader names".\nNaming shaders directly in the shader code can help identify which\nshader is involved when debugging shader parsing errors occur.']}),"\n",(0,r.jsx)(n.h2,{id:"buffer-data-inspection",children:"Buffer data inspection"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Buffer"})," objects contain a CPU side copy of the first few bytes of data in the ",(0,r.jsx)(n.code,{children:"buffer.debugData"})," field. This field is refreshed whenever data is written or read from the CPU side, using ",(0,r.jsx)(n.code,{children:"buffer.write()"}),", ",(0,r.jsx)(n.code,{children:"buffer.readAsync()"})," etc and can be inspected in the debugger to inspect the contents of the buffer."]}),"\n",(0,r.jsx)(n.p,{children:"Note that this CPU side data copy can become invalid when buffers are updated on the GPU by compute shaders or transform feedback operations, in which case reading from the buffer would be necessary to refresh the CPU side data."}),"\n",(0,r.jsx)(n.h2,{id:"parameter-validation",children:"Parameter Validation"}),"\n",(0,r.jsxs)(n.p,{children:["luma.gl runs checks on attributes and buffers when they are being set, catching many trivial errors such as setting uniforms to ",(0,r.jsx)(n.code,{children:"undefined"})," or wrong type (scalar vs array etc)."]}),"\n",(0,r.jsx)(n.p,{children:"Buffers will also have their first values checked to ensure that they are not NaN. As an example, setting uniforms to illegal values now throws an exception containing a helpful error message including the name of the problematic uniform."}),"\n",(0,r.jsx)(n.h2,{id:"resource-leak-detection",children:"Resource Leak Detection"}),"\n",(0,r.jsx)(n.p,{children:"See the chapter on Profiling for tools that can help spot resource leaks."}),"\n",(0,r.jsx)(n.h2,{id:"webgl-api-tracing-integration-webgl-only",children:"WebGL API tracing integration (WebGL only)"}),"\n",(0,r.jsxs)(n.p,{children:["luma.gl is pre-integrated with the Khronos group's WebGL developer tools (the ",(0,r.jsx)(n.a,{href:"https://github.com/KhronosGroup/WebGLDeveloperTools",children:"WebGLDeveloperTools"}),") which provide the following features:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"WebGL API tracing"})," - Logs each call to the WebGL context with parameters."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous WebGL Error Detections"})," - Checks the WebGL error status after each WebGL call and throws an exception if an error was detected, breaking the debugger at the correct place, and also extract helpful information about the error."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"WebGL Parameters Checking"})," - Checks that WebGL parameters are set to valid values."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The most flexible way to enable WebGL API tracing is by typing the following command into the browser developer tools console:"}),"\n",(0,r.jsx)(n.p,{children:"Note that the developer tools module is loaded dynamically when a device is created with the debug flag set, so the developer tools can be activated in production code by opening the browser console and typing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.set('debug-webgl', true)\n"})}),"\n",(0,r.jsx)(n.p,{children:"then reload your browser tab."}),"\n",(0,r.jsxs)(n.p,{children:["While usually not recommended, it is also possible to activate the developer tools manually. Call ",(0,r.jsx)(n.a,{href:"/docs/api-reference/core/luma#lumacreatedevice",children:(0,r.jsx)(n.code,{children:"luma.createDevice"})})," with ",(0,r.jsx)(n.code,{children:"debugWebGL: true"})," to create a WebGL context instrumented with the WebGL developer tools:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {luma} from '@luma.gl/core';\nconst device = luma.createDevice({type: 'webgl', {debugWebGL: true});\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Warning: WebGL debug contexts impose a significant performance penalty (luma waits for the GPU after each WebGL call to check error codes) and should not be activated in production code."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"spectorjs-integration-webgl-only",children:"Spector.js integration (WebGL only)"}),"\n",(0,r.jsxs)(n.p,{children:["luma.gl integrates with ",(0,r.jsx)(n.a,{href:"https://spector.babylonjs.com/",children:"Spector.js"}),", a powerful debug tool created by the BabylonJS team."]}),"\n",(0,r.jsx)(n.p,{children:"The most flexible way to enable Spector.js is by typing the following command into the browser developer tools console:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.log.set('debug-spectorjs', true);\n"})}),"\n",(0,r.jsx)(n.p,{children:"And then restarting the application (e.g. via Command-R on MacOS),"}),"\n",(0,r.jsxs)(n.p,{children:["You can also enable spector when creating a device  by adding the ",(0,r.jsx)(n.code,{children:"debugSpectorJS: true"})," option."]}),"\n",(0,r.jsx)(n.p,{children:"To display Spector.js stats when loaded."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"luma.spector.displayUI()\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Spector.js is dynamically loaded into your application, so there is no bundle size penalty."})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1020:(e,n,i)=>{var r=i(6540),t=Symbol.for("react.element"),s=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,i){var r,s={},d=null,c=null;for(r in void 0!==i&&(d=""+i),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(c=n.ref),n)o.call(n,r)&&!l.hasOwnProperty(r)&&(s[r]=n[r]);if(e&&e.defaultProps)for(r in n=e.defaultProps)void 0===s[r]&&(s[r]=n[r]);return{$$typeof:t,type:e,key:d,ref:c,props:s,_owner:a.current}}n.Fragment=s,n.jsx=d,n.jsxs=d},4848:(e,n,i)=>{e.exports=i(1020)},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);