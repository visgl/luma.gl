"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[849],{6164:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","label":"Overview","href":"/docs/","docId":"README","unlisted":false},{"type":"link","label":"What\'s New","href":"/docs/whats-new","docId":"whats-new","unlisted":false},{"type":"link","label":"Upgrade Guide","href":"/docs/upgrade-guide","docId":"upgrade-guide","unlisted":false},{"type":"category","label":"Tutorials","items":[{"type":"link","label":"Setup","href":"/docs/tutorials/","docId":"tutorials/README","unlisted":false},{"type":"link","label":"Hello Triangle","href":"/docs/tutorials/hello-triangle","docId":"tutorials/hello-triangle","unlisted":false},{"type":"link","label":"Hello Cube","href":"/docs/tutorials/hello-cube","docId":"tutorials/hello-cube","unlisted":false},{"type":"link","label":"Lighting","href":"/docs/tutorials/lighting","docId":"tutorials/lighting","unlisted":false},{"type":"link","label":"Hello Instancing","href":"/docs/tutorials/hello-instancing","docId":"tutorials/hello-instancing","unlisted":false},{"type":"link","label":"Shader Modules","href":"/docs/tutorials/shader-modules","docId":"tutorials/shader-modules","unlisted":false},{"type":"link","label":"Shader Hooks","href":"/docs/tutorials/shader-hooks","docId":"tutorials/shader-hooks","unlisted":false},{"type":"link","label":"Transform Feedback","href":"/docs/tutorials/transform-feedback","docId":"tutorials/transform-feedback","unlisted":false},{"type":"link","label":"What\'s Next?","href":"/docs/tutorials/whats-next","docId":"tutorials/whats-next","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Guide","items":[{"type":"link","label":"API Overview","href":"/docs/api-guide/","docId":"api-guide/README","unlisted":false},{"type":"category","label":"Background","items":[{"type":"link","label":"API Design Philosophy","href":"/docs/api-guide/background/api-design","docId":"api-guide/background/api-design","unlisted":false},{"type":"link","label":"Learning Resources","href":"/docs/api-guide/background/learning-resources","docId":"api-guide/background/learning-resources","unlisted":false},{"type":"link","label":"WebGPU vs WebGL","href":"/docs/api-guide/background/webgpu-vs-webgl","docId":"api-guide/background/webgpu-vs-webgl","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"GPU Programming","items":[{"type":"link","label":"GPU Initialization","href":"/docs/api-guide/gpu/gpu-initialization","docId":"api-guide/gpu/gpu-initialization","unlisted":false},{"type":"link","label":"GPU Resources","href":"/docs/api-guide/gpu/gpu-resources","docId":"api-guide/gpu/gpu-resources","unlisted":false},{"type":"link","label":"GPU Memory","href":"/docs/api-guide/gpu/gpu-memory","docId":"api-guide/gpu/gpu-memory","unlisted":false},{"type":"link","label":"Using GPU Buffers","href":"/docs/api-guide/gpu/gpu-buffers","docId":"api-guide/gpu/gpu-buffers","unlisted":false},{"type":"link","label":"Using GPU Textures","href":"/docs/api-guide/gpu/gpu-textures","docId":"api-guide/gpu/gpu-textures","unlisted":false},{"type":"link","label":"How Rendering Works","href":"/docs/api-guide/gpu/gpu-rendering","docId":"api-guide/gpu/gpu-rendering","unlisted":false},{"type":"link","label":"Using GPU Parameters","href":"/docs/api-guide/gpu/gpu-parameters","docId":"api-guide/gpu/gpu-parameters","unlisted":false},{"type":"link","label":"Understanding Bindings","href":"/docs/api-guide/gpu/gpu-bindings","docId":"api-guide/gpu/gpu-bindings","unlisted":false},{"type":"link","label":"Attributes","href":"/docs/api-guide/gpu/gpu-attributes","docId":"api-guide/gpu/gpu-attributes","unlisted":false},{"type":"link","label":"Uniforms","href":"/docs/api-guide/gpu/gpu-uniforms","docId":"api-guide/gpu/gpu-uniforms","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Shader Programming","items":[{"type":"link","label":"Shader Modules","href":"/docs/api-guide/shaders/shader-modules","docId":"api-guide/shaders/shader-modules","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Engine Programming","items":[{"type":"link","label":"GPU Computations and Transforms","href":"/docs/api-guide/engine/transforms","docId":"api-guide/engine/transforms","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"API Reference","items":[{"type":"link","label":"Overview","href":"/docs/api-reference/","docId":"api-reference/README","unlisted":false},{"type":"category","label":"@luma.gl/core","items":[{"type":"link","label":"Overview","href":"/docs/api-reference/core/","docId":"api-reference/core/README","unlisted":false},{"type":"link","label":"luma","href":"/docs/api-reference/core/luma","docId":"api-reference/core/luma","unlisted":false},{"type":"link","label":"Adapter","href":"/docs/api-reference/core/adapter","docId":"api-reference/core/adapter","unlisted":false},{"type":"link","label":"Device","href":"/docs/api-reference/core/device","docId":"api-reference/core/device","unlisted":false},{"type":"link","label":"DeviceInfo","href":"/docs/api-reference/core/device-info","docId":"api-reference/core/device-info","unlisted":false},{"type":"link","label":"DeviceFeatures","href":"/docs/api-reference/core/device-features","docId":"api-reference/core/device-features","unlisted":false},{"type":"link","label":"DeviceLimits","href":"/docs/api-reference/core/device-limits","docId":"api-reference/core/device-limits","unlisted":false},{"type":"link","label":"CanvasContext","href":"/docs/api-reference/core/canvas-context","docId":"api-reference/core/canvas-context","unlisted":false},{"type":"link","label":"GPU Parameters","href":"/docs/api-reference/core/parameters","docId":"api-reference/core/parameters","unlisted":false},{"type":"link","label":"Bindings","href":"/docs/api-reference/core/bindings","docId":"api-reference/core/bindings","unlisted":false},{"type":"link","label":"ShaderLayout","href":"/docs/api-reference/core/shader-layout","docId":"api-reference/core/shader-layout","unlisted":false},{"type":"link","label":"Texture Formats","href":"/docs/api-reference/core/texture-formats","docId":"api-reference/core/texture-formats","unlisted":false},{"type":"link","label":"Buffer","href":"/docs/api-reference/core/resources/buffer","docId":"api-reference/core/resources/buffer","unlisted":false},{"type":"link","label":"ComputePass","href":"/docs/api-reference/core/resources/compute-pass","docId":"api-reference/core/resources/compute-pass","unlisted":false},{"type":"link","label":"ComputePipeline","href":"/docs/api-reference/core/resources/compute-pipeline","docId":"api-reference/core/resources/compute-pipeline","unlisted":false},{"type":"link","label":"Framebuffer","href":"/docs/api-reference/core/resources/framebuffer","docId":"api-reference/core/resources/framebuffer","unlisted":false},{"type":"link","label":"RenderPass","href":"/docs/api-reference/core/resources/render-pass","docId":"api-reference/core/resources/render-pass","unlisted":false},{"type":"link","label":"RenderPipeline","href":"/docs/api-reference/core/resources/render-pipeline","docId":"api-reference/core/resources/render-pipeline","unlisted":false},{"type":"link","label":"Sampler","href":"/docs/api-reference/core/resources/sampler","docId":"api-reference/core/resources/sampler","unlisted":false},{"type":"link","label":"Shader","href":"/docs/api-reference/core/resources/shader","docId":"api-reference/core/resources/shader","unlisted":false},{"type":"link","label":"Shader Logs","href":"/docs/api-reference/core/shader-logs","docId":"api-reference/core/shader-logs","unlisted":false},{"type":"link","label":"Texture","href":"/docs/api-reference/core/resources/texture","docId":"api-reference/core/resources/texture","unlisted":false},{"type":"link","label":"TextureView","href":"/docs/api-reference/core/resources/texture-view","docId":"api-reference/core/resources/texture-view","unlisted":false},{"type":"link","label":"TransformFeedback","href":"/docs/api-reference/core/resources/transform-feedback","docId":"api-reference/core/resources/transform-feedback","unlisted":false},{"type":"link","label":"QuerySet","href":"/docs/api-reference/core/resources/query-set","docId":"api-reference/core/resources/query-set","unlisted":false},{"type":"link","label":"VertexArray","href":"/docs/api-reference/core/resources/vertex-array","docId":"api-reference/core/resources/vertex-array","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/engine","items":[{"type":"link","label":"Model","href":"/docs/api-reference/engine/model","docId":"api-reference/engine/model","unlisted":false},{"type":"link","label":"ShaderInputs","href":"/docs/api-reference/engine/shader-inputs","docId":"api-reference/engine/shader-inputs","unlisted":false},{"type":"link","label":"AnimationLoop","href":"/docs/api-reference/engine/animation-loop","docId":"api-reference/engine/animation-loop","unlisted":false},{"type":"link","label":"AnimationLoopTemplate","href":"/docs/api-reference/engine/animation-loop-template","docId":"api-reference/engine/animation-loop-template","unlisted":false},{"type":"link","label":"AsyncTexture","href":"/docs/api-reference/engine/async-texture","docId":"api-reference/engine/async-texture","unlisted":false},{"type":"link","label":"loadImageBitmap","href":"/docs/api-reference/engine/load-image-bitmap","docId":"api-reference/engine/load-image-bitmap","unlisted":false},{"type":"link","label":"Built-in Geometries","href":"/docs/api-reference/engine/geometry/geometries","docId":"api-reference/engine/geometry/geometries","unlisted":false},{"type":"link","label":"Geometry","href":"/docs/api-reference/engine/geometry/","docId":"api-reference/engine/geometry/geometry","unlisted":false},{"type":"link","label":"KeyFrames","href":"/docs/api-reference/engine/animation/key-frames","docId":"api-reference/engine/animation/key-frames","unlisted":false},{"type":"link","label":"Timeline","href":"/docs/api-reference/engine/animation/timeline","docId":"api-reference/engine/animation/timeline","unlisted":false},{"type":"link","label":"GroupNode","href":"/docs/api-reference/engine/scenegraph/group-node","docId":"api-reference/engine/scenegraph/group-node","unlisted":false},{"type":"link","label":"ModelNode","href":"/docs/api-reference/engine/scenegraph/model-node","docId":"api-reference/engine/scenegraph/model-node","unlisted":false},{"type":"link","label":"ScenegraphNode","href":"/docs/api-reference/engine/scenegraph/scenegraph-node","docId":"api-reference/engine/scenegraph/scenegraph-node","unlisted":false},{"type":"link","label":"PipelineFactory","href":"/docs/api-reference/engine/pipeline-factory","docId":"api-reference/engine/pipeline-factory","unlisted":false},{"type":"link","label":"ShaderFactory","href":"/docs/api-reference/engine/shader-factory","docId":"api-reference/engine/shader-factory","unlisted":false},{"type":"link","label":"ShaderPassRenderer","href":"/docs/api-reference/engine/passes/shader-pass-renderer","docId":"api-reference/engine/passes/shader-pass-renderer","unlisted":false},{"type":"link","label":"Swap","href":"/docs/api-reference/engine/compute/swap","docId":"api-reference/engine/compute/swap","unlisted":false},{"type":"link","label":"Computation","href":"/docs/api-reference/engine/compute/computation","docId":"api-reference/engine/compute/computation","unlisted":false},{"type":"link","label":"BufferTransform","href":"/docs/api-reference/engine/compute/buffer-transform","docId":"api-reference/engine/compute/buffer-transform","unlisted":false},{"type":"link","label":"TextureTransform","href":"/docs/api-reference/engine/compute/texture-transform","docId":"api-reference/engine/compute/texture-transform","unlisted":false},{"type":"link","label":"GPUPointInPolygon","href":"/docs/api-reference/engine/gpgpu/gpu-point-in-polygon","docId":"api-reference/engine/gpgpu/gpu-point-in-polygon","unlisted":false},{"type":"link","label":"Histopyramid","href":"/docs/api-reference/engine/gpgpu/histopyramid","docId":"api-reference/engine/gpgpu/histopyramid","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/gltf","items":[{"type":"link","label":"Overview","href":"/docs/api-reference/gltf/","docId":"api-reference/gltf/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/shadertools","items":[{"type":"category","label":"Shader Modules","items":[{"type":"link","label":"fp32 (32-bit Floating Point)","href":"/docs/api-reference/shadertools/shader-modules/fp32","docId":"api-reference/shadertools/shader-modules/fp32","unlisted":false},{"type":"link","label":"fp64 (64-bit Floating Point)","href":"/docs/api-reference/shadertools/shader-modules/fp64","docId":"api-reference/shadertools/shader-modules/fp64","unlisted":false},{"type":"link","label":"pbrMaterial","href":"/docs/api-reference/shadertools/shader-modules/pbr-material","docId":"api-reference/shadertools/shader-modules/pbr-material","unlisted":false},{"type":"link","label":"phongMaterial","href":"/docs/api-reference/shadertools/shader-modules/phong-material","docId":"api-reference/shadertools/shader-modules/phong-material","unlisted":false},{"type":"link","label":"gouraudMaterial","href":"/docs/api-reference/shadertools/shader-modules/gouraud-material","docId":"api-reference/shadertools/shader-modules/gouraud-material","unlisted":false},{"type":"link","label":"picking","href":"/docs/api-reference/shadertools/shader-modules/picking","docId":"api-reference/shadertools/shader-modules/picking","unlisted":false},{"type":"link","label":"project","href":"/docs/api-reference/shadertools/shader-modules/project","docId":"api-reference/shadertools/shader-modules/project","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Shader Passes","items":[{"type":"link","label":"Image Processing","href":"/docs/api-reference/shadertools/shader-passes/image-processing","docId":"api-reference/shadertools/shader-passes/image-processing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"link","label":"Overview","href":"/docs/api-reference/shadertools/","docId":"api-reference/shadertools/README","unlisted":false},{"type":"link","label":"ShaderModule","href":"/docs/api-reference/shadertools/shader-module","docId":"api-reference/shadertools/shader-module","unlisted":false},{"type":"link","label":"ShaderAssembler","href":"/docs/api-reference/shadertools/shader-assembler","docId":"api-reference/shadertools/shader-assembler","unlisted":false},{"type":"link","label":"Shader Parsing","href":"/docs/api-reference/shadertools/shader-info","docId":"api-reference/shadertools/shader-info","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/test-utils","items":[{"type":"link","label":"Overview","href":"/docs/api-reference/test-utils/","docId":"api-reference/test-utils/README","unlisted":false},{"type":"link","label":"SnapshotTestRunner","href":"/docs/api-reference/test-utils/snapshot-test-runner","docId":"api-reference/test-utils/snapshot-test-runner","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgl","items":[{"type":"link","label":"@luma.gl/webgl","href":"/docs/api-reference/webgl/","docId":"api-reference/webgl/README","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"@luma.gl/webgpu","items":[{"type":"link","label":"Overview","href":"/docs/api-reference/webgpu/","docId":"api-reference/webgpu/README","unlisted":false}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"Developer Guide","items":[{"type":"link","label":"Developer Guide","href":"/docs/developer-guide/","docId":"developer-guide/README","unlisted":false},{"type":"link","label":"Installing","href":"/docs/developer-guide/installing","docId":"developer-guide/installing","unlisted":false},{"type":"link","label":"Debugging","href":"/docs/developer-guide/debugging","docId":"developer-guide/debugging","unlisted":false},{"type":"link","label":"Testing","href":"/docs/developer-guide/testing","docId":"developer-guide/testing","unlisted":false},{"type":"link","label":"Profiling","href":"/docs/developer-guide/profiling","docId":"developer-guide/profiling","unlisted":false},{"type":"link","label":"Bundling","href":"/docs/developer-guide/bundling","docId":"developer-guide/bundling","unlisted":false},{"type":"link","label":"Contributing","href":"/docs/developer-guide/contributing","docId":"developer-guide/contributing","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Legacy Guides","items":[{"type":"link","label":"Porting Guide","href":"/docs/legacy/porting-guide","docId":"legacy/porting-guide","unlisted":false},{"type":"link","label":"Legacy Upgrade Guide","href":"/docs/legacy/legacy-upgrade-guide","docId":"legacy/legacy-upgrade-guide","unlisted":false},{"type":"link","label":"Legacy What\'s New","href":"/docs/legacy/legacy-whats-new","docId":"legacy/legacy-whats-new","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"api-guide/background/api-design":{"id":"api-guide/background/api-design","title":"API Design Philosophy","description":"This article provides some background on luma.gl\'s API design philosophy.","sidebar":"defaultSidebar"},"api-guide/background/learning-resources":{"id":"api-guide/background/learning-resources","title":"Learning Resources","description":"WebGPU","sidebar":"defaultSidebar"},"api-guide/background/webgpu-vs-webgl":{"id":"api-guide/background/webgpu-vs-webgl","title":"WebGPU vs WebGL","description":"This page is a collection of developer notes on the differences between WebGPU and WebGL.","sidebar":"defaultSidebar"},"api-guide/engine/interactivity":{"id":"api-guide/engine/interactivity","title":"Interactivity","description":"Event Management"},"api-guide/engine/transforms":{"id":"api-guide/engine/transforms","title":"GPU Computations and Transforms","description":"Some operations can be very efficiently executed on the GPU.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-attributes":{"id":"api-guide/gpu/gpu-attributes","title":"Attributes","description":"In traditional 3D graphics, the purpose of GPU attributes* is to","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-bindings":{"id":"api-guide/gpu/gpu-bindings","title":"Understanding Bindings","description":"luma.gl offers support for setting up (\\"binding\\") data required by the GPU during shader execution, including:","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-buffers":{"id":"api-guide/gpu/gpu-buffers","title":"Using GPU Buffers","description":"Buffer Operations","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-initialization":{"id":"api-guide/gpu/gpu-initialization","title":"GPU Initialization","description":"Adapter","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-memory":{"id":"api-guide/gpu/gpu-memory","title":"GPU Memory","description":"Memory on GPU is managed through Buffer and Texture resources.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-parameters":{"id":"api-guide/gpu/gpu-parameters","title":"Using GPU Parameters","description":"luma.gl provides a unified API for controlling GPU parameters providing control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-rendering":{"id":"api-guide/gpu/gpu-rendering","title":"How Rendering Works","description":"Note that the luma.gl documentation includes a series of tutorials that explain how to render with the luma.gl API.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-resources":{"id":"api-guide/gpu/gpu-resources","title":"GPU Resources","description":"A key role of the Device class is to let the application create GPU resources.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-textures":{"id":"api-guide/gpu/gpu-textures","title":"Using GPU Textures","description":"While the idea behind textures is simple in principle (a grid of pixels stored on GPU memory), GPU Textures are surprisingly complex objects.","sidebar":"defaultSidebar"},"api-guide/gpu/gpu-uniforms":{"id":"api-guide/gpu/gpu-uniforms","title":"Uniforms","description":"Uniforms are shader variables whose values can be set from JavaScript.","sidebar":"defaultSidebar"},"api-guide/README":{"id":"api-guide/README","title":"API Overview","description":"The luma.gl API enables the creation of portable GPU applications that can run on top of either WebGPU, or WebGL 2.","sidebar":"defaultSidebar"},"api-guide/shaders/shader-modules":{"id":"api-guide/shaders/shader-modules","title":"Shader Modules","description":"luma.device provides a shader module system (through the @luma.device/shadertools module) that allows you build modular shaders. The system is built around a shader \\"assembler\\", and addresses the lack of a module/import system in the GLSL and WGSL languages. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.","sidebar":"defaultSidebar"},"api-reference/core/adapter":{"id":"api-reference/core/adapter","title":"Adapter","description":"An Adapter is a factory that creates Device instances for a specific backend (e.g. WebGPU or WebGL).","sidebar":"defaultSidebar"},"api-reference/core/bindings":{"id":"api-reference/core/bindings","title":"Bindings","description":"A key responsibility of any GPU API is to enable the application to","sidebar":"defaultSidebar"},"api-reference/core/buffer-layout":{"id":"api-reference/core/buffer-layout","title":"BufferLayout","description":"The bufferLayout type provides information about how the application is planning to"},"api-reference/core/canvas-context":{"id":"api-reference/core/canvas-context","title":"CanvasContext","description":"A CanvasContext holds a connection between a GPU Device and canvas, (either an HTML ` element, aka HTMLCanvasELement, or an OffscreenCanvas`).","sidebar":"defaultSidebar"},"api-reference/core/device":{"id":"api-reference/core/device","title":"Device","description":"The Device class manages the application\'s connection with the GPU,","sidebar":"defaultSidebar"},"api-reference/core/device-features":{"id":"api-reference/core/device-features","title":"DeviceFeatures","description":"The luma.gl Device provides a device \\"feature\\" system that allows applications","sidebar":"defaultSidebar"},"api-reference/core/device-info":{"id":"api-reference/core/device-info","title":"DeviceInfo","description":"The device.info field holds a small DeviceInfo object that provides information about the device, such as driver, GPU, shading language etc.","sidebar":"defaultSidebar"},"api-reference/core/device-limits":{"id":"api-reference/core/device-limits","title":"DeviceLimits","description":"The device.limits field contains limits object that indicates what the current platform supports.","sidebar":"defaultSidebar"},"api-reference/core/luma":{"id":"api-reference/core/luma","title":"luma","description":"The luma namespace provides luma.gl applications","sidebar":"defaultSidebar"},"api-reference/core/parameters":{"id":"api-reference/core/parameters","title":"GPU Parameters","description":"GPU parameters provide control of GPU pipeline features such as culling, depth and stencil buffers, blending, clipping etc.","sidebar":"defaultSidebar"},"api-reference/core/README":{"id":"api-reference/core/README","title":"Overview","description":"The @luma.gl/core module provides an abstract API that enables application code","sidebar":"defaultSidebar"},"api-reference/core/resources/buffer":{"id":"api-reference/core/resources/buffer","title":"Buffer","description":"Holds a block of GPU memory. The length of a buffer cannot be changed after creation.","sidebar":"defaultSidebar"},"api-reference/core/resources/command-encoder":{"id":"api-reference/core/resources/command-encoder","title":"CommandEncoder","description":"A command encoder offering GPU memory copying operations."},"api-reference/core/resources/compute-pass":{"id":"api-reference/core/resources/compute-pass","title":"ComputePass","description":"WebGPU only","sidebar":"defaultSidebar"},"api-reference/core/resources/compute-pipeline":{"id":"api-reference/core/resources/compute-pipeline","title":"ComputePipeline","description":"ComputePipeline is only available on WebGPU. Note on WebGL you can still perform","sidebar":"defaultSidebar"},"api-reference/core/resources/external-texture":{"id":"api-reference/core/resources/external-texture","title":"ExternalTexture","description":"WebGPU only."},"api-reference/core/resources/framebuffer":{"id":"api-reference/core/resources/framebuffer","title":"Framebuffer","description":"A Framebuffer holds textures that will be used as render targets for RenderPipelines","sidebar":"defaultSidebar"},"api-reference/core/resources/query-set":{"id":"api-reference/core/resources/query-set","title":"QuerySet","description":"This page is incomplete.","sidebar":"defaultSidebar"},"api-reference/core/resources/render-pass":{"id":"api-reference/core/resources/render-pass","title":"RenderPass","description":"Usage","sidebar":"defaultSidebar"},"api-reference/core/resources/render-pipeline":{"id":"api-reference/core/resources/render-pipeline","title":"RenderPipeline","description":"A RenderPipeline contains a matched pair of vertex and fragment shaders that can be exectued on the GPU by calling RenderPipeline.draw(). handle compilation and linking of shaders, and store uniform values. They provide draw call which allows the application to run the shaders on specified input data.","sidebar":"defaultSidebar"},"api-reference/core/resources/sampler":{"id":"api-reference/core/resources/sampler","title":"Sampler","description":"A Sampler is an immutable object that holds a set of sampling parameters for texture access.","sidebar":"defaultSidebar"},"api-reference/core/resources/shader":{"id":"api-reference/core/resources/shader","title":"Shader","description":"The Shader class holds a compiled shader.","sidebar":"defaultSidebar"},"api-reference/core/resources/texture":{"id":"api-reference/core/resources/texture","title":"Texture","description":"A Texture are GPU objects that contain one or more images that all have the same image format, that can be accessed from shaders.","sidebar":"defaultSidebar"},"api-reference/core/resources/texture-view":{"id":"api-reference/core/resources/texture-view","title":"TextureView","description":"A TextureView is a view onto some subset of the texture subresources defined by a particular Texture.","sidebar":"defaultSidebar"},"api-reference/core/resources/transform-feedback":{"id":"api-reference/core/resources/transform-feedback","title":"TransformFeedback","description":"WebGPU not supported","sidebar":"defaultSidebar"},"api-reference/core/resources/vertex-array":{"id":"api-reference/core/resources/vertex-array","title":"VertexArray","description":"A VertexArray stores a set of vertex attribute bindings, including the index buffer.","sidebar":"defaultSidebar"},"api-reference/core/shader-layout":{"id":"api-reference/core/shader-layout","title":"ShaderLayout","description":"A ShaderLayout object describes the static structure a `RenderPipeline, \\"location\\" and structure of binding points of shaders,","sidebar":"defaultSidebar"},"api-reference/core/shader-logs":{"id":"api-reference/core/shader-logs","title":"Shader Logs","description":"Shader compilation and linking logs contain important information about .","sidebar":"defaultSidebar"},"api-reference/core/texture-formats":{"id":"api-reference/core/texture-formats","title":"Texture Formats","description":"The term \\"texture format\\" here refers to how pixels are stored in memory, which is an important property of a GPU Texture","sidebar":"defaultSidebar"},"api-reference/core/uniform-buffer-layout":{"id":"api-reference/core/uniform-buffer-layout","title":"UniformBufferLayout","description":"A helper class that lets the application describe the contents of a uniform block and then perform setUniforms({uniform: value}) calls on it, manipulating individual values without concern for memory layout requirements."},"api-reference/core/uniform-store":{"id":"api-reference/core/uniform-store","title":"UniformStore","description":"A uniform store holds uniform values for a set of different uniform buffers,"},"api-reference/engine/animation-loop":{"id":"api-reference/engine/animation-loop","title":"AnimationLoop","description":"Manages an animation loop and optionally a WebGL context and a WebGL canvas. It provides a number of features related to initialization and animation of a WebGL context.","sidebar":"defaultSidebar"},"api-reference/engine/animation-loop-template":{"id":"api-reference/engine/animation-loop-template","title":"AnimationLoopTemplate","description":"AnimationLoopTemplate is a helper class that creates and manages the application\'s render loop.","sidebar":"defaultSidebar"},"api-reference/engine/animation/key-frames":{"id":"api-reference/engine/animation/key-frames","title":"KeyFrames","description":"Manages key frame animation data. Associates time points with arbitrary data and provides methods to access key times and data, and an interpolation factor, based on the current time.","sidebar":"defaultSidebar"},"api-reference/engine/animation/timeline":{"id":"api-reference/engine/animation/timeline","title":"Timeline","description":"Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods (play, pause) assume that the update method is being called once per frame with a \\"global time\\". This automatically done for AnimationLoop.timeline object.","sidebar":"defaultSidebar"},"api-reference/engine/async-texture":{"id":"api-reference/engine/async-texture","title":"AsyncTexture","description":"The AsyncTexture class accepts promises that resolve to texture data (images or byte arrays). It postpones the creation of actual Textures until the supplied promise(s) resolve and data is available.","sidebar":"defaultSidebar"},"api-reference/engine/compute/buffer-transform":{"id":"api-reference/engine/compute/buffer-transform","title":"BufferTransform","description":"WebGPU not supported","sidebar":"defaultSidebar"},"api-reference/engine/compute/computation":{"id":"api-reference/engine/compute/computation","title":"Computation","description":"The Computation class is a high-level class in the luma.gl API. It brings together all GPU functionality needed to run GPU compute shaders, in a single, easy-to-use interface.","sidebar":"defaultSidebar"},"api-reference/engine/compute/swap":{"id":"api-reference/engine/compute/swap","title":"Swap","description":"Swap is a helper class to support buffer and texture management when doing repeated transformations or computations on a block of data (memory). Swap enables a sequence of repeated / successive data transformations to be run by reusing just two resources (two buffers or two textures), effectively supporting a simple double buffering techniques.","sidebar":"defaultSidebar"},"api-reference/engine/compute/texture-transform":{"id":"api-reference/engine/compute/texture-transform","title":"TextureTransform","description":"TextureTransform is responsible for managing resources and state required for reading from and/or writing to Texture objects. It auto creates Texture objects when requested, creates Framebuffer objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.","sidebar":"defaultSidebar"},"api-reference/engine/compute/transform-needs-update":{"id":"api-reference/engine/compute/transform-needs-update","title":"Transform","description":"This page needs update for luma.gl v9"},"api-reference/engine/geometry/geometries":{"id":"api-reference/engine/geometry/geometries","title":"Built-in Geometries","description":"@luma.gl/engine provides several built in geometry primitives (subclasses of Geometry). The generated geometry instances will have indices and POSITION, NORMAL and TEXCOORD_0 attributes.","sidebar":"defaultSidebar"},"api-reference/engine/geometry/geometry":{"id":"api-reference/engine/geometry/geometry","title":"Geometry","description":"The Geometry class holds a collection of vertex array attributes representing a geometric primitive.","sidebar":"defaultSidebar"},"api-reference/engine/gpgpu/gpu-point-in-polygon":{"id":"api-reference/engine/gpgpu/gpu-point-in-polygon","title":"GPUPointInPolygon","description":"GPUPointInPolygon provides GPU accelerated PIP (Point-In-Polygon) testing functionality. A given set of 2D points and one or more 2D polygons, it computes, whether each point is inside or outside of any polygon.","sidebar":"defaultSidebar"},"api-reference/engine/gpgpu/histopyramid":{"id":"api-reference/engine/gpgpu/histopyramid","title":"Histopyramid","description":"Histopyramid aka Histogram Pyramid provides an efficient way of converting sparse matrix (represented by a texture) into list of coordinates (points). Where each active cell in the matrix can contribute to 1 or more points. All operations of the algorithm can be executed in parallel hence are performed on the GPU.","sidebar":"defaultSidebar"},"api-reference/engine/load-image-bitmap":{"id":"api-reference/engine/load-image-bitmap","title":"loadImageBitmap","description":"A simple small utility to load images from URLs. The loaded ImageBitmaps can be used to create textures.","sidebar":"defaultSidebar"},"api-reference/engine/model":{"id":"api-reference/engine/model","title":"Model","description":"The Model class is the centerpiece of the luma.gl API. It brings together all GPU functionality needed to run shaders and perform draw calls, in a single, easy-to-use interface.","sidebar":"defaultSidebar"},"api-reference/engine/passes/shader-pass-renderer":{"id":"api-reference/engine/passes/shader-pass-renderer","title":"ShaderPassRenderer","description":"A ShaderPassRenderer takes an source texture and applies a sequence of ShaderPasses and returns an output texture that can be rendered to the screen.","sidebar":"defaultSidebar"},"api-reference/engine/pipeline-factory":{"id":"api-reference/engine/pipeline-factory","title":"PipelineFactory","description":"The PipelineFactory class provides a createRenderPipeline() method that caches and reuses render pipelines.","sidebar":"defaultSidebar"},"api-reference/engine/README":{"id":"api-reference/engine/README","title":"Overview","description":"The @luma.gl/engine module contains a set of basic 3D framework classes intended"},"api-reference/engine/scenegraph/group-node":{"id":"api-reference/engine/scenegraph/group-node","title":"GroupNode","description":"A GroupNode is a subclass of ScenegraphNode that holds a list of ScenegraphNode children. Since . A GroupNode can be a child of another GroupNode and thus be used to create hierarchical scene graphs.","sidebar":"defaultSidebar"},"api-reference/engine/scenegraph/model-node":{"id":"api-reference/engine/scenegraph/model-node","title":"ModelNode","description":"ModelNode is simply a ScenegraphNode that contains a Model for drawing.","sidebar":"defaultSidebar"},"api-reference/engine/scenegraph/scenegraph-node":{"id":"api-reference/engine/scenegraph/scenegraph-node","title":"ScenegraphNode","description":"The ScenegraphNode is a base class for objects in the luma.gl scene graph, such as Model, Group and Camera. It holds the transformation matrix (i.e. the position, orientation and scale) of the object.","sidebar":"defaultSidebar"},"api-reference/engine/shader-factory":{"id":"api-reference/engine/shader-factory","title":"ShaderFactory","description":"The ShaderFactory class provides a createShader() method that caches and reuses Shader resources.","sidebar":"defaultSidebar"},"api-reference/engine/shader-inputs":{"id":"api-reference/engine/shader-inputs","title":"ShaderInputs","description":"ShaderInputs holds uniform and binding values for one or more shader modules,","sidebar":"defaultSidebar"},"api-reference/gltf/README":{"id":"api-reference/gltf/README","title":"Overview","description":"Classes and functions in @luma.gl/gltf","sidebar":"defaultSidebar"},"api-reference/README":{"id":"api-reference/README","title":"Overview","description":"luma.gl is packaged and published as a suite of composable npm modules, so that applications can choose what functionality they need.","sidebar":"defaultSidebar"},"api-reference/shadertools/README":{"id":"api-reference/shadertools/README","title":"Overview","description":"@luma.gl/shadertools provides:","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-assembler":{"id":"api-reference/shadertools/shader-assembler","title":"ShaderAssembler","description":"The functionality of the shadertools module shader system is primarily exposed","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-conventions":{"id":"api-reference/shadertools/shader-conventions","title":"Shader Modules","description":"This describes informal conventions that luma.gl applies to its shaders."},"api-reference/shadertools/shader-info":{"id":"api-reference/shadertools/shader-info","title":"Shader Parsing","description":"It is sometimes useful to be able to inspect shader source code","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-module":{"id":"api-reference/shadertools/shader-module","title":"ShaderModule","description":"In luma.gl, reusable shader modules are defined by objects that conform to the ShaderModule type.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/fp32":{"id":"api-reference/shadertools/shader-modules/fp32","title":"fp32 (32-bit Floating Point)","description":"Provides \\"improved\\" 32-bit math support to GPU shaders on certain platforms,","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/fp64":{"id":"api-reference/shadertools/shader-modules/fp64","title":"fp64 (64-bit Floating Point)","description":"Provides basic 64-bit math support in GPU shaders:","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/gouraud-material":{"id":"api-reference/shadertools/shader-modules/gouraud-material","title":"gouraudMaterial","description":"The goraudMaterial shader module provides functions to apply gouraud shading (per vertex) to your geometry.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/gpu-picking":{"id":"api-reference/shadertools/shader-modules/gpu-picking","title":"gpuPicking","description":"Provides support for GPU-based picking."},"api-reference/shadertools/shader-modules/lights":{"id":"api-reference/shadertools/shader-modules/lights","title":"lights","description":"The lights` shader module collects uniforms describing the lights in a scene."},"api-reference/shadertools/shader-modules/pbr-material":{"id":"api-reference/shadertools/shader-modules/pbr-material","title":"pbrMaterial","description":"Implements Physically Based Shading of a microfacet surface defined by a glTF material.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/phong-material":{"id":"api-reference/shadertools/shader-modules/phong-material","title":"phongMaterial","description":"This phongMaterial shader module provides functions to apply phong shading (per fragment) to your geometry.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/picking":{"id":"api-reference/shadertools/shader-modules/picking","title":"picking","description":"The picking shader module in @luma.gl/shadertools is deprecated. Use the picking modules in @luma.gl/engine instead.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-modules/project":{"id":"api-reference/shadertools/shader-modules/project","title":"project","description":"A basic projection module.","sidebar":"defaultSidebar"},"api-reference/shadertools/shader-passes/image-processing":{"id":"api-reference/shadertools/shader-passes/image-processing","title":"Image Processing","description":"Screen space effects packaged as reusable shader modules in @luma.gl/shadertools based on the glfx library.","sidebar":"defaultSidebar"},"api-reference/test-utils/README":{"id":"api-reference/test-utils/README","title":"Overview","description":"@luma.gl/test-utils contains support for testing luma.gl programs.","sidebar":"defaultSidebar"},"api-reference/test-utils/snapshot-test-runner":{"id":"api-reference/test-utils/snapshot-test-runner","title":"SnapshotTestRunner","description":"Client-side utility for browser-based WebGL render tests.","sidebar":"defaultSidebar"},"api-reference/webgl/README":{"id":"api-reference/webgl/README","title":"@luma.gl/webgl","description":"WebGL Device Adapter","sidebar":"defaultSidebar"},"api-reference/webgpu/README":{"id":"api-reference/webgpu/README","title":"Overview","description":"WebGPU Device Adapter","sidebar":"defaultSidebar"},"developer-guide/bundling":{"id":"developer-guide/bundling","title":"Bundling","description":"Optimizing for Bundle Size","sidebar":"defaultSidebar"},"developer-guide/contributing":{"id":"developer-guide/contributing","title":"Contributing","description":"luma.gl welcomes contributions from the community. Smaller fixes","sidebar":"defaultSidebar"},"developer-guide/debugging":{"id":"developer-guide/debugging","title":"Debugging","description":"Why GPU Debugging can be hard","sidebar":"defaultSidebar"},"developer-guide/editing":{"id":"developer-guide/editing","title":"Editing","description":"Shader Syntax Highlighting"},"developer-guide/installing":{"id":"developer-guide/installing","title":"Installing","description":"luma.gl is published as a suite of npm modules. Each module responsible for a particular part of the rendering stack.","sidebar":"defaultSidebar"},"developer-guide/profiling":{"id":"developer-guide/profiling","title":"Profiling","description":"GPU programming is all about performance, so having tools to systematically","sidebar":"defaultSidebar"},"developer-guide/README":{"id":"developer-guide/README","title":"Developer Guide","description":"This developer guide focuses on the practicalities of developing with the luma.gl API,","sidebar":"defaultSidebar"},"developer-guide/testing":{"id":"developer-guide/testing","title":"Testing","description":"Testing webgl programs can be tricky...","sidebar":"defaultSidebar"},"faq":{"id":"faq","title":"FAQ","description":"How do I draw to the screen in luma.gl?"},"getting-started":{"id":"getting-started","title":"Getting Started","description":""},"legacy/legacy-upgrade-guide":{"id":"legacy/legacy-upgrade-guide","title":"Legacy Upgrade Guide","description":"This page contains upgrade guides for older luma.gl releases (up through v8.5). For upgrading to luma.gl v9, refer to the main Upgrade Guide.","sidebar":"defaultSidebar"},"legacy/legacy-whats-new":{"id":"legacy/legacy-whats-new","title":"Legacy What\'s New","description":"This page contains release notes for older luma.gl releases (up through v8.5). For luma.gl v9, refer to the main Whats\' New page.","sidebar":"defaultSidebar"},"legacy/porting-guide":{"id":"legacy/porting-guide","title":"Porting Guide","description":"Given that the changes in the v9 API are quite extensive, this separate porting guide is provided to hopefully help plan the upgrade process.","sidebar":"defaultSidebar"},"README":{"id":"README","title":"Overview","description":"luma.gl is a modern GPU toolkit for the Web, focused on processing and visualization of big data.","sidebar":"defaultSidebar"},"tutorials/hello-cube":{"id":"tutorials/hello-cube","title":"Hello Cube","description":"The tutorial pages have not yet been updated for luma.gl v9.","sidebar":"defaultSidebar"},"tutorials/hello-instancing":{"id":"tutorials/hello-instancing","title":"Hello Instancing","description":"In this tutorial, we\'ll work through how to do instanced drawing with luma.gl\'s high-level APIs. We\'ll also take this opportunity to introduce luma.gl shader modules. We\'ll begin with our hello triangle app and make some modifications. First let\'s create a shader module:","sidebar":"defaultSidebar"},"tutorials/hello-triangle":{"id":"tutorials/hello-triangle","title":"Hello Triangle","description":"This tutorial will demonstrate how to draw a triangle using luma.gl\'s high-level APIs.","sidebar":"defaultSidebar"},"tutorials/lighting":{"id":"tutorials/lighting","title":"Lighting","description":"This tutorial adds some lighting to enhance the feeling of 3D in the scene.","sidebar":"defaultSidebar"},"tutorials/README":{"id":"tutorials/README","title":"Setup","description":"The tutorial pages have not yet been updated for luma.gl v9.","sidebar":"defaultSidebar"},"tutorials/shader-hooks":{"id":"tutorials/shader-hooks","title":"Shader Hooks","description":"The tutorial pages have not yet been updated for luma.gl v9.","sidebar":"defaultSidebar"},"tutorials/shader-modules":{"id":"tutorials/shader-modules","title":"Shader Modules","description":"This tutorial will demonstrate how to use luma.gl shader modules to make","sidebar":"defaultSidebar"},"tutorials/transform":{"id":"tutorials/transform","title":"Transform","description":"In this tutorial, we\'ll learn how to use transform feedback"},"tutorials/transform-feedback":{"id":"tutorials/transform-feedback","title":"Transform Feedback","description":"In this tutorial, we\'ll learn how to use transform feedback using luma.gl\'s high-level API. Transform feedback allows us to capture vertex shader results from one pass and use them in subsequent passes. It is a powerful tool that can be used to set up massively parrallelized animations or data transformations. Note that transform feedback can only be used with WebGL 2.","sidebar":"defaultSidebar"},"tutorials/whats-next":{"id":"tutorials/whats-next","title":"What\'s Next?","description":"The tutorial pages have not yet been updated for luma.gl v9.","sidebar":"defaultSidebar"},"upgrade-guide":{"id":"upgrade-guide","title":"Upgrade Guide","description":"The upgrade guide lists breaking changes in each major and minor version of the luma.gl API, and provides information on how to update applications.","sidebar":"defaultSidebar"},"whats-new":{"id":"whats-new","title":"What\'s New","description":"This page contains news for recent luma.gl releases. For older releases (through v8.5) refer to the  Legacy What\'s New page.","sidebar":"defaultSidebar"}}}}')}}]);