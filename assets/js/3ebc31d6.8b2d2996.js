"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[6272],{844:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>d,toc:()=>a});var n=t(4848),s=t(8453);const o={},i="TextureTransform",d={id:"api-reference/engine/compute/texture-transform",title:"TextureTransform",description:"TextureTransform is responsible for managing resources and state required for reading from and/or writing to Texture objects. It auto creates Texture objects when requested, creates Framebuffer objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds.",source:"@site/../docs/api-reference/engine/compute/texture-transform.md",sourceDirName:"api-reference/engine/compute",slug:"/api-reference/engine/compute/texture-transform",permalink:"/docs/api-reference/engine/compute/texture-transform",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/engine/compute/texture-transform.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"BufferTransform",permalink:"/docs/api-reference/engine/compute/buffer-transform"},next:{title:"GPUPointInPolygon",permalink:"/docs/api-reference/engine/gpgpu/gpu-point-in-polygon"}},c={},a=[{value:"Types",id:"types",level:2},{value:"<code>TextureTransformProps</code>",id:"texturetransformprops",level:3},{value:"<code>TextureBinding</code>",id:"texturebinding",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>constructor</code>",id:"constructor",level:3},{value:"getDrawOptions(opts: Object) : Object",id:"getdrawoptionsopts-object--object",level:3},{value:"updateModelProps(props: Object) : Object",id:"updatemodelpropsprops-object--object",level:3},{value:"run(props: Object)",id:"runprops-object",level:3},{value:"getTargetTexture() : Texture",id:"gettargettexture--texture",level:3},{value:"getData([options : Object]) : ArrayBufferView",id:"getdataoptions--object--arraybufferview",level:3},{value:"getFramebuffer() : Framebuffer",id:"getframebuffer--framebuffer",level:3}];function u(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"texturetransform",children:"TextureTransform"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"TextureTransform"})," is responsible for managing resources and state required for reading from and/or writing to ",(0,n.jsx)(r.code,{children:"Texture"})," objects. It auto creates ",(0,n.jsx)(r.code,{children:"Texture"})," objects when requested, creates ",(0,n.jsx)(r.code,{children:"Framebuffer"})," objects. Maintains all texture bindings, when swapping is eanbled, two binding objects are created for easy switching of all WebGL resource binginds."]}),"\n",(0,n.jsxs)(r.p,{children:["NOTE: In following sections 'texture transform' is used to refer to 'reading from and/or writing to ",(0,n.jsx)(r.code,{children:"Texture"})," objects'."]}),"\n",(0,n.jsx)(r.h2,{id:"types",children:"Types"}),"\n",(0,n.jsx)(r.h3,{id:"texturetransformprops",children:(0,n.jsx)(r.code,{children:"TextureTransformProps"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"export type TextureTransformProps = Omit<ModelProps, 'fs'> & {\n  fs?: ModelProps['fs']; // override as optional\n  targetTexture: Texture;\n  targetTextureChannels: 1 | 2 | 3 | 4;\n  targetTextureVarying: string;\n\n  /** @deprecated TODO(donmccurdy): Needed? */\n  inject?: Record<string, string>;\n  /** @deprecated TODO(donmccurdy): Needed? */\n  framebuffer?: Framebuffer;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceBuffers?: Record<string, Buffer>;\n  /** @deprecated TODO(donmccurdy): Model already handles this? */\n  sourceTextures?: Record<string, Texture>;\n};\n"})}),"\n",(0,n.jsx)(r.h3,{id:"texturebinding",children:(0,n.jsx)(r.code,{children:"TextureBinding"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"type TextureBinding = {\n  sourceBuffers: Record<string, Buffer>;\n  sourceTextures: Record<string, Texture>;\n  targetTexture: Texture;\n  framebuffer?: Framebuffer;\n};\n"})}),"\n",(0,n.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(r.h3,{id:"constructor",children:(0,n.jsx)(r.code,{children:"constructor"})}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"new TextureTransform(device: Device, props: TextureTransformProps)"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"device"})," - Device"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props.sourceTextures"})," (",(0,n.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,n.jsx)(r.code,{children:"Texture"})," object."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props.targetTexture"})," (",(0,n.jsx)(r.code,{children:"Texture"}),"|",(0,n.jsx)(r.code,{children:"String"}),", Optional) - ",(0,n.jsx)(r.code,{children:"props.Texture"})," object to which data to be written. When it is a ",(0,n.jsx)(r.code,{children:"String"}),", it must be one of the source texture attributes name, a new texture object is cloned from it."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props.targetTextureVarying"})," : varying name used in vertex shader who's data should go into target texture."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props.swapTexture"})," : source texture attribute name, that is swapped with target texture every time ",(0,n.jsx)(r.code,{children:"swap()"})," is called."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props.fs"}),"  - fragment shader string, when rendering to a texture, fragments can be processed using this custom shader, when not specified, pass through fragment shader will be used."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"getdrawoptionsopts-object--object",children:"getDrawOptions(opts: Object) : Object"}),"\n",(0,n.jsxs)(r.p,{children:["Returns options required when performing ",(0,n.jsx)(r.code,{children:"Model.draw()"})," options."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"opts"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - Any existing ",(0,n.jsx)(r.code,{children:"opts.attributes"})," , ",(0,n.jsx)(r.code,{children:"opts.parameters"}),", and ",(0,n.jsx)(r.code,{children:"opts.uniforms"})," will be merged with new values."]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Returns an Object : attributes, framebuffer, uniforms, discard, parameters"}),"\n",(0,n.jsx)(r.h3,{id:"updatemodelpropsprops-object--object",children:"updateModelProps(props: Object) : Object"}),"\n",(0,n.jsxs)(r.p,{children:["Updates input ",(0,n.jsx)(r.code,{children:"props"})," object used to build ",(0,n.jsx)(r.code,{children:"Model"})," object, with data required for texture transform."]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - props for building ",(0,n.jsx)(r.code,{children:"Model"})," object, it will updated with required options (",(0,n.jsx)(r.code,{children:"{vs, fs, modules, uniforms, inject}"}),") for texture transform."]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Returns updated object."}),"\n",(0,n.jsx)(r.h3,{id:"runprops-object",children:"run(props: Object)"}),"\n",(0,n.jsx)(r.p,{children:"Updates bindings for source and target texture."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"})," (",(0,n.jsx)(r.code,{children:"Object"}),") - contains following data.","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"sourceTextures"})," (",(0,n.jsx)(r.code,{children:"Object"}),", Optional) - key and value pairs, where key is the name of vertex shader attribute and value is the corresponding ",(0,n.jsx)(r.code,{children:"Texture"})," object."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"targetTexture"})," (",(0,n.jsx)(r.code,{children:"Texture"}),"|",(0,n.jsx)(r.code,{children:"String"}),", Optional) - ",(0,n.jsx)(r.code,{children:"Texture"})," object to which data to be written. When it is a ",(0,n.jsx)(r.code,{children:"String"}),", it must be one of the source texture attributes name, a new texture object is cloned from it."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"gettargettexture--texture",children:"getTargetTexture() : Texture"}),"\n",(0,n.jsx)(r.p,{children:"Returns current target texture object."}),"\n",(0,n.jsx)(r.h3,{id:"getdataoptions--object--arraybufferview",children:"getData([options : Object]) : ArrayBufferView"}),"\n",(0,n.jsx)(r.p,{children:"Reads and returns data from current target texture."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"options.packed"})," (Boolean, Optional, Default: false) - When true, data is packed to the actual size varyings. When false return array contains 4 values (R, G, B and A) for each element. Un-used element value will be 0 for R, G and B and 1 for A channel."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"getframebuffer--framebuffer",children:"getFramebuffer() : Framebuffer"}),"\n",(0,n.jsxs)(r.p,{children:["Returns current ",(0,n.jsx)(r.code,{children:"Framebuffer"})," object."]})]})}function l(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>d});var n=t(6540);const s={},o=n.createContext(s);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);