"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[5702],{1943:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-guide/engine/transforms","title":"GPU Computations and Transforms","description":"Some operations can be very efficiently executed on the GPU.","source":"@site/../docs/api-guide/engine/transforms.md","sourceDirName":"api-guide/engine","slug":"/api-guide/engine/transforms","permalink":"/docs/api-guide/engine/transforms","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-guide/engine/transforms.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Scenegraphs","permalink":"/docs/api-guide/engine/scenegraph"},"next":{"title":"Overview","permalink":"/docs/api-reference/"}}');var a=r(4848),t=r(8453);const i={},o="GPU Computations and Transforms",d={},c=[{value:"General GPU compute guidelines",id:"general-gpu-compute-guidelines",level:3},{value:"Compute Shaders",id:"compute-shaders",level:3},{value:"Buffer Transforms (aka Transform Feedback)",id:"buffer-transforms-aka-transform-feedback",level:3},{value:"Texture Transforms",id:"texture-transforms",level:3},{value:"Usage",id:"usage",level:2},{value:"Use case : Specify source and destination buffers.",id:"use-case--specify-source-and-destination-buffers",level:3},{value:"Use case : Create destination buffers automatically.",id:"use-case--create-destination-buffers-automatically",level:3},{value:"Use case : Multiple iterations using swap().",id:"use-case--multiple-iterations-using-swap",level:3},{value:"Use case : Update one or more buffers using update() method..",id:"use-case--update-one-or-more-buffers-using-update-method",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"gpu-computations-and-transforms",children:"GPU Computations and Transforms"})}),"\n",(0,a.jsx)(n.p,{children:"Some operations can be very efficiently executed on the GPU."}),"\n",(0,a.jsx)(n.p,{children:'WebGPU offers extensive GPU compute capabilities via compute shaders, while WebGL is limited to using a technique called "transform feedback".'}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"WebGPU"}),(0,a.jsx)(n.th,{children:"WebGL"}),(0,a.jsx)(n.th,{children:"Comment"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Compute Shader"}),(0,a.jsx)(n.td,{children:"\u2705"}),(0,a.jsx)(n.td,{children:"\u274c"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Buffer Transform"}),(0,a.jsx)(n.td,{children:"\u274c"}),(0,a.jsx)(n.td,{children:"\u2705"}),(0,a.jsxs)(n.td,{children:["Depends on ",(0,a.jsx)(n.code,{children:"TransformFeedback"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Texture Transform"}),(0,a.jsx)(n.td,{children:"\u2705"}),(0,a.jsx)(n.td,{children:"\ud83d\udea7"}),(0,a.jsx)(n.td,{})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"general-gpu-compute-guidelines",children:"General GPU compute guidelines"}),"\n",(0,a.jsx)(n.p,{children:"Buffers can be read back to the CPU, but this has a high performance penalty.\nIdeally, the application's logic can be designed so that CPU access is not required which avoids expensive CPU and GPU sync."}),"\n",(0,a.jsx)(n.h3,{id:"compute-shaders",children:"Compute Shaders"}),"\n",(0,a.jsx)(n.h3,{id:"buffer-transforms-aka-transform-feedback",children:"Buffer Transforms (aka Transform Feedback)"}),"\n",(0,a.jsx)(n.p,{children:"Transform operations represent a GPGPU/GPU compute technique where standard GPU draw calls are configured\nso that they also write some specific outputs from the vertex shaders to (one or more) GPU memory buffers\nthat have been provided by the application."}),"\n",(0,a.jsxs)(n.p,{children:["Transform Feedback operations write their output into ",(0,a.jsx)(n.code,{children:"Buffer"})," instances.\nThese buffers can then be directly set as attributes on ",(0,a.jsx)(n.code,{children:"Model"})," or ",(0,a.jsx)(n.code,{children:"VertexArray"})," for regular rendering operations."]}),"\n",(0,a.jsx)(n.p,{children:"To run a single transform feedback operation:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Create a ",(0,a.jsx)(n.code,{children:"Program"})," or a ",(0,a.jsx)(n.code,{children:"Model"})," with varyings (",(0,a.jsx)(n.code,{children:"out"})," variables) declared in the vertex shader's GLSL code, and provide the names of these varyings to the ",(0,a.jsx)(n.code,{children:"Program"})," constructor."]}),"\n",(0,a.jsxs)(n.li,{children:["Use ",(0,a.jsx)(n.code,{children:"Program.draw()"})," or ",(0,a.jsx)(n.code,{children:"Model.draw()"})," with a ",(0,a.jsx)(n.code,{children:"transformFeedback"})," parameter."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Model.transform()"})," is equivalent to ",(0,a.jsx)(n.code,{children:"Model.draw()"})," but automatically turns off the fragment shader stage."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"BufferTransform"})," class is preferable to avoid having to deal with low-level WebGL specific ",(0,a.jsx)(n.code,{children:"TransformFeedback"})," objects."]}),"\n",(0,a.jsx)(n.h3,{id:"texture-transforms",children:"Texture Transforms"}),"\n",(0,a.jsxs)(n.p,{children:["Another approach for random access compute is Texture Transforms.\nThis approach stores input data in textures and writing to textures, and does not depend on the presence of the WebGL specific ",(0,a.jsx)(n.code,{children:"TransformFeedback"})," class."]}),"\n",(0,a.jsx)(n.p,{children:"It has some characteristics in common with storage buffers in compute shaders but is less flexible."}),"\n",(0,a.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import {BufferTransform} from '@luma.gl/engine';\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-case--specify-source-and-destination-buffers",children:"Use case : Specify source and destination buffers."}),"\n",(0,a.jsxs)(n.p,{children:["Create a ",(0,a.jsx)(n.code,{children:"BufferTransform"})," object by passing, vs (vertex shader), source buffer(s), varyings (output variable names in vertex shader) and destination buffers. Then call ",(0,a.jsx)(n.code,{children:"run"})," to perform one transform feedback iteration."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const VS = `\\\n#version 300 es\nattribute float inValue;\nvarying float outValue;\n\nvoid main()\n{\n  outValue = 2.0 * inValue;\n}\n`;\n\nconst sourceData = new Float32Array([10, 20, 31, 0, -57]);\nconst sourceBuffer = device.createBuffer({data: sourceData});\n\n// Default values applied for size (1) and type (gl.FLOAT)\nconst feedbackBuffer = device.createBuffer({byteLength: sourceData.length * 4});\n\nconst transform = new BufferTransform(device, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackBuffers: {\n    outValue: feedbackBuffer\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n\n// Perform one transform feedback iteration\ntransform.run();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-case--create-destination-buffers-automatically",children:"Use case : Create destination buffers automatically."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"BufferTransform"})," can internally create destination buffers (i.e. feedback buffers), when ",(0,a.jsx)(n.code,{children:"feedbackMap"})," is provided. Each destination buffer is created with same settings and layout as corresponding source buffer as per ",(0,a.jsx)(n.code,{children:"feedbackMap"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const transform = new BufferTransform(device, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackMap: {\n    inValue: 'outValue'\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-case--multiple-iterations-using-swap",children:"Use case : Multiple iterations using swap()."}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.code,{children:"feedbackMap"})," is specified buffers can be swapped using a single call to ",(0,a.jsx)(n.code,{children:"swap()"}),", this is useful for cases like particle simulation, where output of one transform feedback iteration is piped as input to the next iteration."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Setup BufferTransform with `souceDestinationMap` as above\n\ntransform.run();\n\nlet bufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n\n//swap buffers\ntransform.swap();\ntransform.run();\nbufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n"})}),"\n",(0,a.jsx)(n.h3,{id:"use-case--update-one-or-more-buffers-using-update-method",children:"Use case : Update one or more buffers using update() method.."}),"\n",(0,a.jsxs)(n.p,{children:["Once ",(0,a.jsx)(n.code,{children:"BufferTransform"})," object is constructed and used, one or more source or destination buffers can be updated using ",(0,a.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// transform is set up as above\n...\n\n// update buffer binding for 'inValue' attribute\nconst newSourceBuffer = new Buffer(gl, {data: newSourceData});\ntransform.update({\n  sourceBuffers: {\n    inValue: newSourceBuffer\n  }\n});\n\n// now data is provided from newly bound buffer.\ntransform.run();\n"})})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(6540);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);