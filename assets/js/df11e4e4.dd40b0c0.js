"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[9707],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},9386:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api-guide/engine/interactivity","title":"Interactivity","description":"Event Management","source":"@site/../docs/api-guide/engine/interactivity.md","sourceDirName":"api-guide/engine","slug":"/api-guide/engine/interactivity","permalink":"/docs/api-guide/engine/interactivity","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-guide/engine/interactivity.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Shader Inputs","permalink":"/docs/api-guide/engine/shader-inputs"},"next":{"title":"Scenegraphs","permalink":"/docs/api-guide/engine/scenegraph"}}');var a=i(4848),r=i(8453);const s={},c="Interactivity",o={},d=[{value:"Event Management",id:"event-management",level:2},{value:"Picking and Highlighting",id:"picking-and-highlighting",level:2},{value:"About GPU picking",id:"about-gpu-picking",level:3},{value:"About CPU picking",id:"about-cpu-picking",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"interactivity",children:"Interactivity"})}),"\n",(0,a.jsx)(n.h2,{id:"event-management",children:"Event Management"}),"\n",(0,a.jsxs)(n.p,{children:["luma.gl does not include any APIs for capturing events generated by user interaction (mouse clicks, pointer moves, key presses etc).\nThe browser offers APIs for this, and another option is to a library or framework for event management. One option is use to use luma.gl's companion ",(0,a.jsx)(n.a,{href:"https://uber-web.github.io/mjolnir.js/",children:"mjolnir.js"}),' framework, which additionally includes portable support for "gestures" on mobile phones.']}),"\n",(0,a.jsx)(n.h2,{id:"picking-and-highlighting",children:"Picking and Highlighting"}),"\n",(0,a.jsx)(n.p,{children:"Allowing he user to picking object from the screen is a key capability for most interactive applications.\nIt is also often desirable to be able to highlight specific objects."}),"\n",(0,a.jsx)(n.h3,{id:"about-gpu-picking",children:"About GPU picking"}),"\n",(0,a.jsx)(n.p,{children:"GPU based picking has a couple of significant advantage over CPU-based picking:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"GPU-based picking is a picking technique that can be performed entirely on the GPU, meaning that it is very performant, especially when picking is done every frame."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"can be added to any existing shaders"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"and is independent of the structure of the input geometry or rendering without requiring any additional picking logic to that shader, beyond calling one function in the vertex shader and one function in the fragment shader."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Note that GPU-based picking does comes with some limitations:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Picking occluding objects require re-rendering and discarding the already picked objects."}),"\n",(0,a.jsx)(n.li,{children:"On WebGL-specific: the read back of the picking data from the picking texture can only be done synchronously, causing a GPU pipeline stall, which can defeat some of the performance advantages."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"about-cpu-picking",children:"About CPU picking"}),"\n",(0,a.jsxs)(n.p,{children:["Traditional 3d frameworks often support CPU-based picking, perhaps using a JavaScript ",(0,a.jsx)(n.code,{children:"Ray"})," class that can be intersected with a standard JavaScript-format geometry."]}),"\n",(0,a.jsx)(n.p,{children:"CPU based picking techniques do have advantages:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"They can often provide precise intersection points on objects and they are better at handling picking of multiple objects, especially for objects that are occluded."}),"\n",(0,a.jsx)(n.li,{children:"However, CPU based picking techniques are slower and can require more data on the CPU or they may need to be customized to the structure of the input data."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Note that while CPU based picking support could be added to luma.gl, luma does not currently include an CPU-based picking algorithms."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);