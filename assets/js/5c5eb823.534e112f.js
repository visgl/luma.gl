"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[986],{857:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>u,default:()=>f,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"api-reference/engine/compute/transform-needs-update","title":"Transform","description":"This page needs update for luma.gl v9","source":"@site/../docs/api-reference/engine/compute/transform-needs-update.md","sourceDirName":"api-reference/engine/compute","slug":"/api-reference/engine/compute/transform-needs-update","permalink":"/docs/api-reference/engine/compute/transform-needs-update","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/engine/compute/transform-needs-update.md","tags":[],"version":"current","frontMatter":{}}');var s=r(4848),a=r(8453);const o={},u="Transform",i={},c=[{value:"Use case : Specify source and destination buffers.",id:"use-case--specify-source-and-destination-buffers",level:3},{value:"Use case : Create destination buffers automatically.",id:"use-case--create-destination-buffers-automatically",level:3},{value:"Use case : Multiple iterations using swap().",id:"use-case--multiple-iterations-using-swap",level:3},{value:"Use case : Update one or more buffers using update() method..",id:"use-case--update-one-or-more-buffers-using-update-method",level:3},{value:"Use case : Reading source data from texture object (Experimental)",id:"use-case--reading-source-data-from-texture-object-experimental",level:3},{value:"Use case : Generating a texture object (Experimental)",id:"use-case--generating-a-texture-object-experimental",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transform",children:"Transform"})}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsx)(n.p,{children:"This page needs update for luma.gl v9"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Transform"})," class provides easy interface to perform Transform Feedback operations on given data. Applications can use this class to move data processing from CPU to GPU, where multiple parallel execution units will be used for processing. Data is handled in form of ",(0,s.jsx)(n.code,{children:"Buffer"})," objects, i.e. data resides in the GPU memory. Output of this class can directly set as attributes on ",(0,s.jsx)(n.code,{children:"Model"})," or ",(0,s.jsx)(n.code,{children:"VertexArray"})," for regular rendering operations, CPU access is not required hence avoids expensive CPU and GPU sync."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Transform"})," class creates and holds ",(0,s.jsx)(n.code,{children:"Model"})," and ",(0,s.jsx)(n.code,{children:"TransformFeedback"})," instances."]}),"\n",(0,s.jsx)(n.h3,{id:"use-case--specify-source-and-destination-buffers",children:"Use case : Specify source and destination buffers."}),"\n",(0,s.jsxs)(n.p,{children:["Create a ",(0,s.jsx)(n.code,{children:"Transform"})," object by passing, vs (vertex shader), source buffer(s), varyings (output variable names in vertex shader) and destination buffers. Then call ",(0,s.jsx)(n.code,{children:"run"})," to perform one transform feedback iteration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const VS = `\\\n#version 300 es\nattribute float inValue;\nvarying float outValue;\n\nvoid main()\n{\n  outValue = 2.0 * inValue;\n}\n`;\n\nconst sourceData = new Float32Array([10, 20, 31, 0, -57]);\nconst sourceBuffer = new Buffer(gl, {data: sourceData});\n\n// Default values applied for size (1) and type (gl.FLOAT)\nconst feedbackBuffer = new Buffer(gl, {byteLength: sourceData.length * 4});\n\nconst transform = new Transform(gl2, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackBuffers: {\n    outValue: feedbackBuffer\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n\n// Perform one transform feedback iteration\ntransform.run();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case--create-destination-buffers-automatically",children:"Use case : Create destination buffers automatically."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Transform"})," can internally create destination buffers (i.e. feedback buffers), when ",(0,s.jsx)(n.code,{children:"feedbackMap"})," is provided. Each destination buffer is created with same settings and layout as corresponding source buffer as per ",(0,s.jsx)(n.code,{children:"feedbackMap"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const transform = new Transform(gl2, {\n  sourceBuffers: {\n    inValue: sourceBuffer\n  },\n  feedbackMap: {\n    inValue: 'outValue'\n  },\n  vs: VS,\n  varyings: ['outValue'],\n  elementCount: 5\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case--multiple-iterations-using-swap",children:"Use case : Multiple iterations using swap()."}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"feedbackMap"})," is specified buffers can be swapped using a single call to ",(0,s.jsx)(n.code,{children:"swap()"}),", this is useful for cases like particle simulation, where output of one transform feedback iteration is piped as input to the next iteration."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Setup Transform with `feedbackMap` as above\n\ntransform.run();\n\nlet bufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n\n//swap buffers\ntransform.swap();\ntransform.run();\nbufferWithNewValues = transform.getBuffer('outValue');\n...\n// Render using 'bufferWithNewValues'\n...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case--update-one-or-more-buffers-using-update-method",children:"Use case : Update one or more buffers using update() method.."}),"\n",(0,s.jsxs)(n.p,{children:["Once ",(0,s.jsx)(n.code,{children:"Transform"})," object is constructed and used, one or more source or destination buffers can be updated using ",(0,s.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// transform is set up as above\n...\n\n// update buffer binding for 'inValue' attribute\nconst newSourceBuffer = new Buffer(gl, {data: newSourceData});\ntransform.update({\n  sourceBuffers: {\n    inValue: newSourceBuffer\n  }\n});\n\n// now data is provided from newly bound buffer.\ntransform.run();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case--reading-source-data-from-texture-object-experimental",children:"Use case : Reading source data from texture object (Experimental)"}),"\n",(0,s.jsx)(n.p,{children:"In addition to reading data from Buffer objects, Transform can read from texture objects. Transform allows to access texture data in the same way as buffer data and internally generates required texture co-ordinates and sample instructions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// simple shader that adds data from a buffer and texture to generate new buffer.\n\nconst vs = `\\\n#version 300 es\nin float inBuffer;\nin float inTexture;\nout float outBuffer;\n\nvoid main()\n{\n  outBuffer = inTexture + inBuffer;\n}`;\n\nconst sourceBuffer = new Buffer(...);\nconst sourceTexture = new Texture2D(...);\n\nconst transform = new Transform(gl2, {\n  sourceBuffers: {\n    inBuffer: sourceBuffer\n  },\n  // specify source texture object using input attribute name\n  _sourceTextures: {\n    inTexture: sourceTexture\n  },\n  vs,\n  feedbackMap: {\n    inBuffer: 'outBuffer'\n  },\n  elementCount\n});\n\ntransform.run();\n\n// resulting buffer contains sum of input buffer and texture data.\nconst outData = transform.getBuffer('outBuffer').getData();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case--generating-a-texture-object-experimental",children:"Use case : Generating a texture object (Experimental)"}),"\n",(0,s.jsx)(n.p,{children:"In addition to reading data from a texture object, Transform can generate texture object, by rendering data into it offline. Source data can be either buffer(s), texture(s) or any combination."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const vs = `\\\n#version 300 es\nin vec4 inTexture;\nout vec4 outTexture;\n\nvoid main()\n{\n  outTexture = 2. *  inTexture;\n}\n`\nconst sourceTexture = new Texture2D(...);\nconst transform = new Transform(gl2, {\n  _sourceTextures: {\n    inTexture: sourceTexture\n  },\n  _targetTexture: 'inTexture',\n  _targetTextureVarying: 'outTexture',\n  vs,\n  elementCount\n});\n\ntransform.run();\n\nconst outTexture = transform._getTargetTexture();\n"})})]})}function f(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>u});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);