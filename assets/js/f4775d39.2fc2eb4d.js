"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[7268],{2909:(e,r,d)=>{d.r(r),d.d(r,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});var n=d(4848),s=d(8453);const c={},t="Buffer",i={id:"api-reference/core/resources/buffer",title:"Buffer",description:"Holds a block of GPU memory. The length of a buffer cannot be changed after creation.",source:"@site/../docs/api-reference/core/resources/buffer.md",sourceDirName:"api-reference/core/resources",slug:"/api-reference/core/resources/buffer",permalink:"/docs/api-reference/core/resources/buffer",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/core/resources/buffer.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Texture Formats",permalink:"/docs/api-reference/core/texture-formats"},next:{title:"ComputePass",permalink:"/docs/api-reference/core/resources/compute-pass"}},l={},o=[{value:"Types",id:"types",level:2},{value:"<code>BufferProps</code>",id:"bufferprops",level:3},{value:"Usage",id:"usage",level:3},{value:"<code>BufferMapCallback</code>",id:"buffermapcallback",level:3},{value:"Members",id:"members",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>constructor(props: BufferProps)</code>",id:"constructorprops-bufferprops",level:3},{value:"<code>destroy(): void</code>",id:"destroy-void",level:3},{value:"<code>write(): void</code>",id:"write-void",level:3},{value:"<code>readAsync(): Promise&lt;ArrayBuffer&gt;</code>",id:"readasync-promisearraybuffer",level:3},{value:"<code>mapAndReadAsync(): Promise&lt;void&gt;</code>",id:"mapandreadasync-promisevoid",level:3},{value:"<code>readSyncWebGL(): ArrayBuffer</code>",id:"readsyncwebgl-arraybuffer",level:3}];function a(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"buffer",children:"Buffer"})}),"\n",(0,n.jsx)(r.p,{children:"Holds a block of GPU memory. The length of a buffer cannot be changed after creation."}),"\n",(0,n.jsx)(r.h2,{id:"types",children:"Types"}),"\n",(0,n.jsx)(r.h3,{id:"bufferprops",children:(0,n.jsx)(r.code,{children:"BufferProps"})}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Property"}),(0,n.jsx)(r.th,{children:"Type"}),(0,n.jsx)(r.th,{children:"Description"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"usage?"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"number"})}),(0,n.jsx)(r.td,{children:"Bit mask of Usage flags"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"byteLength?"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"number"})}),(0,n.jsx)(r.td,{children:"Length of buffer (cannot be changed after creation)."})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"data?"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"ArrayBuffer | ArrayBufferView"})}),(0,n.jsxs)(r.td,{children:["Data to be copied into buffer. ",(0,n.jsx)(r.code,{children:"byteLength"})," will be deduced if not supplied."]})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"byteOffset?"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"number"})}),(0,n.jsxs)(r.td,{children:["Offset for ",(0,n.jsx)(r.code,{children:"data"})]})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"indexType?"})}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"'uint16' | 'uint32'"})}),(0,n.jsx)(r.td,{children:"If props.usage & Buffer.INDEX"})]})]})]}),"\n",(0,n.jsx)(r.h3,{id:"usage",children:"Usage"}),"\n",(0,n.jsx)(r.p,{children:"Usage expresses two things: The type of buffer and what operations can be performed on it."}),"\n",(0,n.jsx)(r.p,{children:"Note that the allowed combinations are very limited, especially in WebGPU."}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Usage Flag"}),(0,n.jsx)(r.th,{children:"Value"}),(0,n.jsx)(r.th,{children:"Description"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.INDEX"})}),(0,n.jsx)(r.td,{children:"0x0010"}),(0,n.jsx)(r.td,{children:"An index buffer (array of 16 or 32 bit unsigned integers"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.VERTEX"})}),(0,n.jsx)(r.td,{children:"0x0020"}),(0,n.jsx)(r.td,{children:"A vertex buffer (a binary column)"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.UNIFORM"})}),(0,n.jsx)(r.td,{children:"0x0040"}),(0,n.jsx)(r.td,{children:"A uniform buffer"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.STORAGE"})}),(0,n.jsx)(r.td,{children:"0x0080"}),(0,n.jsx)(r.td,{children:"A storage buffer"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.INDIRECT"})}),(0,n.jsx)(r.td,{children:"0x0100"}),(0,n.jsx)(r.td,{})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.QUERY_RESOLVE"})}),(0,n.jsx)(r.td,{children:"0x0200"}),(0,n.jsx)(r.td,{})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.MAP_READ"})}),(0,n.jsx)(r.td,{children:"0x01"}),(0,n.jsx)(r.td,{children:"Whether the buffer can be mapped for read"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.MAP_WRITE"})}),(0,n.jsx)(r.td,{children:"0x02"}),(0,n.jsx)(r.td,{children:"Whether the buffer can be mapped for write"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.COPY_SRC"})}),(0,n.jsx)(r.td,{children:"0x0004"}),(0,n.jsxs)(r.td,{children:["Supports ",(0,n.jsx)(r.code,{children:"commandEncoder.copyBufferTo..."})]})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"Buffer.COPY_DST"})}),(0,n.jsx)(r.td,{children:"0x0008"}),(0,n.jsxs)(r.td,{children:["Supports ",(0,n.jsx)(r.code,{children:"commandEncoder.copy...ToBuffer"})]})]})]})]}),"\n",(0,n.jsx)(r.h3,{id:"buffermapcallback",children:(0,n.jsx)(r.code,{children:"BufferMapCallback"})}),"\n",(0,n.jsx)(r.p,{children:"Called when a GPU buffer data has been mapped to the CPU."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"type BufferMapCallback<T> = (arrayBuffer: ArrayBuffer, lifetime: 'mapped' | 'copied') => T;\n"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"arrayBuffer"})," an array buffer containing the data range of the buffer."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"lifetime"})," - indicates whether the ",(0,n.jsx)(r.code,{children:"arrayBuffer"})," parameter is only available in the callback (WebGPU) or whether it is permanent and can be used after the callback returns (WebGL2)."]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"members",children:"Members"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"device"}),": ",(0,n.jsx)(r.code,{children:"Device"})," - holds a reference to the ",(0,n.jsx)(r.code,{children:"Device"})," that created this ",(0,n.jsx)(r.code,{children:"Buffer"}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"handle"}),": ",(0,n.jsx)(r.code,{children:"unknown"})," - holds the underlying WebGL or WebGPU shader object"]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"props"}),": ",(0,n.jsx)(r.code,{children:"BufferProps"})," - holds a copy of the ",(0,n.jsx)(r.code,{children:"BufferProps"})," used to create this ",(0,n.jsx)(r.code,{children:"Buffer"}),"."]}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(r.h3,{id:"constructorprops-bufferprops",children:(0,n.jsx)(r.code,{children:"constructor(props: BufferProps)"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"Buffer"})," is an abstract class and cannot be instantiated directly. Create with ",(0,n.jsx)(r.code,{children:"device.createBuffer(...)"}),"."]}),"\n",(0,n.jsx)(r.h3,{id:"destroy-void",children:(0,n.jsx)(r.code,{children:"destroy(): void"})}),"\n",(0,n.jsx)(r.p,{children:"Free up any GPU resources associated with this buffer immediately (instead of waiting for garbage collection)."}),"\n",(0,n.jsx)(r.h3,{id:"write-void",children:(0,n.jsx)(r.code,{children:"write(): void"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"buffer.write(data: ArrayBufferLike | ArrayBufferView, byteOffset?: number): void;\n"})}),"\n",(0,n.jsx)(r.p,{children:"Writes data to the GPU buffer."}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"data"})," - binary data to be written to the GPU Buffer."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteOffset"})," - the first byte to read from the GPU buffer."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteLength"})," - the number of bytes to read from the GPU buffer"]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Remarks"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Data writes are asynchronous on the GPU but will be completed before any reads."}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"readasync-promisearraybuffer",children:(0,n.jsx)(r.code,{children:"readAsync(): Promise<ArrayBuffer>"})}),"\n",(0,n.jsx)(r.p,{children:"Reads the contents of a GPU Buffer into CPU memory."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"buffer.readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;\n"})}),"\n",(0,n.jsx)(r.p,{children:"Remarks:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["On WebGPU, this copies the mapped buffer data into a permanent array buffer. If you do not need a copy of the memory, considering using ",(0,n.jsx)(r.code,{children:"mapAndReadAsync"})," instead."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"mapandreadasync-promisevoid",children:(0,n.jsx)(r.code,{children:"mapAndReadAsync(): Promise<void>"})}),"\n",(0,n.jsx)(r.p,{children:"Maps buffer data to CPU memory. Mapped memory is only accessible in the callback."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-ts",children:"  buffer.mapAndReadAsync<T>(onData: BufferMapCallback<T>, byteOffset?: number, byteLength?: number): Promise<T>;\n"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"onData"})," - called when the GPU buffer data has been mapped onto the CPU."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteOffset"})," - the first byte to read from the GPU buffer."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteLength"})," - the number of bytes to read from the GPU buffer"]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Note:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"On WebGPU, if you do not plan to hold on to the ArrayBuffer read from the buffer, you can provide a callback that accesses the mapped buffer data before it is unmapped."}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"readsyncwebgl-arraybuffer",children:(0,n.jsx)(r.code,{children:"readSyncWebGL(): ArrayBuffer"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteOffset"})," - the first byte to read from the GPU buffer."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.code,{children:"byteLength"})," - the number of bytes to read from the GPU buffer"]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Synchronous reads, while convenient, have significant performance penalty as they force a GPU sync.\nSynchronous reads are not available on WebGPU."})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,r,d)=>{d.d(r,{R:()=>t,x:()=>i});var n=d(6540);const s={},c=n.createContext(s);function t(e){const r=n.useContext(c);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),n.createElement(c.Provider,{value:r},e.children)}}}]);