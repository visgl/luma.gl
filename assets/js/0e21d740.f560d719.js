/*! For license information please see 0e21d740.f560d719.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[8626],{8950:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>o});var t=i(4848),a=i(8453);const l={},r="Timeline",d={id:"api-reference/engine/animation/timeline",title:"Timeline",description:'Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods (play, pause) assume that the update method is being called once per frame with a "global time". This automatically done for AnimationLoop.timeline object.',source:"@site/../docs/api-reference/engine/animation/timeline.md",sourceDirName:"api-reference/engine/animation",slug:"/api-reference/engine/animation/timeline",permalink:"/docs/api-reference/engine/animation/timeline",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/engine/animation/timeline.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"KeyFrames",permalink:"/docs/api-reference/engine/animation/key-frames"},next:{title:"GroupNode",permalink:"/docs/api-reference/engine/scenegraph/group-node"}},s={},o=[{value:"Parallel Times",id:"parallel-times",level:2},{value:"Usage",id:"usage",level:2},{value:"Methods",id:"methods",level:2},{value:"addChannel([props: Object]) : number",id:"addchannelprops-object--number",level:3},{value:"removeChannel(handle : number)",id:"removechannelhandle--number",level:3},{value:"isFinished(handle : number) : Boolean",id:"isfinishedhandle--number--boolean",level:3},{value:"getTime([handle : number]) : number",id:"gettimehandle--number--number",level:3},{value:"setTime(time : number)",id:"settimetime--number",level:3},{value:"play",id:"play",level:3},{value:"pause",id:"pause",level:3},{value:"reset",id:"reset",level:3},{value:"attachAnimation(animation: Object, [channelHandle : number]) : number",id:"attachanimationanimation-object-channelhandle--number--number",level:3},{value:"detachAnimation(handle : number)",id:"detachanimationhandle--number",level:3},{value:"update(globalTime : number)",id:"updateglobaltime--number",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"timeline",children:"Timeline"}),"\n",(0,t.jsxs)(n.p,{children:["Manages an animation timeline, with multiple channels that can be running at different rates, durations, etc. Many methods (",(0,t.jsx)(n.code,{children:"play"}),", ",(0,t.jsx)(n.code,{children:"pause"}),") assume that the ",(0,t.jsx)(n.code,{children:"update"}),' method is being called once per frame with a "global time". This automatically done for ',(0,t.jsx)(n.code,{children:"AnimationLoop.timeline"})," object."]}),"\n",(0,t.jsx)(n.h2,{id:"parallel-times",children:"Parallel Times"}),"\n",(0,t.jsxs)(n.p,{children:["The key concept at work in the ",(0,t.jsx)(n.code,{children:"Timeline"})," is running multiple time frames in parallel:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['Global Time: The "system time" as determined by the application. Used by ',(0,t.jsx)(n.code,{children:"Timeline"})," to determine the rate at which to play."]}),"\n",(0,t.jsx)(n.li,{children:'Timeline Time: The "parent" time of all channels on the timeline. Can be played at the same rate as "Global Time" or manipulated manually.'}),"\n",(0,t.jsx)(n.li,{children:'Channel Time: Will update in lock step with "Timeline Time", but may move at different rates, loop, etc. depending on channel parameters.'}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,t.jsxs)(n.p,{children:["Automatic update usage (assume ",(0,t.jsx)(n.code,{children:"update"})," method is being called once per frame):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"animationLoop.attachTimeline(new Timeline());\nconst timeline = animationLoop.timeline;\nconst channel1 = timeline.addChannel({\n  rate: 0.5,\n  duration: 4000,\n  repeat: Number.POSITIVE_INFINITY\n});\nconst channel2 = timeline.addChannel({\n  rate: 2,\n  delay: 500,\n  duration: 1000,\n  repeat: 3\n});\n\ntimeline.pause();\ntimeline.play();\n\nmodel.setUniforms({\n  uValue1: timeline.getTime(channel1);\n  uValue2: timeline.getTime(channel2);\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Manual usage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const timeline = new Timeline();\nconst channel1 = timeline.addChannel({\n  rate: 0.5,\n  duration: 4000,\n  repeat: Number.POSITIVE_INFINITY\n});\nconst channel2 = timeline.addChannel({\n  rate: 2,\n  delay: 500,\n  duration: 1000,\n  repeat: 3\n});\ntimeline.setTime(500);\n\nmodel.setUniforms({\n  uValue1: timeline.getTime(channel1);\n  uValue2: timeline.getTime(channel2);\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"addchannelprops-object--number",children:"addChannel([props: Object]) : number"}),"\n",(0,t.jsx)(n.p,{children:"Add a new channel to the timeline. Returns a handle to the channel that can be use for subsequent interactions. Valid propeties are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"rate"})," the speed of the channel's time relative to timeline time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"delay"})," offset into timeline time at which channel time starts elapsing, in timeline time units."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"duration"})," the length of the channel time frame, in timeline time units."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"repeat"})," how many time to repeat channel time's timeline. Only meaningful if ",(0,t.jsx)(n.code,{children:"duration"})," is finite."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"removechannelhandle--number",children:"removeChannel(handle : number)"}),"\n",(0,t.jsxs)(n.p,{children:["Remove a channel from the timeline. ",(0,t.jsx)(n.code,{children:"handle"})," should be a value that was returned by ",(0,t.jsx)(n.code,{children:"addChannel"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"isfinishedhandle--number--boolean",children:"isFinished(handle : number) : Boolean"}),"\n",(0,t.jsx)(n.p,{children:"Returns whether the channel's time has completely elapsed."}),"\n",(0,t.jsx)(n.h3,{id:"gettimehandle--number--number",children:"getTime([handle : number]) : number"}),"\n",(0,t.jsxs)(n.p,{children:["Return the current time of the channel indicated by ",(0,t.jsx)(n.code,{children:"handle"}),". If no handle is provided, return timeline time."]}),"\n",(0,t.jsx)(n.h3,{id:"settimetime--number",children:"setTime(time : number)"}),"\n",(0,t.jsx)(n.p,{children:"Set the timeline time to the given value."}),"\n",(0,t.jsx)(n.h3,{id:"play",children:"play"}),"\n",(0,t.jsxs)(n.p,{children:["Allow timeline time to be updated by calls to ",(0,t.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"pause",children:"pause"}),"\n",(0,t.jsxs)(n.p,{children:["Prevent timeline time from being updated by calls to ",(0,t.jsx)(n.code,{children:"update"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"reset",children:"reset"}),"\n",(0,t.jsxs)(n.p,{children:["Reset timeline time to ",(0,t.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"attachanimationanimation-object-channelhandle--number--number",children:"attachAnimation(animation: Object, [channelHandle : number]) : number"}),"\n",(0,t.jsxs)(n.p,{children:["Attach an animation object (can be any object with a ",(0,t.jsx)(n.code,{children:"setTime"})," method, e.g. ",(0,t.jsx)(n.a,{href:"/docs/api-reference/engine/animation/key-frames",children:"KeyFrames"}),", ",(0,t.jsx)(n.code,{children:"GLTFAnimator"}),") to the timeline, optionally attached to a specific channel referenced by ",(0,t.jsx)(n.code,{children:"channelHandle"}),".\nThe animation object's time will be updated whenever the timeline updates. Returns a handle that can be used to reference the animation attachement."]}),"\n",(0,t.jsx)(n.h3,{id:"detachanimationhandle--number",children:"detachAnimation(handle : number)"}),"\n",(0,t.jsxs)(n.p,{children:["Detach an animation object from the timeline. ",(0,t.jsx)(n.code,{children:"handle"})," should be a value that was returned by ",(0,t.jsx)(n.code,{children:"attachAnimation"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"updateglobaltime--number",children:"update(globalTime : number)"}),"\n",(0,t.jsxs)(n.p,{children:['Expected to be called once per frame, with whatever is considered the "system time". Required for ',(0,t.jsx)(n.code,{children:"play"})," and ",(0,t.jsx)(n.code,{children:"pause"})," to work properly."]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1020:(e,n,i)=>{var t=i(6540),a=Symbol.for("react.element"),l=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,d=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,s={key:!0,ref:!0,__self:!0,__source:!0};function o(e,n,i){var t,l={},o=null,c=null;for(t in void 0!==i&&(o=""+i),void 0!==n.key&&(o=""+n.key),void 0!==n.ref&&(c=n.ref),n)r.call(n,t)&&!s.hasOwnProperty(t)&&(l[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===l[t]&&(l[t]=n[t]);return{$$typeof:a,type:e,key:o,ref:c,props:l,_owner:d.current}}n.Fragment=l,n.jsx=o,n.jsxs=o},4848:(e,n,i)=>{e.exports=i(1020)},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>d});var t=i(6540);const a={},l=t.createContext(a);function r(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);