"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[4332],{116:(e,n,t)=>{t.d(n,{vz:()=>R});var r=t(1425),i="texture-compression-bc",o="texture-compression-astc",a="texture-compression-etc2",s="texture-compression-pvrtc-webgl",l="texture-compression-atc-webgl",c="float32-renderable-webgl",u="float16-renderable-webgl",f="snorm8-renderable-webgl",d="norm16-renderable-webgl",p="snorm16-renderable-webgl",h="float32-filterable",m="float16-filterable-webgl";function g(e){var n=A[e];if(!n)throw new Error("Unsupported texture format "+e);return n}var _={r8unorm:{},rg8unorm:{},"rgb8unorm-webgl":{},rgba8unorm:{},"rgba8unorm-srgb":{},r8snorm:{render:f},rg8snorm:{render:f},"rgb8snorm-webgl":{},rgba8snorm:{render:f},r8uint:{},rg8uint:{},rgba8uint:{},r8sint:{},rg8sint:{},rgba8sint:{},bgra8unorm:{},"bgra8unorm-srgb":{},r16unorm:{f:d},rg16unorm:{render:d},"rgb16unorm-webgl":{f:d},rgba16unorm:{render:d},r16snorm:{f:p},rg16snorm:{render:p},"rgb16snorm-webgl":{f:d},rgba16snorm:{render:p},r16uint:{},rg16uint:{},rgba16uint:{},r16sint:{},rg16sint:{},rgba16sint:{},r16float:{render:u,filter:"float16-filterable-webgl"},rg16float:{render:u,filter:m},rgba16float:{render:u,filter:m},r32uint:{},rg32uint:{},rgba32uint:{},r32sint:{},rg32sint:{},rgba32sint:{},r32float:{render:c,filter:h},rg32float:{render:!1,filter:h},"rgb32float-webgl":{render:c,filter:h},rgba32float:{render:c,filter:h},"rgba4unorm-webgl":{channels:"rgba",bitsPerChannel:[4,4,4,4],packed:!0},"rgb565unorm-webgl":{channels:"rgb",bitsPerChannel:[5,6,5,0],packed:!0},"rgb5a1unorm-webgl":{channels:"rgba",bitsPerChannel:[5,5,5,1],packed:!0},rgb9e5ufloat:{channels:"rgb",packed:!0,render:"rgb9e5ufloat-renderable-webgl"},rg11b10ufloat:{channels:"rgb",bitsPerChannel:[11,11,10,0],packed:!0,p:1,render:c},rgb10a2unorm:{channels:"rgba",bitsPerChannel:[10,10,10,2],packed:!0,p:1},rgb10a2uint:{channels:"rgba",bitsPerChannel:[10,10,10,2],packed:!0,p:1},stencil8:{attachment:"stencil",bitsPerChannel:[8,0,0,0],dataType:"uint8"},depth16unorm:{attachment:"depth",bitsPerChannel:[16,0,0,0],dataType:"uint16"},depth24plus:{attachment:"depth",bitsPerChannel:[24,0,0,0],dataType:"uint32"},depth32float:{attachment:"depth",bitsPerChannel:[32,0,0,0],dataType:"float32"},"depth24plus-stencil8":{attachment:"depth-stencil",bitsPerChannel:[24,8,0,0],packed:!0},"depth32float-stencil8":{attachment:"depth-stencil",bitsPerChannel:[32,8,0,0],packed:!0}},v={"bc1-rgb-unorm-webgl":{f:i},"bc1-rgb-unorm-srgb-webgl":{f:i},"bc1-rgba-unorm":{f:i},"bc1-rgba-unorm-srgb":{f:i},"bc2-rgba-unorm":{f:i},"bc2-rgba-unorm-srgb":{f:i},"bc3-rgba-unorm":{f:i},"bc3-rgba-unorm-srgb":{f:i},"bc4-r-unorm":{f:i},"bc4-r-snorm":{f:i},"bc5-rg-unorm":{f:i},"bc5-rg-snorm":{f:i},"bc6h-rgb-ufloat":{f:i},"bc6h-rgb-float":{f:i},"bc7-rgba-unorm":{f:i},"bc7-rgba-unorm-srgb":{f:i},"etc2-rgb8unorm":{f:a},"etc2-rgb8unorm-srgb":{f:a},"etc2-rgb8a1unorm":{f:a},"etc2-rgb8a1unorm-srgb":{f:a},"etc2-rgba8unorm":{f:a},"etc2-rgba8unorm-srgb":{f:a},"eac-r11unorm":{f:a},"eac-r11snorm":{f:a},"eac-rg11unorm":{f:a},"eac-rg11snorm":{f:a},"astc-4x4-unorm":{f:o},"astc-4x4-unorm-srgb":{f:o},"astc-5x4-unorm":{f:o},"astc-5x4-unorm-srgb":{f:o},"astc-5x5-unorm":{f:o},"astc-5x5-unorm-srgb":{f:o},"astc-6x5-unorm":{f:o},"astc-6x5-unorm-srgb":{f:o},"astc-6x6-unorm":{f:o},"astc-6x6-unorm-srgb":{f:o},"astc-8x5-unorm":{f:o},"astc-8x5-unorm-srgb":{f:o},"astc-8x6-unorm":{f:o},"astc-8x6-unorm-srgb":{f:o},"astc-8x8-unorm":{f:o},"astc-8x8-unorm-srgb":{f:o},"astc-10x5-unorm":{f:o},"astc-10x5-unorm-srgb":{f:o},"astc-10x6-unorm":{f:o},"astc-10x6-unorm-srgb":{f:o},"astc-10x8-unorm":{f:o},"astc-10x8-unorm-srgb":{f:o},"astc-10x10-unorm":{f:o},"astc-10x10-unorm-srgb":{f:o},"astc-12x10-unorm":{f:o},"astc-12x10-unorm-srgb":{f:o},"astc-12x12-unorm":{f:o},"astc-12x12-unorm-srgb":{f:o},"pvrtc-rgb4unorm-webgl":{f:s},"pvrtc-rgba4unorm-webgl":{f:s},"pvrtc-rbg2unorm-webgl":{f:s},"pvrtc-rgba2unorm-webgl":{f:s},"etc1-rbg-unorm-webgl":{f:"texture-compression-etc1-webgl"},"atc-rgb-unorm-webgl":{f:l},"atc-rgba-unorm-webgl":{f:l},"atc-rgbai-unorm-webgl":{f:l}},A=Object.assign({},_,v),E=/^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/,T=["rgb","rgba","bgra"],b=["depth","stencil"],x=["bc1","bc2","bc3","bc4","bc5","bc6","bc7","etc1","etc2","eac","atc","astc","pvrtc"],R=new(function(){function e(){}var n=e.prototype;return n.isColor=function(e){return T.some(function(n){return e.startsWith(n)})},n.isDepthStencil=function(e){return b.some(function(n){return e.startsWith(n)})},n.isCompressed=function(e){return x.some(function(n){return e.startsWith(n)})},n.getInfo=function(e){return C(e)},n.getCapabilities=function(e){return function(e){var n,t,r,i,o,a=g(e),s={format:e,create:null==(n=a.f)||n,render:null==(t=a.render)||t,filter:null==(r=a.filter)||r,blend:null==(i=a.blend)||i,store:null==(o=a.store)||o},l=C(e),c=e.startsWith("depth")||e.startsWith("stencil"),u=null==l?void 0:l.signed,f=null==l?void 0:l.integer,d=null==l?void 0:l.webgl;return s.render&&(s.render=!u),s.filter&&(s.filter=!(c||u||f||d)),s}(e)},n.computeMemoryLayout=function(e){return t=(n=e).format,r=n.width,i=n.height,o=n.depth,a=n.byteAlignment,s=R.getInfo(t).bytesPerPixel,l=r*s,c=Math.ceil(l/a)*a,{bytesPerPixel:s,bytesPerRow:c,rowsPerImage:i,depthOrArrayLayers:o,bytesPerImage:c*i,byteLength:c*i*o};var n,t,r,i,o,a,s,l,c},e}());function C(e){var n=function(e){var n,t,r,i,o,a,s,l,c=g(e),u=c.bytesPerPixel||1,f=c.bitsPerChannel||[8,8,8,8];delete c.bitsPerChannel,delete c.bytesPerPixel,delete c.f,delete c.render,delete c.filter,delete c.blend,delete c.store;var d=Object.assign({},c,{format:e,attachment:c.attachment||"color",channels:c.channels||"r",components:c.components||(null==(n=c.channels)?void 0:n.length)||1,bytesPerPixel:u,bitsPerChannel:f,dataType:c.dataType||"uint8",srgb:null!=(t=c.srgb)&&t,packed:null!=(r=c.packed)&&r,webgl:null!=(i=c.webgl)&&i,integer:null!=(o=c.integer)&&o,signed:null!=(a=c.signed)&&a,normalized:null!=(s=c.normalized)&&s,compressed:null!=(l=c.compressed)&&l});return d}(e);if(R.isCompressed(e)){n.channels="rgb",n.components=3,n.bytesPerPixel=1,n.srgb=!1,n.compressed=!0;var t=function(e){var n=/.*-(\d+)x(\d+)-.*/.exec(e);if(n){var t=n[1],r=n[2];return{blockWidth:Number(t),blockHeight:Number(r)}}return null}(e);t&&(n.blockWidth=t.blockWidth,n.blockHeight=t.blockHeight)}var i=E.exec(e);if(i){var o=i[1],a=i[2],s=i[3],l=i[4],c=i[5],u=""+s+a,f=(0,r.vE)(u),d=8*f.byteLength,p=o.length,h=[d,p>=2?d:0,p>=3?d:0,p>=4?d:0];n={format:e,attachment:n.attachment,dataType:f.signedType,components:p,channels:o,integer:f.integer,signed:f.signed,normalized:f.normalized,bitsPerChannel:h,bytesPerPixel:f.byteLength*o.length,packed:n.packed,srgb:n.srgb},"-webgl"===c&&(n.webgl=!0),"-srgb"===l&&(n.srgb=!0)}return e.endsWith("-webgl")&&(n.webgl=!0),e.endsWith("-srgb")&&(n.srgb=!0),n}},996:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>f});const r=JSON.parse('{"id":"tutorials/hello-triangle","title":"Hello Triangle","description":"This tutorial demonstrates how to draw a triangle using luma.gl\'s cross-platform rendering APIs.","source":"@site/../docs/tutorials/hello-triangle.mdx","sourceDirName":"tutorials","slug":"/tutorials/hello-triangle","permalink":"/docs/tutorials/hello-triangle","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/tutorials/hello-triangle.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Setup","permalink":"/docs/tutorials/"},"next":{"title":"Hello Cube","permalink":"/docs/tutorials/hello-cube"}}');var i=t(4848),o=t(8453),a=t(8482),s=t(3848);const l={},c="Hello Triangle",u={},f=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"hello-triangle",children:"Hello Triangle"})}),"\n",(0,i.jsx)(n.p,{children:"This tutorial demonstrates how to draw a triangle using luma.gl's cross-platform rendering APIs."}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"Tutorials are maintained on a best-effort basis and may not be fully up to date (contributions welcome)."})}),"\n",(0,i.jsx)(a.xN,{}),"\n",(0,i.jsx)(s.Jh,{}),"\n",(0,i.jsxs)(n.p,{children:["It is assumed you've set up your development environment as described in ",(0,i.jsx)(n.a,{href:"/docs/tutorials",children:"Setup"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["We create a ",(0,i.jsx)(n.code,{children:"Model"})," to render the triangle. This will be a recurring theme in all our tutorials. A ",(0,i.jsx)(n.code,{children:"Model"})," can be thought of as gathering all the WebGL/WebGPU pieces necessary for a single draw call: render pipelines (shader programs), attribute buffers, uniforms, texture bindings etc."]}),"\n",(0,i.jsxs)(n.p,{children:["The program uses a tiny vertex shader that relies on the built-in ",(0,i.jsx)(n.code,{children:"vertex_index"})," to look up clip-space positions for the three vertices. A matching fragment shader fills the triangle with a solid color. Both WGSL and GLSL versions are provided so the example runs on WebGPU and WebGL without changes."]}),"\n",(0,i.jsxs)(n.p,{children:["The complete source for this example is shown below. It creates a ",(0,i.jsx)(n.code,{children:"Model"})," with both WGSL and GLSL shaders and renders it inside an ",(0,i.jsx)(n.code,{children:"AnimationLoopTemplate"}),". The animation loop simply opens a render pass, draws the model and ends the pass each frame."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import {AnimationLoopTemplate, AnimationProps, makeAnimationLoop, Model} from '@luma.gl/engine';\nimport {webgl2Adapter} from '@luma.gl/webgl';\nimport {webgpuAdapter} from '@luma.gl/webgpu';\n\nconst WGSL_SHADER = /* WGSL */ `\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4<f32> {\n  var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  return vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n}\n\n@fragment\nfn fragmentMain() -> @location(0) vec4<f32> {\n  return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n`;\n\nconst VS_GLSL = /* glsl */ `\n#version 300 es\nconst vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);\n}\n`;\n\nconst FS_GLSL = /* glsl */ `\n#version 300 es\nprecision highp float;\nlayout(location = 0) out vec4 outColor;\nvoid main() {\n  outColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n`;\n\nclass AppAnimationLoopTemplate extends AnimationLoopTemplate {\n  model: Model;\n\n  constructor({device}: AnimationProps) {\n    super();\n    this.model = new Model(device, {\n      source: WGSL_SHADER,\n      vs: VS_GLSL,\n      fs: FS_GLSL,\n      topology: 'triangle-list',\n      vertexCount: 3,\n      shaderLayout: {\n        attributes: [],\n        bindings: []\n      },\n      parameters: {\n        depthFormat: 'depth24plus'\n      }\n    });\n  }\n\n  override onFinalize() {\n    this.model.destroy();\n  }\n\n  override onRender({device}: AnimationProps) {\n    const renderPass = device.beginRenderPass({clearColor: [1, 1, 1, 1]});\n    this.model.draw(renderPass);\n    renderPass.end();\n  }\n}\n\nconst animationLoop = makeAnimationLoop(AnimationLoopTemplate, {adapters: [webgpuAdapter, webgl2Adapter]})\nanimationLoop.start();\n"})}),"\n",(0,i.jsx)(n.p,{children:"The vertex shader uses built-in indices, so no vertex buffers are needed for this\nminimal example. The render loop clears the canvas and draws the model every\nframe."}),"\n",(0,i.jsx)(n.p,{children:"When the application runs you should see a red triangle rendered on a white background."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1166:(e,n,t)=>{t.d(n,{L:()=>i});var r={};function i(e){return void 0===e&&(e="id"),r[e]=r[e]||1,e+"-"+r[e]++}},1425:(e,n,t)=>{function r(e){var n=e.includes("norm"),t=!n&&!e.startsWith("float"),r=e.startsWith("s"),i=l[e]||["uint8 ","i32",1];return{signedType:i[0],primitiveType:i[1],byteLength:i[2],normalized:n,integer:t,signed:r}}function i(e){var n=e;switch(n){case"uint8":return"unorm8";case"sint8":return"snorm8";case"uint16":return"unorm16";case"sint16":return"snorm16";default:return n}}function o(e,n){switch(n){case 1:return e;case 2:return e+e%2;default:return e+(4-e%4)%4}}function a(e){var n=ArrayBuffer.isView(e)?e.constructor:e;if(n===Uint8ClampedArray)return"uint8";var t=Object.values(l).find(function(e){return n===e[4]});if(!t)throw new Error(n.name);return t[0]}function s(e){return l[e][4]}t.d(n,{Ak:()=>s,JP:()=>o,K7:()=>i,h1:()=>a,vE:()=>r});var l={uint8:["uint8","u32",1,!1,Uint8Array],sint8:["sint8","i32",1,!1,Int8Array],unorm8:["uint8","f32",1,!0,Uint8Array],snorm8:["sint8","f32",1,!0,Int8Array],uint16:["uint16","u32",2,!1,Uint16Array],sint16:["sint16","i32",2,!1,Int16Array],unorm16:["uint16","u32",2,!0,Uint16Array],snorm16:["sint16","i32",2,!0,Int16Array],float16:["float16","f16",2,!1,Uint16Array],float32:["float32","f32",4,!1,Float32Array],uint32:["uint32","u32",4,!1,Uint32Array],sint32:["sint32","i32",4,!1,Int32Array]}},1464:(e,n,t)=>{function r(e){return s[e]}function i(e){var n=a[e],t=n[0],r=n[1],i="i32"===t||"u32"===t,s="u32"!==t;return{primitiveType:t,components:r,byteLength:o[t]*r,integer:i,signed:s}}t.d(n,{k0:()=>r,wH:()=>i});var o={f32:4,f16:2,i32:4,u32:4},a={f32:["f32",1],"vec2<f32>":["f32",2],"vec3<f32>":["f32",3],"vec4<f32>":["f32",4],f16:["f16",1],"vec2<f16>":["f16",2],"vec3<f16>":["f16",3],"vec4<f16>":["f16",4],i32:["i32",1],"vec2<i32>":["i32",2],"vec3<i32>":["i32",3],"vec4<i32>":["i32",4],u32:["u32",1],"vec2<u32>":["u32",2],"vec3<u32>":["u32",3],"vec4<u32>":["u32",4]},s={f32:{type:"f32",components:1},f16:{type:"f16",components:1},i32:{type:"i32",components:1},u32:{type:"u32",components:1},"vec2<f32>":{type:"f32",components:2},"vec3<f32>":{type:"f32",components:3},"vec4<f32>":{type:"f32",components:4},"vec2<f16>":{type:"f16",components:2},"vec3<f16>":{type:"f16",components:3},"vec4<f16>":{type:"f16",components:4},"vec2<i32>":{type:"i32",components:2},"vec3<i32>":{type:"i32",components:3},"vec4<i32>":{type:"i32",components:4},"vec2<u32>":{type:"u32",components:2},"vec3<u32>":{type:"u32",components:3},"vec4<u32>":{type:"u32",components:4},"mat2x2<f32>":{type:"f32",components:4},"mat2x3<f32>":{type:"f32",components:6},"mat2x4<f32>":{type:"f32",components:8},"mat3x2<f32>":{type:"f32",components:6},"mat3x3<f32>":{type:"f32",components:9},"mat3x4<f32>":{type:"f32",components:12},"mat4x2<f32>":{type:"f32",components:8},"mat4x3<f32>":{type:"f32",components:12},"mat4x4<f32>":{type:"f32",components:16},"mat2x2<f16>":{type:"f16",components:4},"mat2x3<f16>":{type:"f16",components:6},"mat2x4<f16>":{type:"f16",components:8},"mat3x2<f16>":{type:"f16",components:6},"mat3x3<f16>":{type:"f16",components:9},"mat3x4<f16>":{type:"f16",components:12},"mat4x2<f16>":{type:"f16",components:8},"mat4x3<f16>":{type:"f16",components:12},"mat4x4<f16>":{type:"f16",components:16},"mat2x2<i32>":{type:"i32",components:4},"mat2x3<i32>":{type:"i32",components:6},"mat2x4<i32>":{type:"i32",components:8},"mat3x2<i32>":{type:"i32",components:6},"mat3x3<i32>":{type:"i32",components:9},"mat3x4<i32>":{type:"i32",components:12},"mat4x2<i32>":{type:"i32",components:8},"mat4x3<i32>":{type:"i32",components:12},"mat4x4<i32>":{type:"i32",components:16},"mat2x2<u32>":{type:"u32",components:4},"mat2x3<u32>":{type:"u32",components:6},"mat2x4<u32>":{type:"u32",components:8},"mat3x2<u32>":{type:"u32",components:6},"mat3x3<u32>":{type:"u32",components:9},"mat3x4<u32>":{type:"u32",components:12},"mat4x2<u32>":{type:"u32",components:8},"mat4x3<u32>":{type:"u32",components:12},"mat4x4<u32>":{type:"u32",components:16}},l={vec2i:"vec2<i32>",vec3i:"vec3<i32>",vec4i:"vec4<i32>",vec2u:"vec2<u32>",vec3u:"vec3<u32>",vec4u:"vec4<u32>",vec2f:"vec2<f32>",vec3f:"vec3<f32>",vec4f:"vec4<f32>",vec2h:"vec2<f16>",vec3h:"vec3<f16>",vec4h:"vec4<f16>"};Object.assign({},l,{mat2x2f:"mat2x2<f32>",mat2x3f:"mat2x3<f32>",mat2x4f:"mat2x4<f32>",mat3x2f:"mat3x2<f32>",mat3x3f:"mat3x3<f32>",mat3x4f:"mat3x4<f32>",mat4x2f:"mat4x2<f32>",mat4x3f:"mat4x3<f32>",mat4x4f:"mat4x4<f32>",mat2x2i:"mat2x2<i32>",mat2x3i:"mat2x3<i32>",mat2x4i:"mat2x4<i32>",mat3x2i:"mat3x2<i32>",mat3x3i:"mat3x3<i32>",mat3x4i:"mat3x4<i32>",mat4x2i:"mat4x2<i32>",mat4x3i:"mat4x3<i32>",mat4x4i:"mat4x4<i32>",mat2x2u:"mat2x2<u32>",mat2x3u:"mat2x3<u32>",mat2x4u:"mat2x4<u32>",mat3x2u:"mat3x2<u32>",mat3x3u:"mat3x3<u32>",mat3x4u:"mat3x4<u32>",mat4x2u:"mat4x2<u32>",mat4x3u:"mat4x3<u32>",mat4x4u:"mat4x4<u32>",mat2x2h:"mat2x2<f16>",mat2x3h:"mat2x3<f16>",mat2x4h:"mat2x4<f16>",mat3x2h:"mat3x2<f16>",mat3x3h:"mat3x3<f16>",mat3x4h:"mat3x4<f16>",mat4x2h:"mat4x2<f16>",mat4x3h:"mat4x3<f16>",mat4x4h:"mat4x4<f16>"})},1649:(e,n,t)=>{var r;function i(e){return(!r||r.byteLength<e)&&(r=new ArrayBuffer(e)),r}function o(e,n){return new e(i(e.BYTES_PER_ELEMENT*n),0,n)}t.d(n,{X:()=>o,o:()=>i})},1990:(e,n,t)=>{t.d(n,{Mz:()=>a,OB:()=>o,yx:()=>i});var r=t(1425);function i(e){var n;e.endsWith("-webgl")&&(e.replace("-webgl",""),n=!0);var t=e.split("x"),i=t[0],o=t[1],a=i,s=o?parseInt(o):1,l=(0,r.vE)(a),c={type:a,components:s,byteLength:l.byteLength*s,integer:l.integer,signed:l.signed,normalized:l.normalized};return n&&(c.webglOnly=!0),c}function o(e,n,t){if(!n||n>4)throw new Error("size "+n);var i=n;return function(e,n,t){var i=t?(0,r.K7)(e):e;switch(i){case"unorm8":return 1===n?"unorm8":3===n?"unorm8x3-webgl":i+"x"+n;case"snorm8":case"uint8":case"sint8":case"uint16":case"sint16":case"unorm16":case"snorm16":case"float16":if(1===n||3===n)throw new Error("size: "+n);return i+"x"+n;default:return 1===n?i:i+"x"+n}}((0,r.h1)(e),i,t)}function a(e){var n;switch(e.primitiveType){case"f32":n="float32";break;case"i32":n="sint32";break;case"u32":n="uint32";break;case"f16":return e.components<=2?"float16x2":"float16x4"}return 1===e.components?n:n+"x"+e.components}},2018:(e,n,t)=>{t.d(n,{M:()=>l,P:()=>s});var r=t(3845),i=t(3522),o=t(1464),a=t(1990);function s(e,n){for(var t,i={},o=(0,r.A)(e.attributes);!(t=o()).done;){var a=t.value,s=c(e,n,a.name);s&&(i[a.name]=s)}return i}function l(e,n,t){void 0===t&&(t=16);for(var r=s(e,n),i=new Array(t).fill(null),o=0,a=Object.values(r);o<a.length;o++){var l=a[o];i[l.location]=l}return i}function c(e,n,t){var s=function(e,n){var t=e.attributes.find(function(e){return e.name===n});t||i.R.warn('shader layout attribute "'+n+'" not present in shader');return t||null}(e,t),l=function(e,n){u(e);var t=function(e,n){for(var t,i=(0,r.A)(e);!(t=i()).done;){var o=t.value;if(o.format&&o.name===n)return{attributeName:o.name,bufferName:n,stepMode:o.stepMode,vertexFormat:o.format,byteOffset:0,byteStride:o.byteStride||0}}return null}(e,n);if(t)return t;if(t=function(e,n){for(var t,i=(0,r.A)(e);!(t=i()).done;){var o,s=t.value,l=s.byteStride;if("number"!=typeof s.byteStride)for(var c,u=(0,r.A)(s.attributes||[]);!(c=u()).done;){var f=c.value;l+=(0,a.yx)(f.format).byteLength}var d=null==(o=s.attributes)?void 0:o.find(function(e){return e.attribute===n});if(d)return{attributeName:d.attribute,bufferName:s.name,stepMode:s.stepMode,vertexFormat:d.format,byteOffset:d.byteOffset,byteStride:l}}return null}(e,n),t)return t;return i.R.warn('layout for attribute "'+n+'" not present in buffer layout'),null}(n,t);if(!s)return null;var c=(0,o.wH)(s.type),f=(0,a.Mz)(c),d=(null==l?void 0:l.vertexFormat)||f,p=(0,a.yx)(d);return{attributeName:(null==l?void 0:l.attributeName)||s.name,bufferName:(null==l?void 0:l.bufferName)||s.name,location:s.location,shaderType:s.type,primitiveType:c.primitiveType,shaderComponents:c.components,vertexFormat:d,bufferDataType:p.type,bufferComponents:p.components,normalized:p.normalized,integer:c.integer,stepMode:(null==l?void 0:l.stepMode)||s.stepMode||"vertex",byteOffset:(null==l?void 0:l.byteOffset)||0,byteStride:(null==l?void 0:l.byteStride)||0}}function u(e){for(var n,t=(0,r.A)(e);!(n=t()).done;){var o=n.value;(o.attributes&&o.format||!o.attributes&&!o.format)&&i.R.warn("BufferLayout "+name+" must have either 'attributes' or 'format' field")}}},3145:(e,n,t)=>{t.d(n,{r:()=>a});var r=t(8696),i=t(7387),o=t(7862),a=function(e){function n(t,r){var i;return(i=e.call(this,t,r,n.defaultProps)||this).linkStatus="pending",i.hash="",i.shaderLayout=i.props.shaderLayout,i.bufferLayout=i.props.bufferLayout||[],i}return(0,i.A)(n,e),(0,r.A)(n,[{key:Symbol.toStringTag,get:function(){return"RenderPipeline"}}])}(o.F);a.defaultProps=Object.assign({},o.F.defaultProps,{vs:null,vertexEntryPoint:"vertexMain",vsConstants:{},fs:null,fragmentEntryPoint:"fragmentMain",fsConstants:{},shaderLayout:null,bufferLayout:[],topology:"triangle-list",colorAttachmentFormats:void 0,depthStencilAttachmentFormat:void 0,parameters:{},bindings:{},uniforms:{}})},3369:(e,n,t)=>{t.d(n,{GL:()=>r});var r=function(e){return e[e.DEPTH_BUFFER_BIT=256]="DEPTH_BUFFER_BIT",e[e.STENCIL_BUFFER_BIT=1024]="STENCIL_BUFFER_BIT",e[e.COLOR_BUFFER_BIT=16384]="COLOR_BUFFER_BIT",e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN",e[e.ZERO=0]="ZERO",e[e.ONE=1]="ONE",e[e.SRC_COLOR=768]="SRC_COLOR",e[e.ONE_MINUS_SRC_COLOR=769]="ONE_MINUS_SRC_COLOR",e[e.SRC_ALPHA=770]="SRC_ALPHA",e[e.ONE_MINUS_SRC_ALPHA=771]="ONE_MINUS_SRC_ALPHA",e[e.DST_ALPHA=772]="DST_ALPHA",e[e.ONE_MINUS_DST_ALPHA=773]="ONE_MINUS_DST_ALPHA",e[e.DST_COLOR=774]="DST_COLOR",e[e.ONE_MINUS_DST_COLOR=775]="ONE_MINUS_DST_COLOR",e[e.SRC_ALPHA_SATURATE=776]="SRC_ALPHA_SATURATE",e[e.CONSTANT_COLOR=32769]="CONSTANT_COLOR",e[e.ONE_MINUS_CONSTANT_COLOR=32770]="ONE_MINUS_CONSTANT_COLOR",e[e.CONSTANT_ALPHA=32771]="CONSTANT_ALPHA",e[e.ONE_MINUS_CONSTANT_ALPHA=32772]="ONE_MINUS_CONSTANT_ALPHA",e[e.FUNC_ADD=32774]="FUNC_ADD",e[e.FUNC_SUBTRACT=32778]="FUNC_SUBTRACT",e[e.FUNC_REVERSE_SUBTRACT=32779]="FUNC_REVERSE_SUBTRACT",e[e.BLEND_EQUATION=32777]="BLEND_EQUATION",e[e.BLEND_EQUATION_RGB=32777]="BLEND_EQUATION_RGB",e[e.BLEND_EQUATION_ALPHA=34877]="BLEND_EQUATION_ALPHA",e[e.BLEND_DST_RGB=32968]="BLEND_DST_RGB",e[e.BLEND_SRC_RGB=32969]="BLEND_SRC_RGB",e[e.BLEND_DST_ALPHA=32970]="BLEND_DST_ALPHA",e[e.BLEND_SRC_ALPHA=32971]="BLEND_SRC_ALPHA",e[e.BLEND_COLOR=32773]="BLEND_COLOR",e[e.ARRAY_BUFFER_BINDING=34964]="ARRAY_BUFFER_BINDING",e[e.ELEMENT_ARRAY_BUFFER_BINDING=34965]="ELEMENT_ARRAY_BUFFER_BINDING",e[e.LINE_WIDTH=2849]="LINE_WIDTH",e[e.ALIASED_POINT_SIZE_RANGE=33901]="ALIASED_POINT_SIZE_RANGE",e[e.ALIASED_LINE_WIDTH_RANGE=33902]="ALIASED_LINE_WIDTH_RANGE",e[e.CULL_FACE_MODE=2885]="CULL_FACE_MODE",e[e.FRONT_FACE=2886]="FRONT_FACE",e[e.DEPTH_RANGE=2928]="DEPTH_RANGE",e[e.DEPTH_WRITEMASK=2930]="DEPTH_WRITEMASK",e[e.DEPTH_CLEAR_VALUE=2931]="DEPTH_CLEAR_VALUE",e[e.DEPTH_FUNC=2932]="DEPTH_FUNC",e[e.STENCIL_CLEAR_VALUE=2961]="STENCIL_CLEAR_VALUE",e[e.STENCIL_FUNC=2962]="STENCIL_FUNC",e[e.STENCIL_FAIL=2964]="STENCIL_FAIL",e[e.STENCIL_PASS_DEPTH_FAIL=2965]="STENCIL_PASS_DEPTH_FAIL",e[e.STENCIL_PASS_DEPTH_PASS=2966]="STENCIL_PASS_DEPTH_PASS",e[e.STENCIL_REF=2967]="STENCIL_REF",e[e.STENCIL_VALUE_MASK=2963]="STENCIL_VALUE_MASK",e[e.STENCIL_WRITEMASK=2968]="STENCIL_WRITEMASK",e[e.STENCIL_BACK_FUNC=34816]="STENCIL_BACK_FUNC",e[e.STENCIL_BACK_FAIL=34817]="STENCIL_BACK_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_FAIL=34818]="STENCIL_BACK_PASS_DEPTH_FAIL",e[e.STENCIL_BACK_PASS_DEPTH_PASS=34819]="STENCIL_BACK_PASS_DEPTH_PASS",e[e.STENCIL_BACK_REF=36003]="STENCIL_BACK_REF",e[e.STENCIL_BACK_VALUE_MASK=36004]="STENCIL_BACK_VALUE_MASK",e[e.STENCIL_BACK_WRITEMASK=36005]="STENCIL_BACK_WRITEMASK",e[e.VIEWPORT=2978]="VIEWPORT",e[e.SCISSOR_BOX=3088]="SCISSOR_BOX",e[e.COLOR_CLEAR_VALUE=3106]="COLOR_CLEAR_VALUE",e[e.COLOR_WRITEMASK=3107]="COLOR_WRITEMASK",e[e.UNPACK_ALIGNMENT=3317]="UNPACK_ALIGNMENT",e[e.PACK_ALIGNMENT=3333]="PACK_ALIGNMENT",e[e.MAX_TEXTURE_SIZE=3379]="MAX_TEXTURE_SIZE",e[e.MAX_VIEWPORT_DIMS=3386]="MAX_VIEWPORT_DIMS",e[e.SUBPIXEL_BITS=3408]="SUBPIXEL_BITS",e[e.RED_BITS=3410]="RED_BITS",e[e.GREEN_BITS=3411]="GREEN_BITS",e[e.BLUE_BITS=3412]="BLUE_BITS",e[e.ALPHA_BITS=3413]="ALPHA_BITS",e[e.DEPTH_BITS=3414]="DEPTH_BITS",e[e.STENCIL_BITS=3415]="STENCIL_BITS",e[e.POLYGON_OFFSET_UNITS=10752]="POLYGON_OFFSET_UNITS",e[e.POLYGON_OFFSET_FACTOR=32824]="POLYGON_OFFSET_FACTOR",e[e.TEXTURE_BINDING_2D=32873]="TEXTURE_BINDING_2D",e[e.SAMPLE_BUFFERS=32936]="SAMPLE_BUFFERS",e[e.SAMPLES=32937]="SAMPLES",e[e.SAMPLE_COVERAGE_VALUE=32938]="SAMPLE_COVERAGE_VALUE",e[e.SAMPLE_COVERAGE_INVERT=32939]="SAMPLE_COVERAGE_INVERT",e[e.COMPRESSED_TEXTURE_FORMATS=34467]="COMPRESSED_TEXTURE_FORMATS",e[e.VENDOR=7936]="VENDOR",e[e.RENDERER=7937]="RENDERER",e[e.VERSION=7938]="VERSION",e[e.IMPLEMENTATION_COLOR_READ_TYPE=35738]="IMPLEMENTATION_COLOR_READ_TYPE",e[e.IMPLEMENTATION_COLOR_READ_FORMAT=35739]="IMPLEMENTATION_COLOR_READ_FORMAT",e[e.BROWSER_DEFAULT_WEBGL=37444]="BROWSER_DEFAULT_WEBGL",e[e.STATIC_DRAW=35044]="STATIC_DRAW",e[e.STREAM_DRAW=35040]="STREAM_DRAW",e[e.DYNAMIC_DRAW=35048]="DYNAMIC_DRAW",e[e.ARRAY_BUFFER=34962]="ARRAY_BUFFER",e[e.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",e[e.BUFFER_SIZE=34660]="BUFFER_SIZE",e[e.BUFFER_USAGE=34661]="BUFFER_USAGE",e[e.CURRENT_VERTEX_ATTRIB=34342]="CURRENT_VERTEX_ATTRIB",e[e.VERTEX_ATTRIB_ARRAY_ENABLED=34338]="VERTEX_ATTRIB_ARRAY_ENABLED",e[e.VERTEX_ATTRIB_ARRAY_SIZE=34339]="VERTEX_ATTRIB_ARRAY_SIZE",e[e.VERTEX_ATTRIB_ARRAY_STRIDE=34340]="VERTEX_ATTRIB_ARRAY_STRIDE",e[e.VERTEX_ATTRIB_ARRAY_TYPE=34341]="VERTEX_ATTRIB_ARRAY_TYPE",e[e.VERTEX_ATTRIB_ARRAY_NORMALIZED=34922]="VERTEX_ATTRIB_ARRAY_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_POINTER=34373]="VERTEX_ATTRIB_ARRAY_POINTER",e[e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING=34975]="VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",e[e.CULL_FACE=2884]="CULL_FACE",e[e.FRONT=1028]="FRONT",e[e.BACK=1029]="BACK",e[e.FRONT_AND_BACK=1032]="FRONT_AND_BACK",e[e.BLEND=3042]="BLEND",e[e.DEPTH_TEST=2929]="DEPTH_TEST",e[e.DITHER=3024]="DITHER",e[e.POLYGON_OFFSET_FILL=32823]="POLYGON_OFFSET_FILL",e[e.SAMPLE_ALPHA_TO_COVERAGE=32926]="SAMPLE_ALPHA_TO_COVERAGE",e[e.SAMPLE_COVERAGE=32928]="SAMPLE_COVERAGE",e[e.SCISSOR_TEST=3089]="SCISSOR_TEST",e[e.STENCIL_TEST=2960]="STENCIL_TEST",e[e.NO_ERROR=0]="NO_ERROR",e[e.INVALID_ENUM=1280]="INVALID_ENUM",e[e.INVALID_VALUE=1281]="INVALID_VALUE",e[e.INVALID_OPERATION=1282]="INVALID_OPERATION",e[e.OUT_OF_MEMORY=1285]="OUT_OF_MEMORY",e[e.CONTEXT_LOST_WEBGL=37442]="CONTEXT_LOST_WEBGL",e[e.CW=2304]="CW",e[e.CCW=2305]="CCW",e[e.DONT_CARE=4352]="DONT_CARE",e[e.FASTEST=4353]="FASTEST",e[e.NICEST=4354]="NICEST",e[e.GENERATE_MIPMAP_HINT=33170]="GENERATE_MIPMAP_HINT",e[e.BYTE=5120]="BYTE",e[e.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",e[e.SHORT=5122]="SHORT",e[e.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",e[e.INT=5124]="INT",e[e.UNSIGNED_INT=5125]="UNSIGNED_INT",e[e.FLOAT=5126]="FLOAT",e[e.DOUBLE=5130]="DOUBLE",e[e.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",e[e.ALPHA=6406]="ALPHA",e[e.RGB=6407]="RGB",e[e.RGBA=6408]="RGBA",e[e.LUMINANCE=6409]="LUMINANCE",e[e.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",e[e.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",e[e.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",e[e.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",e[e.FRAGMENT_SHADER=35632]="FRAGMENT_SHADER",e[e.VERTEX_SHADER=35633]="VERTEX_SHADER",e[e.COMPILE_STATUS=35713]="COMPILE_STATUS",e[e.DELETE_STATUS=35712]="DELETE_STATUS",e[e.LINK_STATUS=35714]="LINK_STATUS",e[e.VALIDATE_STATUS=35715]="VALIDATE_STATUS",e[e.ATTACHED_SHADERS=35717]="ATTACHED_SHADERS",e[e.ACTIVE_ATTRIBUTES=35721]="ACTIVE_ATTRIBUTES",e[e.ACTIVE_UNIFORMS=35718]="ACTIVE_UNIFORMS",e[e.MAX_VERTEX_ATTRIBS=34921]="MAX_VERTEX_ATTRIBS",e[e.MAX_VERTEX_UNIFORM_VECTORS=36347]="MAX_VERTEX_UNIFORM_VECTORS",e[e.MAX_VARYING_VECTORS=36348]="MAX_VARYING_VECTORS",e[e.MAX_COMBINED_TEXTURE_IMAGE_UNITS=35661]="MAX_COMBINED_TEXTURE_IMAGE_UNITS",e[e.MAX_VERTEX_TEXTURE_IMAGE_UNITS=35660]="MAX_VERTEX_TEXTURE_IMAGE_UNITS",e[e.MAX_TEXTURE_IMAGE_UNITS=34930]="MAX_TEXTURE_IMAGE_UNITS",e[e.MAX_FRAGMENT_UNIFORM_VECTORS=36349]="MAX_FRAGMENT_UNIFORM_VECTORS",e[e.SHADER_TYPE=35663]="SHADER_TYPE",e[e.SHADING_LANGUAGE_VERSION=35724]="SHADING_LANGUAGE_VERSION",e[e.CURRENT_PROGRAM=35725]="CURRENT_PROGRAM",e[e.NEVER=512]="NEVER",e[e.LESS=513]="LESS",e[e.EQUAL=514]="EQUAL",e[e.LEQUAL=515]="LEQUAL",e[e.GREATER=516]="GREATER",e[e.NOTEQUAL=517]="NOTEQUAL",e[e.GEQUAL=518]="GEQUAL",e[e.ALWAYS=519]="ALWAYS",e[e.KEEP=7680]="KEEP",e[e.REPLACE=7681]="REPLACE",e[e.INCR=7682]="INCR",e[e.DECR=7683]="DECR",e[e.INVERT=5386]="INVERT",e[e.INCR_WRAP=34055]="INCR_WRAP",e[e.DECR_WRAP=34056]="DECR_WRAP",e[e.NEAREST=9728]="NEAREST",e[e.LINEAR=9729]="LINEAR",e[e.NEAREST_MIPMAP_NEAREST=9984]="NEAREST_MIPMAP_NEAREST",e[e.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",e[e.NEAREST_MIPMAP_LINEAR=9986]="NEAREST_MIPMAP_LINEAR",e[e.LINEAR_MIPMAP_LINEAR=9987]="LINEAR_MIPMAP_LINEAR",e[e.TEXTURE_MAG_FILTER=10240]="TEXTURE_MAG_FILTER",e[e.TEXTURE_MIN_FILTER=10241]="TEXTURE_MIN_FILTER",e[e.TEXTURE_WRAP_S=10242]="TEXTURE_WRAP_S",e[e.TEXTURE_WRAP_T=10243]="TEXTURE_WRAP_T",e[e.TEXTURE_2D=3553]="TEXTURE_2D",e[e.TEXTURE=5890]="TEXTURE",e[e.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",e[e.TEXTURE_BINDING_CUBE_MAP=34068]="TEXTURE_BINDING_CUBE_MAP",e[e.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",e[e.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",e[e.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",e[e.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",e[e.MAX_CUBE_MAP_TEXTURE_SIZE=34076]="MAX_CUBE_MAP_TEXTURE_SIZE",e[e.TEXTURE0=33984]="TEXTURE0",e[e.ACTIVE_TEXTURE=34016]="ACTIVE_TEXTURE",e[e.REPEAT=10497]="REPEAT",e[e.CLAMP_TO_EDGE=33071]="CLAMP_TO_EDGE",e[e.MIRRORED_REPEAT=33648]="MIRRORED_REPEAT",e[e.TEXTURE_WIDTH=4096]="TEXTURE_WIDTH",e[e.TEXTURE_HEIGHT=4097]="TEXTURE_HEIGHT",e[e.FLOAT_VEC2=35664]="FLOAT_VEC2",e[e.FLOAT_VEC3=35665]="FLOAT_VEC3",e[e.FLOAT_VEC4=35666]="FLOAT_VEC4",e[e.INT_VEC2=35667]="INT_VEC2",e[e.INT_VEC3=35668]="INT_VEC3",e[e.INT_VEC4=35669]="INT_VEC4",e[e.BOOL=35670]="BOOL",e[e.BOOL_VEC2=35671]="BOOL_VEC2",e[e.BOOL_VEC3=35672]="BOOL_VEC3",e[e.BOOL_VEC4=35673]="BOOL_VEC4",e[e.FLOAT_MAT2=35674]="FLOAT_MAT2",e[e.FLOAT_MAT3=35675]="FLOAT_MAT3",e[e.FLOAT_MAT4=35676]="FLOAT_MAT4",e[e.SAMPLER_2D=35678]="SAMPLER_2D",e[e.SAMPLER_CUBE=35680]="SAMPLER_CUBE",e[e.LOW_FLOAT=36336]="LOW_FLOAT",e[e.MEDIUM_FLOAT=36337]="MEDIUM_FLOAT",e[e.HIGH_FLOAT=36338]="HIGH_FLOAT",e[e.LOW_INT=36339]="LOW_INT",e[e.MEDIUM_INT=36340]="MEDIUM_INT",e[e.HIGH_INT=36341]="HIGH_INT",e[e.FRAMEBUFFER=36160]="FRAMEBUFFER",e[e.RENDERBUFFER=36161]="RENDERBUFFER",e[e.RGBA4=32854]="RGBA4",e[e.RGB5_A1=32855]="RGB5_A1",e[e.RGB565=36194]="RGB565",e[e.DEPTH_COMPONENT16=33189]="DEPTH_COMPONENT16",e[e.STENCIL_INDEX=6401]="STENCIL_INDEX",e[e.STENCIL_INDEX8=36168]="STENCIL_INDEX8",e[e.DEPTH_STENCIL=34041]="DEPTH_STENCIL",e[e.RENDERBUFFER_WIDTH=36162]="RENDERBUFFER_WIDTH",e[e.RENDERBUFFER_HEIGHT=36163]="RENDERBUFFER_HEIGHT",e[e.RENDERBUFFER_INTERNAL_FORMAT=36164]="RENDERBUFFER_INTERNAL_FORMAT",e[e.RENDERBUFFER_RED_SIZE=36176]="RENDERBUFFER_RED_SIZE",e[e.RENDERBUFFER_GREEN_SIZE=36177]="RENDERBUFFER_GREEN_SIZE",e[e.RENDERBUFFER_BLUE_SIZE=36178]="RENDERBUFFER_BLUE_SIZE",e[e.RENDERBUFFER_ALPHA_SIZE=36179]="RENDERBUFFER_ALPHA_SIZE",e[e.RENDERBUFFER_DEPTH_SIZE=36180]="RENDERBUFFER_DEPTH_SIZE",e[e.RENDERBUFFER_STENCIL_SIZE=36181]="RENDERBUFFER_STENCIL_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE=36048]="FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME=36049]="FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL=36050]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE=36051]="FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",e[e.COLOR_ATTACHMENT0=36064]="COLOR_ATTACHMENT0",e[e.DEPTH_ATTACHMENT=36096]="DEPTH_ATTACHMENT",e[e.STENCIL_ATTACHMENT=36128]="STENCIL_ATTACHMENT",e[e.DEPTH_STENCIL_ATTACHMENT=33306]="DEPTH_STENCIL_ATTACHMENT",e[e.NONE=0]="NONE",e[e.FRAMEBUFFER_COMPLETE=36053]="FRAMEBUFFER_COMPLETE",e[e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT=36054]="FRAMEBUFFER_INCOMPLETE_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT=36055]="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",e[e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS=36057]="FRAMEBUFFER_INCOMPLETE_DIMENSIONS",e[e.FRAMEBUFFER_UNSUPPORTED=36061]="FRAMEBUFFER_UNSUPPORTED",e[e.FRAMEBUFFER_BINDING=36006]="FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_BINDING=36007]="RENDERBUFFER_BINDING",e[e.READ_FRAMEBUFFER=36008]="READ_FRAMEBUFFER",e[e.DRAW_FRAMEBUFFER=36009]="DRAW_FRAMEBUFFER",e[e.MAX_RENDERBUFFER_SIZE=34024]="MAX_RENDERBUFFER_SIZE",e[e.INVALID_FRAMEBUFFER_OPERATION=1286]="INVALID_FRAMEBUFFER_OPERATION",e[e.UNPACK_FLIP_Y_WEBGL=37440]="UNPACK_FLIP_Y_WEBGL",e[e.UNPACK_PREMULTIPLY_ALPHA_WEBGL=37441]="UNPACK_PREMULTIPLY_ALPHA_WEBGL",e[e.UNPACK_COLORSPACE_CONVERSION_WEBGL=37443]="UNPACK_COLORSPACE_CONVERSION_WEBGL",e[e.READ_BUFFER=3074]="READ_BUFFER",e[e.UNPACK_ROW_LENGTH=3314]="UNPACK_ROW_LENGTH",e[e.UNPACK_SKIP_ROWS=3315]="UNPACK_SKIP_ROWS",e[e.UNPACK_SKIP_PIXELS=3316]="UNPACK_SKIP_PIXELS",e[e.PACK_ROW_LENGTH=3330]="PACK_ROW_LENGTH",e[e.PACK_SKIP_ROWS=3331]="PACK_SKIP_ROWS",e[e.PACK_SKIP_PIXELS=3332]="PACK_SKIP_PIXELS",e[e.TEXTURE_BINDING_3D=32874]="TEXTURE_BINDING_3D",e[e.UNPACK_SKIP_IMAGES=32877]="UNPACK_SKIP_IMAGES",e[e.UNPACK_IMAGE_HEIGHT=32878]="UNPACK_IMAGE_HEIGHT",e[e.MAX_3D_TEXTURE_SIZE=32883]="MAX_3D_TEXTURE_SIZE",e[e.MAX_ELEMENTS_VERTICES=33e3]="MAX_ELEMENTS_VERTICES",e[e.MAX_ELEMENTS_INDICES=33001]="MAX_ELEMENTS_INDICES",e[e.MAX_TEXTURE_LOD_BIAS=34045]="MAX_TEXTURE_LOD_BIAS",e[e.MAX_FRAGMENT_UNIFORM_COMPONENTS=35657]="MAX_FRAGMENT_UNIFORM_COMPONENTS",e[e.MAX_VERTEX_UNIFORM_COMPONENTS=35658]="MAX_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_ARRAY_TEXTURE_LAYERS=35071]="MAX_ARRAY_TEXTURE_LAYERS",e[e.MIN_PROGRAM_TEXEL_OFFSET=35076]="MIN_PROGRAM_TEXEL_OFFSET",e[e.MAX_PROGRAM_TEXEL_OFFSET=35077]="MAX_PROGRAM_TEXEL_OFFSET",e[e.MAX_VARYING_COMPONENTS=35659]="MAX_VARYING_COMPONENTS",e[e.FRAGMENT_SHADER_DERIVATIVE_HINT=35723]="FRAGMENT_SHADER_DERIVATIVE_HINT",e[e.RASTERIZER_DISCARD=35977]="RASTERIZER_DISCARD",e[e.VERTEX_ARRAY_BINDING=34229]="VERTEX_ARRAY_BINDING",e[e.MAX_VERTEX_OUTPUT_COMPONENTS=37154]="MAX_VERTEX_OUTPUT_COMPONENTS",e[e.MAX_FRAGMENT_INPUT_COMPONENTS=37157]="MAX_FRAGMENT_INPUT_COMPONENTS",e[e.MAX_SERVER_WAIT_TIMEOUT=37137]="MAX_SERVER_WAIT_TIMEOUT",e[e.MAX_ELEMENT_INDEX=36203]="MAX_ELEMENT_INDEX",e[e.RED=6403]="RED",e[e.RGB8=32849]="RGB8",e[e.RGBA8=32856]="RGBA8",e[e.RGB10_A2=32857]="RGB10_A2",e[e.TEXTURE_3D=32879]="TEXTURE_3D",e[e.TEXTURE_WRAP_R=32882]="TEXTURE_WRAP_R",e[e.TEXTURE_MIN_LOD=33082]="TEXTURE_MIN_LOD",e[e.TEXTURE_MAX_LOD=33083]="TEXTURE_MAX_LOD",e[e.TEXTURE_BASE_LEVEL=33084]="TEXTURE_BASE_LEVEL",e[e.TEXTURE_MAX_LEVEL=33085]="TEXTURE_MAX_LEVEL",e[e.TEXTURE_COMPARE_MODE=34892]="TEXTURE_COMPARE_MODE",e[e.TEXTURE_COMPARE_FUNC=34893]="TEXTURE_COMPARE_FUNC",e[e.SRGB=35904]="SRGB",e[e.SRGB8=35905]="SRGB8",e[e.SRGB8_ALPHA8=35907]="SRGB8_ALPHA8",e[e.COMPARE_REF_TO_TEXTURE=34894]="COMPARE_REF_TO_TEXTURE",e[e.RGBA32F=34836]="RGBA32F",e[e.RGB32F=34837]="RGB32F",e[e.RGBA16F=34842]="RGBA16F",e[e.RGB16F=34843]="RGB16F",e[e.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",e[e.TEXTURE_BINDING_2D_ARRAY=35869]="TEXTURE_BINDING_2D_ARRAY",e[e.R11F_G11F_B10F=35898]="R11F_G11F_B10F",e[e.RGB9_E5=35901]="RGB9_E5",e[e.RGBA32UI=36208]="RGBA32UI",e[e.RGB32UI=36209]="RGB32UI",e[e.RGBA16UI=36214]="RGBA16UI",e[e.RGB16UI=36215]="RGB16UI",e[e.RGBA8UI=36220]="RGBA8UI",e[e.RGB8UI=36221]="RGB8UI",e[e.RGBA32I=36226]="RGBA32I",e[e.RGB32I=36227]="RGB32I",e[e.RGBA16I=36232]="RGBA16I",e[e.RGB16I=36233]="RGB16I",e[e.RGBA8I=36238]="RGBA8I",e[e.RGB8I=36239]="RGB8I",e[e.RED_INTEGER=36244]="RED_INTEGER",e[e.RGB_INTEGER=36248]="RGB_INTEGER",e[e.RGBA_INTEGER=36249]="RGBA_INTEGER",e[e.R8=33321]="R8",e[e.RG8=33323]="RG8",e[e.R16F=33325]="R16F",e[e.R32F=33326]="R32F",e[e.RG16F=33327]="RG16F",e[e.RG32F=33328]="RG32F",e[e.R8I=33329]="R8I",e[e.R8UI=33330]="R8UI",e[e.R16I=33331]="R16I",e[e.R16UI=33332]="R16UI",e[e.R32I=33333]="R32I",e[e.R32UI=33334]="R32UI",e[e.RG8I=33335]="RG8I",e[e.RG8UI=33336]="RG8UI",e[e.RG16I=33337]="RG16I",e[e.RG16UI=33338]="RG16UI",e[e.RG32I=33339]="RG32I",e[e.RG32UI=33340]="RG32UI",e[e.R8_SNORM=36756]="R8_SNORM",e[e.RG8_SNORM=36757]="RG8_SNORM",e[e.RGB8_SNORM=36758]="RGB8_SNORM",e[e.RGBA8_SNORM=36759]="RGBA8_SNORM",e[e.RGB10_A2UI=36975]="RGB10_A2UI",e[e.TEXTURE_IMMUTABLE_FORMAT=37167]="TEXTURE_IMMUTABLE_FORMAT",e[e.TEXTURE_IMMUTABLE_LEVELS=33503]="TEXTURE_IMMUTABLE_LEVELS",e[e.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",e[e.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",e[e.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",e[e.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",e[e.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",e[e.HALF_FLOAT=5131]="HALF_FLOAT",e[e.RG=33319]="RG",e[e.RG_INTEGER=33320]="RG_INTEGER",e[e.INT_2_10_10_10_REV=36255]="INT_2_10_10_10_REV",e[e.CURRENT_QUERY=34917]="CURRENT_QUERY",e[e.QUERY_RESULT=34918]="QUERY_RESULT",e[e.QUERY_RESULT_AVAILABLE=34919]="QUERY_RESULT_AVAILABLE",e[e.ANY_SAMPLES_PASSED=35887]="ANY_SAMPLES_PASSED",e[e.ANY_SAMPLES_PASSED_CONSERVATIVE=36202]="ANY_SAMPLES_PASSED_CONSERVATIVE",e[e.MAX_DRAW_BUFFERS=34852]="MAX_DRAW_BUFFERS",e[e.DRAW_BUFFER0=34853]="DRAW_BUFFER0",e[e.DRAW_BUFFER1=34854]="DRAW_BUFFER1",e[e.DRAW_BUFFER2=34855]="DRAW_BUFFER2",e[e.DRAW_BUFFER3=34856]="DRAW_BUFFER3",e[e.DRAW_BUFFER4=34857]="DRAW_BUFFER4",e[e.DRAW_BUFFER5=34858]="DRAW_BUFFER5",e[e.DRAW_BUFFER6=34859]="DRAW_BUFFER6",e[e.DRAW_BUFFER7=34860]="DRAW_BUFFER7",e[e.DRAW_BUFFER8=34861]="DRAW_BUFFER8",e[e.DRAW_BUFFER9=34862]="DRAW_BUFFER9",e[e.DRAW_BUFFER10=34863]="DRAW_BUFFER10",e[e.DRAW_BUFFER11=34864]="DRAW_BUFFER11",e[e.DRAW_BUFFER12=34865]="DRAW_BUFFER12",e[e.DRAW_BUFFER13=34866]="DRAW_BUFFER13",e[e.DRAW_BUFFER14=34867]="DRAW_BUFFER14",e[e.DRAW_BUFFER15=34868]="DRAW_BUFFER15",e[e.MAX_COLOR_ATTACHMENTS=36063]="MAX_COLOR_ATTACHMENTS",e[e.COLOR_ATTACHMENT1=36065]="COLOR_ATTACHMENT1",e[e.COLOR_ATTACHMENT2=36066]="COLOR_ATTACHMENT2",e[e.COLOR_ATTACHMENT3=36067]="COLOR_ATTACHMENT3",e[e.COLOR_ATTACHMENT4=36068]="COLOR_ATTACHMENT4",e[e.COLOR_ATTACHMENT5=36069]="COLOR_ATTACHMENT5",e[e.COLOR_ATTACHMENT6=36070]="COLOR_ATTACHMENT6",e[e.COLOR_ATTACHMENT7=36071]="COLOR_ATTACHMENT7",e[e.COLOR_ATTACHMENT8=36072]="COLOR_ATTACHMENT8",e[e.COLOR_ATTACHMENT9=36073]="COLOR_ATTACHMENT9",e[e.COLOR_ATTACHMENT10=36074]="COLOR_ATTACHMENT10",e[e.COLOR_ATTACHMENT11=36075]="COLOR_ATTACHMENT11",e[e.COLOR_ATTACHMENT12=36076]="COLOR_ATTACHMENT12",e[e.COLOR_ATTACHMENT13=36077]="COLOR_ATTACHMENT13",e[e.COLOR_ATTACHMENT14=36078]="COLOR_ATTACHMENT14",e[e.COLOR_ATTACHMENT15=36079]="COLOR_ATTACHMENT15",e[e.SAMPLER_3D=35679]="SAMPLER_3D",e[e.SAMPLER_2D_SHADOW=35682]="SAMPLER_2D_SHADOW",e[e.SAMPLER_2D_ARRAY=36289]="SAMPLER_2D_ARRAY",e[e.SAMPLER_2D_ARRAY_SHADOW=36292]="SAMPLER_2D_ARRAY_SHADOW",e[e.SAMPLER_CUBE_SHADOW=36293]="SAMPLER_CUBE_SHADOW",e[e.INT_SAMPLER_2D=36298]="INT_SAMPLER_2D",e[e.INT_SAMPLER_3D=36299]="INT_SAMPLER_3D",e[e.INT_SAMPLER_CUBE=36300]="INT_SAMPLER_CUBE",e[e.INT_SAMPLER_2D_ARRAY=36303]="INT_SAMPLER_2D_ARRAY",e[e.UNSIGNED_INT_SAMPLER_2D=36306]="UNSIGNED_INT_SAMPLER_2D",e[e.UNSIGNED_INT_SAMPLER_3D=36307]="UNSIGNED_INT_SAMPLER_3D",e[e.UNSIGNED_INT_SAMPLER_CUBE=36308]="UNSIGNED_INT_SAMPLER_CUBE",e[e.UNSIGNED_INT_SAMPLER_2D_ARRAY=36311]="UNSIGNED_INT_SAMPLER_2D_ARRAY",e[e.MAX_SAMPLES=36183]="MAX_SAMPLES",e[e.SAMPLER_BINDING=35097]="SAMPLER_BINDING",e[e.PIXEL_PACK_BUFFER=35051]="PIXEL_PACK_BUFFER",e[e.PIXEL_UNPACK_BUFFER=35052]="PIXEL_UNPACK_BUFFER",e[e.PIXEL_PACK_BUFFER_BINDING=35053]="PIXEL_PACK_BUFFER_BINDING",e[e.PIXEL_UNPACK_BUFFER_BINDING=35055]="PIXEL_UNPACK_BUFFER_BINDING",e[e.COPY_READ_BUFFER=36662]="COPY_READ_BUFFER",e[e.COPY_WRITE_BUFFER=36663]="COPY_WRITE_BUFFER",e[e.COPY_READ_BUFFER_BINDING=36662]="COPY_READ_BUFFER_BINDING",e[e.COPY_WRITE_BUFFER_BINDING=36663]="COPY_WRITE_BUFFER_BINDING",e[e.FLOAT_MAT2x3=35685]="FLOAT_MAT2x3",e[e.FLOAT_MAT2x4=35686]="FLOAT_MAT2x4",e[e.FLOAT_MAT3x2=35687]="FLOAT_MAT3x2",e[e.FLOAT_MAT3x4=35688]="FLOAT_MAT3x4",e[e.FLOAT_MAT4x2=35689]="FLOAT_MAT4x2",e[e.FLOAT_MAT4x3=35690]="FLOAT_MAT4x3",e[e.UNSIGNED_INT_VEC2=36294]="UNSIGNED_INT_VEC2",e[e.UNSIGNED_INT_VEC3=36295]="UNSIGNED_INT_VEC3",e[e.UNSIGNED_INT_VEC4=36296]="UNSIGNED_INT_VEC4",e[e.UNSIGNED_NORMALIZED=35863]="UNSIGNED_NORMALIZED",e[e.SIGNED_NORMALIZED=36764]="SIGNED_NORMALIZED",e[e.VERTEX_ATTRIB_ARRAY_INTEGER=35069]="VERTEX_ATTRIB_ARRAY_INTEGER",e[e.VERTEX_ATTRIB_ARRAY_DIVISOR=35070]="VERTEX_ATTRIB_ARRAY_DIVISOR",e[e.TRANSFORM_FEEDBACK_BUFFER_MODE=35967]="TRANSFORM_FEEDBACK_BUFFER_MODE",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS=35968]="MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",e[e.TRANSFORM_FEEDBACK_VARYINGS=35971]="TRANSFORM_FEEDBACK_VARYINGS",e[e.TRANSFORM_FEEDBACK_BUFFER_START=35972]="TRANSFORM_FEEDBACK_BUFFER_START",e[e.TRANSFORM_FEEDBACK_BUFFER_SIZE=35973]="TRANSFORM_FEEDBACK_BUFFER_SIZE",e[e.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN=35976]="TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN",e[e.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS=35978]="MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS=35979]="MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",e[e.INTERLEAVED_ATTRIBS=35980]="INTERLEAVED_ATTRIBS",e[e.SEPARATE_ATTRIBS=35981]="SEPARATE_ATTRIBS",e[e.TRANSFORM_FEEDBACK_BUFFER=35982]="TRANSFORM_FEEDBACK_BUFFER",e[e.TRANSFORM_FEEDBACK_BUFFER_BINDING=35983]="TRANSFORM_FEEDBACK_BUFFER_BINDING",e[e.TRANSFORM_FEEDBACK=36386]="TRANSFORM_FEEDBACK",e[e.TRANSFORM_FEEDBACK_PAUSED=36387]="TRANSFORM_FEEDBACK_PAUSED",e[e.TRANSFORM_FEEDBACK_ACTIVE=36388]="TRANSFORM_FEEDBACK_ACTIVE",e[e.TRANSFORM_FEEDBACK_BINDING=36389]="TRANSFORM_FEEDBACK_BINDING",e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING=33296]="FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING",e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE=33297]="FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE",e[e.FRAMEBUFFER_ATTACHMENT_RED_SIZE=33298]="FRAMEBUFFER_ATTACHMENT_RED_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE=33299]="FRAMEBUFFER_ATTACHMENT_GREEN_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE=33300]="FRAMEBUFFER_ATTACHMENT_BLUE_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE=33301]="FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE=33302]="FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE",e[e.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE=33303]="FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE",e[e.FRAMEBUFFER_DEFAULT=33304]="FRAMEBUFFER_DEFAULT",e[e.DEPTH24_STENCIL8=35056]="DEPTH24_STENCIL8",e[e.DRAW_FRAMEBUFFER_BINDING=36006]="DRAW_FRAMEBUFFER_BINDING",e[e.READ_FRAMEBUFFER_BINDING=36010]="READ_FRAMEBUFFER_BINDING",e[e.RENDERBUFFER_SAMPLES=36011]="RENDERBUFFER_SAMPLES",e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER=36052]="FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER",e[e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE=36182]="FRAMEBUFFER_INCOMPLETE_MULTISAMPLE",e[e.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",e[e.UNIFORM_BUFFER_BINDING=35368]="UNIFORM_BUFFER_BINDING",e[e.UNIFORM_BUFFER_START=35369]="UNIFORM_BUFFER_START",e[e.UNIFORM_BUFFER_SIZE=35370]="UNIFORM_BUFFER_SIZE",e[e.MAX_VERTEX_UNIFORM_BLOCKS=35371]="MAX_VERTEX_UNIFORM_BLOCKS",e[e.MAX_FRAGMENT_UNIFORM_BLOCKS=35373]="MAX_FRAGMENT_UNIFORM_BLOCKS",e[e.MAX_COMBINED_UNIFORM_BLOCKS=35374]="MAX_COMBINED_UNIFORM_BLOCKS",e[e.MAX_UNIFORM_BUFFER_BINDINGS=35375]="MAX_UNIFORM_BUFFER_BINDINGS",e[e.MAX_UNIFORM_BLOCK_SIZE=35376]="MAX_UNIFORM_BLOCK_SIZE",e[e.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS=35377]="MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",e[e.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS=35379]="MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS",e[e.UNIFORM_BUFFER_OFFSET_ALIGNMENT=35380]="UNIFORM_BUFFER_OFFSET_ALIGNMENT",e[e.ACTIVE_UNIFORM_BLOCKS=35382]="ACTIVE_UNIFORM_BLOCKS",e[e.UNIFORM_TYPE=35383]="UNIFORM_TYPE",e[e.UNIFORM_SIZE=35384]="UNIFORM_SIZE",e[e.UNIFORM_BLOCK_INDEX=35386]="UNIFORM_BLOCK_INDEX",e[e.UNIFORM_OFFSET=35387]="UNIFORM_OFFSET",e[e.UNIFORM_ARRAY_STRIDE=35388]="UNIFORM_ARRAY_STRIDE",e[e.UNIFORM_MATRIX_STRIDE=35389]="UNIFORM_MATRIX_STRIDE",e[e.UNIFORM_IS_ROW_MAJOR=35390]="UNIFORM_IS_ROW_MAJOR",e[e.UNIFORM_BLOCK_BINDING=35391]="UNIFORM_BLOCK_BINDING",e[e.UNIFORM_BLOCK_DATA_SIZE=35392]="UNIFORM_BLOCK_DATA_SIZE",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORMS=35394]="UNIFORM_BLOCK_ACTIVE_UNIFORMS",e[e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES=35395]="UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES",e[e.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER=35396]="UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER",e[e.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER=35398]="UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER",e[e.OBJECT_TYPE=37138]="OBJECT_TYPE",e[e.SYNC_CONDITION=37139]="SYNC_CONDITION",e[e.SYNC_STATUS=37140]="SYNC_STATUS",e[e.SYNC_FLAGS=37141]="SYNC_FLAGS",e[e.SYNC_FENCE=37142]="SYNC_FENCE",e[e.SYNC_GPU_COMMANDS_COMPLETE=37143]="SYNC_GPU_COMMANDS_COMPLETE",e[e.UNSIGNALED=37144]="UNSIGNALED",e[e.SIGNALED=37145]="SIGNALED",e[e.ALREADY_SIGNALED=37146]="ALREADY_SIGNALED",e[e.TIMEOUT_EXPIRED=37147]="TIMEOUT_EXPIRED",e[e.CONDITION_SATISFIED=37148]="CONDITION_SATISFIED",e[e.WAIT_FAILED=37149]="WAIT_FAILED",e[e.SYNC_FLUSH_COMMANDS_BIT=1]="SYNC_FLUSH_COMMANDS_BIT",e[e.COLOR=6144]="COLOR",e[e.DEPTH=6145]="DEPTH",e[e.STENCIL=6146]="STENCIL",e[e.MIN=32775]="MIN",e[e.MAX=32776]="MAX",e[e.DEPTH_COMPONENT24=33190]="DEPTH_COMPONENT24",e[e.STREAM_READ=35041]="STREAM_READ",e[e.STREAM_COPY=35042]="STREAM_COPY",e[e.STATIC_READ=35045]="STATIC_READ",e[e.STATIC_COPY=35046]="STATIC_COPY",e[e.DYNAMIC_READ=35049]="DYNAMIC_READ",e[e.DYNAMIC_COPY=35050]="DYNAMIC_COPY",e[e.DEPTH_COMPONENT32F=36012]="DEPTH_COMPONENT32F",e[e.DEPTH32F_STENCIL8=36013]="DEPTH32F_STENCIL8",e[e.INVALID_INDEX=4294967295]="INVALID_INDEX",e[e.TIMEOUT_IGNORED=-1]="TIMEOUT_IGNORED",e[e.MAX_CLIENT_WAIT_TIMEOUT_WEBGL=37447]="MAX_CLIENT_WAIT_TIMEOUT_WEBGL",e[e.UNMASKED_VENDOR_WEBGL=37445]="UNMASKED_VENDOR_WEBGL",e[e.UNMASKED_RENDERER_WEBGL=37446]="UNMASKED_RENDERER_WEBGL",e[e.MAX_TEXTURE_MAX_ANISOTROPY_EXT=34047]="MAX_TEXTURE_MAX_ANISOTROPY_EXT",e[e.TEXTURE_MAX_ANISOTROPY_EXT=34046]="TEXTURE_MAX_ANISOTROPY_EXT",e[e.R16_EXT=33322]="R16_EXT",e[e.RG16_EXT=33324]="RG16_EXT",e[e.RGB16_EXT=32852]="RGB16_EXT",e[e.RGBA16_EXT=32859]="RGBA16_EXT",e[e.R16_SNORM_EXT=36760]="R16_SNORM_EXT",e[e.RG16_SNORM_EXT=36761]="RG16_SNORM_EXT",e[e.RGB16_SNORM_EXT=36762]="RGB16_SNORM_EXT",e[e.RGBA16_SNORM_EXT=36763]="RGBA16_SNORM_EXT",e[e.COMPRESSED_RGB_S3TC_DXT1_EXT=33776]="COMPRESSED_RGB_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT=33777]="COMPRESSED_RGBA_S3TC_DXT1_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT=33778]="COMPRESSED_RGBA_S3TC_DXT3_EXT",e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT=33779]="COMPRESSED_RGBA_S3TC_DXT5_EXT",e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT=35916]="COMPRESSED_SRGB_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917]="COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918]="COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919]="COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",e[e.COMPRESSED_RED_RGTC1_EXT=36283]="COMPRESSED_RED_RGTC1_EXT",e[e.COMPRESSED_SIGNED_RED_RGTC1_EXT=36284]="COMPRESSED_SIGNED_RED_RGTC1_EXT",e[e.COMPRESSED_RED_GREEN_RGTC2_EXT=36285]="COMPRESSED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT=36286]="COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT",e[e.COMPRESSED_RGBA_BPTC_UNORM_EXT=36492]="COMPRESSED_RGBA_BPTC_UNORM_EXT",e[e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=36493]="COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT",e[e.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT=36494]="COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT",e[e.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT=36495]="COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT",e[e.COMPRESSED_R11_EAC=37488]="COMPRESSED_R11_EAC",e[e.COMPRESSED_SIGNED_R11_EAC=37489]="COMPRESSED_SIGNED_R11_EAC",e[e.COMPRESSED_RG11_EAC=37490]="COMPRESSED_RG11_EAC",e[e.COMPRESSED_SIGNED_RG11_EAC=37491]="COMPRESSED_SIGNED_RG11_EAC",e[e.COMPRESSED_RGB8_ETC2=37492]="COMPRESSED_RGB8_ETC2",e[e.COMPRESSED_RGBA8_ETC2_EAC=37493]="COMPRESSED_RGBA8_ETC2_EAC",e[e.COMPRESSED_SRGB8_ETC2=37494]="COMPRESSED_SRGB8_ETC2",e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37495]="COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37496]="COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37497]="COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG=35840]="COMPRESSED_RGB_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG=35842]="COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG=35841]="COMPRESSED_RGB_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG=35843]="COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",e[e.COMPRESSED_RGB_ETC1_WEBGL=36196]="COMPRESSED_RGB_ETC1_WEBGL",e[e.COMPRESSED_RGB_ATC_WEBGL=35986]="COMPRESSED_RGB_ATC_WEBGL",e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL=35986]="COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL=34798]="COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",e[e.COMPRESSED_RGBA_ASTC_4x4_KHR=37808]="COMPRESSED_RGBA_ASTC_4x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x4_KHR=37809]="COMPRESSED_RGBA_ASTC_5x4_KHR",e[e.COMPRESSED_RGBA_ASTC_5x5_KHR=37810]="COMPRESSED_RGBA_ASTC_5x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x5_KHR=37811]="COMPRESSED_RGBA_ASTC_6x5_KHR",e[e.COMPRESSED_RGBA_ASTC_6x6_KHR=37812]="COMPRESSED_RGBA_ASTC_6x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x5_KHR=37813]="COMPRESSED_RGBA_ASTC_8x5_KHR",e[e.COMPRESSED_RGBA_ASTC_8x6_KHR=37814]="COMPRESSED_RGBA_ASTC_8x6_KHR",e[e.COMPRESSED_RGBA_ASTC_8x8_KHR=37815]="COMPRESSED_RGBA_ASTC_8x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x5_KHR=37816]="COMPRESSED_RGBA_ASTC_10x5_KHR",e[e.COMPRESSED_RGBA_ASTC_10x6_KHR=37817]="COMPRESSED_RGBA_ASTC_10x6_KHR",e[e.COMPRESSED_RGBA_ASTC_10x8_KHR=37818]="COMPRESSED_RGBA_ASTC_10x8_KHR",e[e.COMPRESSED_RGBA_ASTC_10x10_KHR=37819]="COMPRESSED_RGBA_ASTC_10x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x10_KHR=37820]="COMPRESSED_RGBA_ASTC_12x10_KHR",e[e.COMPRESSED_RGBA_ASTC_12x12_KHR=37821]="COMPRESSED_RGBA_ASTC_12x12_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840]="COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR=37841]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR=37842]="COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR=37843]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR=37844]="COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR=37845]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR=37846]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR=37847]="COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR=37848]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR=37849]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR=37850]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR=37851]="COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR=37852]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR",e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR=37853]="COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR",e[e.QUERY_COUNTER_BITS_EXT=34916]="QUERY_COUNTER_BITS_EXT",e[e.CURRENT_QUERY_EXT=34917]="CURRENT_QUERY_EXT",e[e.QUERY_RESULT_EXT=34918]="QUERY_RESULT_EXT",e[e.QUERY_RESULT_AVAILABLE_EXT=34919]="QUERY_RESULT_AVAILABLE_EXT",e[e.TIME_ELAPSED_EXT=35007]="TIME_ELAPSED_EXT",e[e.TIMESTAMP_EXT=36392]="TIMESTAMP_EXT",e[e.GPU_DISJOINT_EXT=36795]="GPU_DISJOINT_EXT",e[e.COMPLETION_STATUS_KHR=37297]="COMPLETION_STATUS_KHR",e[e.DEPTH_CLAMP_EXT=34383]="DEPTH_CLAMP_EXT",e[e.FIRST_VERTEX_CONVENTION_WEBGL=36429]="FIRST_VERTEX_CONVENTION_WEBGL",e[e.LAST_VERTEX_CONVENTION_WEBGL=36430]="LAST_VERTEX_CONVENTION_WEBGL",e[e.PROVOKING_VERTEX_WEBL=36431]="PROVOKING_VERTEX_WEBL",e[e.POLYGON_MODE_WEBGL=2880]="POLYGON_MODE_WEBGL",e[e.POLYGON_OFFSET_LINE_WEBGL=10754]="POLYGON_OFFSET_LINE_WEBGL",e[e.LINE_WEBGL=6913]="LINE_WEBGL",e[e.FILL_WEBGL=6914]="FILL_WEBGL",e[e.MAX_CLIP_DISTANCES_WEBGL=3378]="MAX_CLIP_DISTANCES_WEBGL",e[e.MAX_CULL_DISTANCES_WEBGL=33529]="MAX_CULL_DISTANCES_WEBGL",e[e.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL=33530]="MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL",e[e.CLIP_DISTANCE0_WEBGL=12288]="CLIP_DISTANCE0_WEBGL",e[e.CLIP_DISTANCE1_WEBGL=12289]="CLIP_DISTANCE1_WEBGL",e[e.CLIP_DISTANCE2_WEBGL=12290]="CLIP_DISTANCE2_WEBGL",e[e.CLIP_DISTANCE3_WEBGL=12291]="CLIP_DISTANCE3_WEBGL",e[e.CLIP_DISTANCE4_WEBGL=12292]="CLIP_DISTANCE4_WEBGL",e[e.CLIP_DISTANCE5_WEBGL=12293]="CLIP_DISTANCE5_WEBGL",e[e.CLIP_DISTANCE6_WEBGL=12294]="CLIP_DISTANCE6_WEBGL",e[e.CLIP_DISTANCE7_WEBGL=12295]="CLIP_DISTANCE7_WEBGL",e[e.POLYGON_OFFSET_CLAMP_EXT=36379]="POLYGON_OFFSET_CLAMP_EXT",e[e.LOWER_LEFT_EXT=36001]="LOWER_LEFT_EXT",e[e.UPPER_LEFT_EXT=36002]="UPPER_LEFT_EXT",e[e.NEGATIVE_ONE_TO_ONE_EXT=37726]="NEGATIVE_ONE_TO_ONE_EXT",e[e.ZERO_TO_ONE_EXT=37727]="ZERO_TO_ONE_EXT",e[e.CLIP_ORIGIN_EXT=37724]="CLIP_ORIGIN_EXT",e[e.CLIP_DEPTH_MODE_EXT=37725]="CLIP_DEPTH_MODE_EXT",e[e.SRC1_COLOR_WEBGL=35065]="SRC1_COLOR_WEBGL",e[e.SRC1_ALPHA_WEBGL=34185]="SRC1_ALPHA_WEBGL",e[e.ONE_MINUS_SRC1_COLOR_WEBGL=35066]="ONE_MINUS_SRC1_COLOR_WEBGL",e[e.ONE_MINUS_SRC1_ALPHA_WEBGL=35067]="ONE_MINUS_SRC1_ALPHA_WEBGL",e[e.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL=35068]="MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL",e[e.MIRROR_CLAMP_TO_EDGE_EXT=34627]="MIRROR_CLAMP_TO_EDGE_EXT",e}(r||{})},3492:(e,n,t)=>{t.d(n,{$:()=>f,l:()=>p});var r=t(2444),i=t(3845),o=t(467),a=t(3522),s=t(3369),l=t(6769),c=t(8942);function u(e){return e.luma=e.luma||{},e.luma}function f(){return d.apply(this,arguments)}function d(){return(d=(0,o.A)((0,r.A)().m(function e(){return(0,r.A)().w(function(e){for(;;)switch(e.n){case 0:if(!(0,l.B)()||globalThis.WebGLDebugUtils){e.n=1;break}return globalThis.global=globalThis.global||globalThis,globalThis.global.module={},e.n=1,(0,c.k)("https://unpkg.com/webgl-debug@2.0.1/index.js");case 1:return e.a(2)}},e)}))).apply(this,arguments)}function p(e,n){return void 0===n&&(n={}),n.debugWebGL||n.traceWebGL?function(e,n){if(!globalThis.WebGLDebugUtils)return a.R.warn("webgl-debug not loaded")(),e;var t=u(e);if(t.debugContext)return t.debugContext;globalThis.WebGLDebugUtils.init(Object.assign({},s.GL,e));var r=globalThis.WebGLDebugUtils.makeDebugContext(e,m.bind(null,n),g.bind(null,n));for(var i in s.GL)i in r||"number"!=typeof s.GL[i]||(r[i]=s.GL[i]);var o=function(){};Object.setPrototypeOf(r,Object.getPrototypeOf(e)),Object.setPrototypeOf(o,r);var l=Object.create(o);return t.realContext=e,t.debugContext=l,l.debug=!0,l}(e,n):function(e){var n=u(e);return n.realContext?n.realContext:e}(e)}function h(e,n){n=Array.from(n).map(function(e){return void 0===e?"undefined":e});var t=globalThis.WebGLDebugUtils.glFunctionArgsToString(e,n);return"gl."+e+"("+(t=t.slice(0,100)+(t.length>100?"...":""))+")"}function m(e,n,t,r){r=Array.from(r).map(function(e){return void 0===e?"undefined":e});var i=globalThis.WebGLDebugUtils.glEnumToString(n)+" in gl."+t+"("+globalThis.WebGLDebugUtils.glFunctionArgsToString(t,r)+")";throw a.R.error("%cWebGL","color: white; background: red; padding: 2px 6px; border-radius: 3px;",i)(),new Error(i)}function g(e,n,t){var r="";e.traceWebGL&&a.R.level>=1&&(r=h(n,t),a.R.info(1,"%cWebGL","color: white; background: blue; padding: 2px 6px; border-radius: 3px;",r)());for(var o,s=(0,i.A)(t);!(o=s()).done;){void 0===o.value&&(r=r||h(n,t))}}},3522:(e,n,t)=>{t.d(n,{R:()=>r});var r=new(t(5593).t)({id:"luma.gl"})},3848:(e,n,t)=>{t.d(n,{PZ:()=>ei,gl:()=>ni,O0:()=>ri,MV:()=>ai,k9:()=>ui,zW:()=>fi,Jh:()=>ii,z6:()=>oi,yr:()=>si,LL:()=>qr,BA:()=>ci,_j:()=>Jr,YI:()=>$r,YE:()=>di,ZM:()=>pi,Z5:()=>ti,rq:()=>mi,yt:()=>hi,n5:()=>li});var r={};t.r(r),t.d(r,{_warp:()=>It,brightnessContrast:()=>ut,bulgePinch:()=>Pt,colorHalftone:()=>Tt,denoise:()=>ft,dotScreen:()=>bt,edgeWork:()=>xt,fxaa:()=>yt,hexagonalPixelate:()=>Rt,hueSaturation:()=>dt,ink:()=>Ct,magnify:()=>St,noise:()=>pt,sepia:()=>ht,swirl:()=>Nt,tiltShift:()=>vt,triangleBlur:()=>At,vibrance:()=>mt,vignette:()=>gt,zoomBlur:()=>Et});var i=t(6540),o=t(8482),a=t(3845),s=t(7387),l=t(5056),c=t(3522);function u(e){return Array.isArray(e)?0===e.length||"number"==typeof e[0]:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(e)}var f=function(){function e(e){if(this.uniforms={},this.modifiedUniforms={},this.modified=!0,this.bindingLayout={},this.needsRedraw="initialized",this.name=(null==e?void 0:e.name)||"unnamed",null!=e&&e.name&&null!=e&&e.shaderLayout){var n,t=null==e||null==(n=e.shaderLayout.bindings)?void 0:n.find(function(n){return"uniform"===n.type&&n.name===(null==e?void 0:e.name)});if(!t)throw new Error(null==e?void 0:e.name);for(var r,i=t,o=(0,a.A)(i.uniforms||[]);!(r=o()).done;){var s=r.value;this.bindingLayout[s.name]=s}}}var n=e.prototype;return n.setUniforms=function(e){for(var n=0,t=Object.entries(e);n<t.length;n++){var r=t[n],i=r[0],o=r[1];this._setUniform(i,o),this.needsRedraw||this.setNeedsRedraw(this.name+"."+i+"="+o)}},n.setNeedsRedraw=function(e){this.needsRedraw=this.needsRedraw||e},n.getAllUniforms=function(){return this.modifiedUniforms={},this.needsRedraw=!1,this.uniforms||{}},n._setUniform=function(e,n){var t;(function(e,n,t){if(void 0===t&&(t=16),e!==n)return!1;var r=e,i=n;if(!u(r))return!1;if(u(i)&&r.length===i.length)for(var o=0;o<r.length;++o)if(i[o]!==r[o])return!1;return!0})(this.uniforms[e],n)||(this.uniforms[e]=u(t=n)?t.slice():t,this.modifiedUniforms[e]=!0,this.modified=!0)},e}(),d=t(1425),p=t(1464),h=t(1649),m=function(){function e(e,n){void 0===n&&(n={}),this.layout={};for(var t=0,r=0,i=Object.entries(e);r<i.length;r++){var o,a=i[r],s=a[0],l=a[1];t=this._addToLayout(s,l,t,null==(o=n)?void 0:o[s])}t+=(4-t%4)%4,this.byteLength=Math.max(4*t,1024)}var n=e.prototype;return n.has=function(e){return Boolean(this.layout[e])},n.get=function(e){return this.layout[e]},n.getData=function(e){for(var n=(0,h.o)(this.byteLength),t={i32:new Int32Array(n),u32:new Uint32Array(n),f32:new Float32Array(n),f16:new Uint16Array(n)},r=0,i=Object.entries(e);r<i.length;r++){var o=i[r],a=o[0],s=o[1];this._writeCompositeValue(t,a,s)}return new Uint8Array(n,0,this.byteLength)},n._addToLayout=function(e,n,t,r){if(void 0===r&&(r=1),"string"==typeof n){var i=(0,p.k0)(n),o=i.components*r,a=(0,d.JP)(t,i.components);return this.layout[e]={offset:a,size:o,type:i.type},a+o}if(Array.isArray(n)){for(var s=n[0],l=r>1?r:n.length>1?n[1]:1,c=(0,d.JP)(t,4),u=0;u<l;u++)c=this._addToLayout(e+"["+u+"]",s,c);return c}if("object"==typeof n){for(var f=(0,d.JP)(t,4),h=0,m=Object.entries(n);h<m.length;h++){var g=m[h],_=g[0],v=g[1];f=this._addToLayout(e+"."+_,v,f)}return f}throw new Error("Unsupported CompositeShaderType for "+e)},n._writeCompositeValue=function(e,n,t){if(this.layout[n])this._writeToBuffer(e,n,t);else if(Array.isArray(t))for(var r=0;r<t.length;r++){var i=t[r],o=n+"["+r+"]";this._writeCompositeValue(e,o,i)}else if("object"!=typeof t||null===t)c.R.warn("Unsupported uniform value for "+n+":",t)();else for(var a=0,s=Object.entries(t);a<s.length;a++){var l=s[a],u=l[0],f=l[1],d=n+"."+u;this._writeCompositeValue(e,d,f)}},n._writeToBuffer=function(e,n,t){var r=this.layout[n];if(r){var i=r.type,o=r.size,a=r.offset,s=e[i];1===o?s[a]=Number(t):s.set(t,a)}else c.R.warn("Uniform "+n+" not found in layout")()},e}(),g=function(){function e(e){this.uniformBlocks=new Map,this.uniformBufferLayouts=new Map,this.uniformBuffers=new Map;for(var n=0,t=Object.entries(e);n<t.length;n++){var r,i,o=t[n],a=o[0],s=o[1],l=a,c=new m(null!=(r=s.uniformTypes)?r:{},null!=(i=s.uniformSizes)?i:{});this.uniformBufferLayouts.set(l,c);var u=new f({name:a});u.setUniforms(s.defaultUniforms||{}),this.uniformBlocks.set(l,u)}}var n=e.prototype;return n.destroy=function(){for(var e,n=(0,a.A)(this.uniformBuffers.values());!(e=n()).done;){e.value.destroy()}},n.setUniforms=function(e){for(var n=0,t=Object.entries(e);n<t.length;n++){var r,i=t[n],o=i[0],a=i[1];null==(r=this.uniformBlocks.get(o))||r.setUniforms(a)}this.updateUniformBuffers()},n.getUniformBufferByteLength=function(e){var n;return(null==(n=this.uniformBufferLayouts.get(e))?void 0:n.byteLength)||0},n.getUniformBufferData=function(e){var n,t,r=(null==(n=this.uniformBlocks.get(e))?void 0:n.getAllUniforms())||{};return null==(t=this.uniformBufferLayouts.get(e))?void 0:t.getData(r)},n.createUniformBuffer=function(e,n,t){t&&this.setUniforms(t);var r=this.getUniformBufferByteLength(n),i=e.createBuffer({usage:l.h.UNIFORM|l.h.COPY_DST,byteLength:r}),o=this.getUniformBufferData(n);return i.write(o),i},n.getManagedUniformBuffer=function(e,n){if(!this.uniformBuffers.get(n)){var t=this.getUniformBufferByteLength(n),r=e.createBuffer({usage:l.h.UNIFORM|l.h.COPY_DST,byteLength:t});this.uniformBuffers.set(n,r)}return this.uniformBuffers.get(n)},n.updateUniformBuffers=function(){for(var e,n=!1,t=(0,a.A)(this.uniformBlocks.keys());!(e=t()).done;){var r=e.value,i=this.updateUniformBuffer(r);n||(n=i)}return n&&c.R.log(3,"UniformStore.updateUniformBuffers(): "+n)(),n},n.updateUniformBuffer=function(e){var n=this.uniformBlocks.get(e),t=this.uniformBuffers.get(e),r=!1;if(t&&null!=n&&n.needsRedraw){var i,o;r||(r=n.needsRedraw);var a=this.getUniformBufferData(e);null==(i=t=this.uniformBuffers.get(e))||i.write(a);var s=null==(o=this.uniformBlocks.get(e))?void 0:o.getAllUniforms();c.R.log(4,"Writing to uniform buffer "+String(e),a,s)()}return r},e}();function _(){var e=1,n=1;return function(){return e=Math.sin(17.23*n),n=Math.cos(27.92*e),(t=1432.71*Math.abs(e*n))-Math.floor(t);var t}}var v=1,A=1,E=function(){function e(){this.time=0,this.channels=new Map,this.animations=new Map,this.playing=!1,this.lastEngineTime=-1}var n=e.prototype;return n.addChannel=function(e){var n=e.delay,t=void 0===n?0:n,r=e.duration,i=void 0===r?Number.POSITIVE_INFINITY:r,o=e.rate,a=void 0===o?1:o,s=e.repeat,l=v++,c={time:0,delay:t,duration:i,rate:a,repeat:void 0===s?1:s};return this._setChannelTime(c,this.time),this.channels.set(l,c),l},n.removeChannel=function(e){this.channels.delete(e);for(var n,t=(0,a.A)(this.animations);!(n=t()).done;){var r=n.value,i=r[0];r[1].channel===e&&this.detachAnimation(i)}},n.isFinished=function(e){var n=this.channels.get(e);return void 0!==n&&this.time>=n.delay+n.duration*n.repeat},n.getTime=function(e){if(void 0===e)return this.time;var n=this.channels.get(e);return void 0===n?-1:n.time},n.setTime=function(e){this.time=Math.max(0,e);for(var n,t=this.channels.values(),r=(0,a.A)(t);!(n=r()).done;){var i=n.value;this._setChannelTime(i,this.time)}for(var o,s=this.animations.values(),l=(0,a.A)(s);!(o=l()).done;){var c=o.value,u=c.animation,f=c.channel;u.setTime(this.getTime(f))}},n.play=function(){this.playing=!0},n.pause=function(){this.playing=!1,this.lastEngineTime=-1},n.reset=function(){this.setTime(0)},n.attachAnimation=function(e,n){var t=A++;return this.animations.set(t,{animation:e,channel:n}),e.setTime(this.getTime(n)),t},n.detachAnimation=function(e){this.animations.delete(e)},n.update=function(e){this.playing&&(-1===this.lastEngineTime&&(this.lastEngineTime=e),this.setTime(this.time+(e-this.lastEngineTime)),this.lastEngineTime=e)},n._setChannelTime=function(e,n){var t=n-e.delay;t>=e.duration*e.repeat?e.time=e.duration*e.rate:(e.time=Math.max(0,t)%e.duration,e.time*=e.rate)},e}(),T=function(){function e(e){this.startIndex=-1,this.endIndex=-1,this.factor=0,this.times=[],this.values=[],this._lastTime=-1,this.setKeyFrames(e),this.setTime(0)}var n=e.prototype;return n.setKeyFrames=function(e){var n=e.length;this.times.length=n,this.values.length=n;for(var t=0;t<n;++t)this.times[t]=e[t][0],this.values[t]=e[t][1];this._calculateKeys(this._lastTime)},n.setTime=function(e){(e=Math.max(0,e))!==this._lastTime&&(this._calculateKeys(e),this._lastTime=e)},n.getStartTime=function(){return this.times[this.startIndex]},n.getEndTime=function(){return this.times[this.endIndex]},n.getStartData=function(){return this.values[this.startIndex]},n.getEndData=function(){return this.values[this.endIndex]},n._calculateKeys=function(e){var n=0,t=this.times.length;for(n=0;n<t-2&&!(this.times[n+1]>e);++n);this.startIndex=n,this.endIndex=n+1;var r=this.times[this.startIndex],i=this.times[this.endIndex];this.factor=Math.min(Math.max(0,(e-r)/(i-r)),1)},e}(),b=t(8696),x=t(4353),R=t(7083),C=t(5768),S=t(2018),I=t(3145),P={number:{type:"number",validate:function(e,n){return Number.isFinite(e)&&"object"==typeof n&&(void 0===n.max||e<=n.max)&&(void 0===n.min||e>=n.min)}},array:{type:"array",validate:function(e,n){return Array.isArray(e)||ArrayBuffer.isView(e)}}};function N(e){var n=y(e);if("object"!==n)return Object.assign({value:e},P[n],{type:n});if("object"==typeof e)return e?void 0!==e.type?Object.assign({},e,P[e.type],{type:e.type}):void 0===e.value?{type:"object",value:e}:(n=y(e.value),Object.assign({},e,P[n],{type:n})):{type:"object",value:null};throw new Error("props")}function y(e){return Array.isArray(e)||ArrayBuffer.isView(e)?"array":typeof e}var L={vertex:"#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n",fragment:"#ifdef MODULE_MATERIAL\n  fragColor = material_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  fragColor = lighting_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_FOG\n  fragColor = fog_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  fragColor = picking_filterHighlightColor(fragColor);\n  fragColor = picking_filterPickingColor(fragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n"},F=/void\s+main\s*\([^)]*\)\s*\{\n?/,M=/}\n?[^{}]*$/,O=[],w="__LUMA_INJECT_DECLARATIONS__";function U(e){var n={vertex:{},fragment:{}};for(var t in e){var r=e[t];"string"==typeof r&&(r={order:0,injection:r}),n[D(t)][t]=r}return n}function D(e){var n=e.slice(0,2);switch(n){case"vs":return"vertex";case"fs":return"fragment";default:throw new Error(n)}}function B(e,n,t,r){void 0===r&&(r=!1);var i="vertex"===n,o=function(){var n=t[a];n.sort(function(e,n){return e.order-n.order}),O.length=n.length;for(var r=0,o=n.length;r<o;++r)O[r]=n[r].injection;var s=O.join("\n")+"\n";switch(a){case"vs:#decl":i&&(e=e.replace(w,s));break;case"vs:#main-start":i&&(e=e.replace(F,function(e){return e+s}));break;case"vs:#main-end":i&&(e=e.replace(M,function(e){return s+e}));break;case"fs:#decl":i||(e=e.replace(w,s));break;case"fs:#main-start":i||(e=e.replace(F,function(e){return e+s}));break;case"fs:#main-end":i||(e=e.replace(M,function(e){return s+e}));break;default:e=e.replace(a,function(e){return e+s})}};for(var a in t)o();return e=e.replace(w,""),r&&(e=e.replace(/\}\s*$/,function(e){return e+L[n]})),e}function G(e){e.map(function(e){return X(e)})}function X(e){if(!e.instance){G(e.dependencies||[]);var n=e.propTypes,t=void 0===n?{}:n,r=e.deprecations,i=void 0===r?[]:r,o=e.inject,a={normalizedInjections:U(void 0===o?{}:o),parsedDeprecations:V(i)};t&&(a.propValidators=function(e){for(var n={},t=0,r=Object.entries(e);t<r.length;t++){var i=r[t],o=i[0],a=i[1];n[o]=N(a)}return n}(t)),e.instance=a;var s={};t&&(s=Object.entries(t).reduce(function(e,n){var t=n[0],r=n[1],i=null==r?void 0:r.value;return i&&(e[t]=i),e},{})),e.defaultUniforms=Object.assign({},e.defaultUniforms,s)}}function H(e,n,t){var r;null==(r=e.deprecations)||r.forEach(function(e){var r;null!=(r=e.regex)&&r.test(n)&&(e.deprecated?t.deprecated(e.old,e.new)():t.removed(e.old,e.new)())})}function V(e){return e.forEach(function(e){if("function"===e.type)e.regex=new RegExp("\\b"+e.old+"\\(");else e.regex=new RegExp(e.type+" "+e.old+";")}),e}function k(e){G(e);var n={},t={};z({modules:e,level:0,moduleMap:n,moduleDepth:t});var r=Object.keys(t).sort(function(e,n){return t[n]-t[e]}).map(function(e){return n[e]});return G(r),r}function z(e){var n=e.modules,t=e.level,r=e.moduleMap,i=e.moduleDepth;if(t>=5)throw new Error("Possible loop in shader dependency graph");for(var o,s=(0,a.A)(n);!(o=s()).done;){var l=o.value;r[l.name]=l,(void 0===i[l.name]||i[l.name]<t)&&(i[l.name]=t)}for(var c,u=(0,a.A)(n);!(c=u()).done;){var f=c.value;f.dependencies&&z({modules:f.dependencies,level:t+1,moduleMap:r,moduleDepth:i})}}var j=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,"#version 300 es\n"],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],W=[].concat(j,[[K("attribute"),"in $1"],[K("varying"),"out $1"]]),Y=[].concat(j,[[K("varying"),"in $1"]]);function Q(e,n){for(var t,r=(0,a.A)(n);!(t=r()).done;){var i=t.value,o=i[0],s=i[1];e=e.replace(o,s)}return e}function K(e){return new RegExp("\\b"+e+"[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)","g")}function Z(e,n){var t="";for(var r in e){var i=e[r];if(t+="void "+i.signature+" {\n",i.header&&(t+="  "+i.header),n[r]){var o=n[r];o.sort(function(e,n){return e.order-n.order});for(var s,l=(0,a.A)(o);!(s=l()).done;){t+="  "+s.value.injection+"\n"}}i.footer&&(t+="  "+i.footer),t+="}\n"}return t}function q(e){for(var n,t={vertex:{},fragment:{}},r=(0,a.A)(e);!(n=r()).done;){var i=n.value,o=void 0,s=void 0;"string"!=typeof i?s=(o=i).hook:(o={},s=i);var l=(s=s.trim()).split(":"),c=l[0],u=l[1],f=s.replace(/\(.+/,""),d=Object.assign(o,{signature:u});switch(c){case"vs":t.vertex[f]=d;break;case"fs":t.fragment[f]=d;break;default:throw new Error(c)}}return t}function J(e,n){if(!e)throw new Error(n||"shadertools: assertion failed.")}function $(e,n){void 0===n&&(n="unnamed");var t=/#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(e);return t?t[1]:n}function ee(e){var n=100,t=e.match(/[^\s]+/g);if(t&&t.length>=2&&"#version"===t[0]){var r=parseInt(t[1],10);Number.isFinite(r)&&(n=r)}if(100!==n&&300!==n)throw new Error("Invalid GLSL version "+n);return n}var ne="\n\n"+w+"\n";function te(e,n){var t=n.source,r=n.stage,i=n.modules,o=n.hookFunctions,s=void 0===o?[]:o,l=n.inject,c=void 0===l?{}:l,u=n.log;J("string"==typeof t,"shader source must be a string");var f=t,d="",p=q(s),h={},m={},g={};for(var _ in c){var v="string"==typeof c[_]?{injection:c[_],order:0}:c[_],A=/^(v|f)s:(#)?([\w-]+)$/.exec(_);if(A){var E=A[2],T=A[3];E?"decl"===T?m[_]=[v]:g[_]=[v]:h[_]=[v]}else g[_]=[v]}for(var b,x=i,R=(0,a.A)(x);!(b=R()).done;){var C,S=b.value;u&&H(S,f,u),d+=oe(S,"wgsl");var I=(null==(C=S.injections)?void 0:C[r])||{};for(var P in I){var N=/^(v|f)s:#([\w-]+)$/.exec(P);if(N){var y="decl"===N[2]?m:g;y[P]=y[P]||[],y[P].push(I[P])}else h[P]=h[P]||[],h[P].push(I[P])}}return d=B(d+=ne,r,m),d+=Z(p[r],h),d=B(d+=f,r,g)}function re(e,n){var t=n.source,r=n.stage,i=n.language,o=void 0===i?"glsl":i,s=n.modules,l=n.defines,c=void 0===l?{}:l,u=n.hookFunctions,f=void 0===u?[]:u,d=n.inject,p=void 0===d?{}:d,h=n.prologue,m=void 0===h||h,g=n.log;J("string"==typeof t,"shader source must be a string");var _="glsl"===o?function(e,n){return{name:$(e,n),language:"glsl",version:ee(e)}}(t).version:-1,v=e.shaderLanguageVersion,A=100===_?"#version 100":"#version 300 es",E=t.split("\n").slice(1).join("\n"),T={};s.forEach(function(e){Object.assign(T,e.defines)}),Object.assign(T,c);var b="";switch(o){case"wgsl":break;case"glsl":b=m?A+"\n\n// ----- PROLOGUE -------------------------\n#define SHADER_TYPE_"+r.toUpperCase()+"\n\n"+function(e){switch(null==e?void 0:e.gpu.toLowerCase()){case"apple":return"#define APPLE_GPU\n// Apple optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"nvidia":return"#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";case"intel":return"#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";case"amd":return"#define AMD_GPU\n";default:return"#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Headless Chrome's software shader 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// If the GPU doesn't have full 32 bits precision, will causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n"}}(e)+"\n"+("fragment"===r?"precision highp float;\n":"")+"\n\n// ----- APPLICATION DEFINES -------------------------\n\n"+function(e){void 0===e&&(e={});var n="";for(var t in e){var r=e[t];(r||Number.isFinite(r))&&(n+="#define "+t.toUpperCase()+" "+e[t]+"\n")}return n}(T)+"\n\n":A+"\n"}var x=q(f),R={},C={},S={};for(var I in p){var P="string"==typeof p[I]?{injection:p[I],order:0}:p[I],N=/^(v|f)s:(#)?([\w-]+)$/.exec(I);if(N){var y=N[2],L=N[3];y?"decl"===L?C[I]=[P]:S[I]=[P]:R[I]=[P]}else S[I]=[P]}for(var F,M=(0,a.A)(s);!(F=M()).done;){var O,w=F.value;g&&H(w,E,g),b+=oe(w,r);var U=(null==(O=w.instance)?void 0:O.normalizedInjections[r])||{};for(var D in U){var G=/^(v|f)s:#([\w-]+)$/.exec(D);if(G){var X="decl"===G[2]?C:S;X[D]=X[D]||[],X[D].push(U[D])}else R[D]=R[D]||[],R[D].push(U[D])}}return b+="// ----- MAIN SHADER SOURCE -------------------------",b=B(b+=ne,r,C),b+=Z(x[r],R),b=B(b+=E,r,S),"glsl"===o&&_!==v&&(b=function(e,n){var t;if(300!==Number((null==(t=e.match(/^#version[ \t]+(\d+)/m))?void 0:t[1])||100))throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");switch(n){case"vertex":return Q(e,W);case"fragment":return Q(e,Y);default:throw new Error(n)}}(b,r)),b.trim()}function ie(e){return function(n){for(var t,r={},i=(0,a.A)(e);!(t=i()).done;){var o=t.value,s=null==o.getUniforms?void 0:o.getUniforms(n,r);Object.assign(r,s)}return r}}function oe(e,n){var t;switch(n){case"vertex":t=e.vs||"";break;case"fragment":t=e.fs||"";break;case"wgsl":t=e.source||"";break;default:J(!1)}if(!e.name)throw new Error("Shader module must have a name");var r=e.name.toUpperCase().replace(/[^0-9a-z]/gi,"_"),i="// ----- MODULE "+e.name+" ---------------\n\n";return"wgsl"!==n&&(i+="#define MODULE_"+r+"\n"),i+=t+"\n"}var ae=/^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/,se=/^\s*\#\s*endif\s*$/;var le=function(){function e(){this._hookFunctions=[],this._defaultModules=[]}e.getDefaultShaderAssembler=function(){return e.defaultShaderAssembler=e.defaultShaderAssembler||new e,e.defaultShaderAssembler};var n=e.prototype;return n.addDefaultModule=function(e){this._defaultModules.find(function(n){return n.name===("string"==typeof e?e:e.name)})||this._defaultModules.push(e)},n.removeDefaultModule=function(e){var n="string"==typeof e?e:e.name;this._defaultModules=this._defaultModules.filter(function(e){return e.name!==n})},n.addShaderHook=function(e,n){n&&(e=Object.assign(n,{hook:e})),this._hookFunctions.push(e)},n.assembleWGSLShader=function(e){var n=this._getModuleList(e.modules),t=this._hookFunctions,r=function(e){var n=k(e.modules||[]);return{source:te(e.platformInfo,Object.assign({},e,{source:e.source,stage:"vertex",modules:n})),getUniforms:ie(n)}}(Object.assign({},e,{source:e.source,modules:n,hookFunctions:t})),i=r.source,o=r.getUniforms,s="wgsl"===e.platformInfo.shaderLanguage?function(e,n){for(var t,r=e.split("\n"),i=[],o=!0,s=null,l=(0,a.A)(r);!(t=l()).done;){var c,u=t.value,f=u.match(ae),d=u.match(se);f?(s=f[1],o=Boolean(null==n||null==(c=n.defines)?void 0:c[s])):d?o=!0:o&&i.push(u)}return i.join("\n")}(i):i;return{source:s,getUniforms:o,modules:n}},n.assembleGLSLShaderPair=function(e){var n=this._getModuleList(e.modules),t=this._hookFunctions,r=function(e){var n=e.vs,t=e.fs,r=k(e.modules||[]);return{vs:re(e.platformInfo,Object.assign({},e,{source:n,stage:"vertex",modules:r})),fs:re(e.platformInfo,Object.assign({},e,{source:t,stage:"fragment",modules:r})),getUniforms:ie(r)}}(Object.assign({},e,{vs:e.vs,fs:e.fs,modules:n,hookFunctions:t}));return Object.assign({},r,{modules:n})},n._getModuleList=function(e){void 0===e&&(e=[]);for(var n=new Array(this._defaultModules.length+e.length),t={},r=0,i=0,o=this._defaultModules.length;i<o;++i){var a=this._defaultModules[i],s=a.name;n[r++]=a,t[s]=!0}for(var l=0,c=e.length;l<c;++l){var u=e[l],f=u.name;t[f]||(n[r++]=u,t[f]=!0)}return n.length=r,G(n),n},e}(),ce=t(1990),ue={};function fe(e){return void 0===e&&(e="id"),ue[e]=ue[e]||1,e+"-"+ue[e]++}var de=function(){function e(e){if(this.userData={},this.bufferLayout=[],this.id=e.id||fe("geometry"),this.topology=e.topology,this.indices=e.indices||null,this.attributes=e.attributes,this.vertexCount=e.vertexCount,this.bufferLayout=e.bufferLayout||[],this.indices&&!(this.indices.usage&l.h.INDEX))throw new Error("Index buffer must have INDEX usage")}var n=e.prototype;return n.destroy=function(){var e;null==(e=this.indices)||e.destroy();for(var n=0,t=Object.values(this.attributes);n<t.length;n++){t[n].destroy()}},n.getVertexCount=function(){return this.vertexCount},n.getAttributes=function(){return this.attributes},n.getIndexes=function(){return this.indices||null},n._calculateVertexCount=function(e){return e.byteLength/12},e}();function pe(e,n){if(n instanceof de)return n;var t=function(e,n){if(!n.indices)return;var t=n.indices.value;return e.createBuffer({usage:l.h.INDEX,data:t})}(e,n),r=function(e,n){for(var t=[],r={},i=0,o=Object.entries(n.attributes);i<o.length;i++){var a=o[i],s=a[0],l=a[1],c=s;switch(s){case"POSITION":c="positions";break;case"NORMAL":c="normals";break;case"TEXCOORD_0":c="texCoords";break;case"COLOR_0":c="colors"}if(l){r[c]=e.createBuffer({data:l.value,id:s+"-buffer"});var u=l.value,f=l.size,d=l.normalized;t.push({name:c,format:(0,ce.OB)(u,f,d)})}}var p=n._calculateVertexCount(n.attributes,n.indices);return{attributes:r,bufferLayout:t,vertexCount:p}}(e,n),i=r.attributes,o=r.bufferLayout;return new de({topology:n.topology||"triangle-list",bufferLayout:o,vertexCount:n.vertexCount,indices:t,attributes:i})}var he=t(9316),me=function(){function e(e){this._hashCounter=0,this._hashes={},this._renderPipelineCache={},this._computePipelineCache={},this.device=e,this.cachingEnabled=e.props._cachePipelines,this.destroyPolicy=e.props._cacheDestroyPolicy,this.debug=e.props.debugFactories}e.getDefaultPipelineFactory=function(n){return n._lumaData.defaultPipelineFactory=n._lumaData.defaultPipelineFactory||new e(n),n._lumaData.defaultPipelineFactory};var n=e.prototype;return n.toString=function(){return"PipelineFactory("+this.device.id+")"},n.createRenderPipeline=function(e){var n;if(!this.cachingEnabled)return this.device.createRenderPipeline(e);var t=Object.assign({},I.r.defaultProps,e),r=this._renderPipelineCache,i=this._hashRenderPipeline(t),o=null==(n=r[i])?void 0:n.pipeline;return o?(r[i].useCount++,this.debug&&c.R.warn(this+": "+r[i].pipeline+" reused, count="+r[i].useCount+", (id="+e.id+")")()):((o=this.device.createRenderPipeline(Object.assign({},t,{id:t.id?t.id+"-cached":fe("unnamed-cached")}))).hash=i,r[i]={pipeline:o,useCount:1},this.debug&&c.R.warn(this+": "+o+" created, count="+r[i].useCount)()),o},n.createComputePipeline=function(e){var n;if(!this.cachingEnabled)return this.device.createComputePipeline(e);var t=Object.assign({},he.C.defaultProps,e),r=this._computePipelineCache,i=this._hashComputePipeline(t),o=null==(n=r[i])?void 0:n.pipeline;return o?(r[i].useCount++,this.debug&&c.R.warn(this+": "+r[i].pipeline+" reused, count="+r[i].useCount+", (id="+e.id+")")()):((o=this.device.createComputePipeline(Object.assign({},t,{id:t.id?t.id+"-cached":void 0}))).hash=i,r[i]={pipeline:o,useCount:1},this.debug&&c.R.warn(this+": "+o+" created, count="+r[i].useCount)()),o},n.release=function(e){if(this.cachingEnabled){var n=this._getCache(e),t=e.hash;n[t].useCount--,0===n[t].useCount?(this._destroyPipeline(e),this.debug&&c.R.warn(this+": "+e+" released and destroyed")()):n[t].useCount<0?(c.R.error(this+": "+e+" released, useCount < 0, resetting")(),n[t].useCount=0):this.debug&&c.R.warn(this+": "+e+" released, count="+n[t].useCount)()}else e.destroy()},n._destroyPipeline=function(e){var n=this._getCache(e);switch(this.destroyPolicy){case"never":return!1;case"unused":return delete n[e.hash],e.destroy(),!0}},n._getCache=function(e){var n;if(e instanceof he.C&&(n=this._computePipelineCache),e instanceof I.r&&(n=this._renderPipelineCache),!n)throw new Error(""+this);if(!n[e.hash])throw new Error(this+": "+e+" matched incorrect entry");return n},n._hashComputePipeline=function(e){return this.device.type+"/C/"+this._getHash(e.shader.source)},n._hashRenderPipeline=function(e){var n=e.vs?this._getHash(e.vs.source):0,t=e.fs?this._getHash(e.fs.source):0,r=this._getHash(JSON.stringify(e.bufferLayout)),i=this.device.type;if("webgl"===i)return i+"/R/"+n+"/"+t+"V-BL"+r;var o=this._getHash(JSON.stringify(e.parameters));return i+"/R/"+n+"/"+t+"V-T"+e.topology+"P"+o+"BL"+r},n._getHash=function(e){return void 0===this._hashes[e]&&(this._hashes[e]=this._hashCounter++),this._hashes[e]},(0,b.A)(e,[{key:Symbol.toStringTag,get:function(){return"PipelineFactory"}}])}();me.defaultProps=Object.assign({},I.r.defaultProps);var ge=t(7468),_e=function(){function e(e){this._cache={},this.device=e,this.cachingEnabled=e.props._cacheShaders,this.destroyPolicy=e.props._cacheDestroyPolicy,this.debug=!0}e.getDefaultShaderFactory=function(n){var t;return(t=n._lumaData)["defaultShaderFactory"]||(t.defaultShaderFactory=new e(n)),n._lumaData.defaultShaderFactory};var n=e.prototype;return n.toString=function(){return this[Symbol.toStringTag]+"("+this.device.id+")"},n.createShader=function(e){if(!this.cachingEnabled)return this.device.createShader(e);var n=this._hashShader(e),t=this._cache[n];if(t)t.useCount++,this.debug&&c.R.warn(this+": Reusing shader "+t.shader.id+" count="+t.useCount)();else{var r=this.device.createShader(Object.assign({},e,{id:e.id?e.id+"-cached":void 0}));this._cache[n]=t={shader:r,useCount:1},this.debug&&c.R.warn(this+": Created new shader "+r.id)()}return t.shader},n.release=function(e){if(this.cachingEnabled){var n=this._hashShader(e),t=this._cache[n];if(t)if(t.useCount--,0===t.useCount)"unused"===this.destroyPolicy&&(delete this._cache[n],t.shader.destroy(),this.debug&&c.R.warn(this+": Releasing shader "+e.id+", destroyed")());else{if(t.useCount<0)throw new Error("ShaderFactory: Shader "+e.id+" released too many times");this.debug&&c.R.warn(this+": Releasing shader "+e.id+" count="+t.useCount)()}}else e.destroy()},n._hashShader=function(e){return e.stage+":"+e.source},(0,b.A)(e,[{key:Symbol.toStringTag,get:function(){return"ShaderFactory"}}])}();_e.defaultProps=Object.assign({},ge.M.defaultProps);var ve=null,Ae=null;function Ee(e,n,t){if(e===n)return!0;if(!t||!e||!n)return!1;if(Array.isArray(e)){if(!Array.isArray(n)||e.length!==n.length)return!1;for(var r=0;r<e.length;r++)if(!Ee(e[r],n[r],t-1))return!1;return!0}if(Array.isArray(n))return!1;if("object"==typeof e&&"object"==typeof n){var i=Object.keys(e),o=Object.keys(n);if(i.length!==o.length)return!1;for(var a=0,s=i;a<s.length;a++){var l=s[a];if(!n.hasOwnProperty(l))return!1;if(!Ee(e[l],n[l],t-1))return!1}return!0}return!1}var Te=function(){function e(e){this.bufferLayouts=e}var n=e.prototype;return n.getBufferLayout=function(e){return this.bufferLayouts.find(function(n){return n.name===e})||null},n.getAttributeNamesForBuffer=function(e){var n;return e.attributes?null==(n=e.attributes)?void 0:n.map(function(e){return e.attribute}):[e.name]},n.mergeBufferLayouts=function(e,n){for(var t,r=[].concat(e),i=function(){var e=t.value,n=r.findIndex(function(n){return n.name===e.name});n<0?r.push(e):r[n]=e},o=(0,a.A)(n);!(t=o()).done;)i();return r},n.getBufferIndex=function(e){var n=this.bufferLayouts.findIndex(function(n){return n.name===e});return-1===n&&c.R.warn('BufferLayout: Missing buffer for "'+e+'".')(),n},e}();var be=t(6282);function xe(e){var n={bindings:{},uniforms:{}};return Object.keys(e).forEach(function(t){var r,i=e[t];r=i,(0,be.H9)(r)||"number"==typeof r||"boolean"==typeof r?n.uniforms[t]=i:n.bindings[t]=i}),n}var Re=function(){function e(e,n){this.options={disableWarnings:!1},Object.assign(this.options,n);for(var t,r=k(Object.values(e).filter(function(e){return e.dependencies})),i=(0,a.A)(r);!(t=i()).done;){var o=t.value;e[o.name]=o}c.R.log(1,"Creating ShaderInputs with modules",Object.keys(e))(),this.modules=e,this.moduleUniforms={},this.moduleBindings={};for(var s=0,l=Object.entries(e);s<l.length;s++){var u=l[s],f=u[0],d=u[1];this._addModule(d),d.name&&f!==d.name&&!this.options.disableWarnings&&c.R.warn("Module name: "+f+" vs "+d.name)()}}var n=e.prototype;return n.destroy=function(){},n.setProps=function(e){for(var n=0,t=Object.keys(e);n<t.length;n++){var r=t[n],i=r,o=e[i]||{},a=this.modules[i];if(a){var s=this.moduleUniforms[i],l=this.moduleBindings[i],u=xe((null==a.getUniforms?void 0:a.getUniforms(o,s))||o),f=u.uniforms,d=u.bindings;this.moduleUniforms[i]=Object.assign({},s,f),this.moduleBindings[i]=Object.assign({},l,d)}else this.options.disableWarnings||c.R.warn("Module "+r+" not found")()}},n.getModules=function(){return Object.values(this.modules)},n.getUniformValues=function(){return this.moduleUniforms},n.getBindingValues=function(){for(var e={},n=0,t=Object.values(this.moduleBindings);n<t.length;n++){var r=t[n];Object.assign(e,r)}return e},n.getDebugTable=function(){for(var e={},n=0,t=Object.entries(this.moduleUniforms);n<t.length;n++)for(var r=t[n],i=r[0],o=r[1],a=0,s=Object.entries(o);a<s.length;a++){var l,c=s[a],u=c[0],f=c[1];e[i+"."+u]={type:null==(l=this.modules[i].uniformTypes)?void 0:l[u],value:String(f)}}return e},n._addModule=function(e){var n=e.name;this.moduleUniforms[n]=e.defaultUniforms||{},this.moduleBindings[n]={}},e}(),Ce=t(2444),Se=t(467),Ie=t(9141),Pe={"+X":0,"-X":1,"+Y":2,"-Y":3,"+Z":4,"-Z":5};function Ne(e){var n;return e?Array.isArray(e)?null!=(n=e[0])?n:null:e:null}function ye(e){var n=e.dimension,t=e.data;if(!t)return null;switch(n){case"1d":var r=Ne(t);return r?{width:Le(r).width,height:1}:null;case"2d":var i=Ne(t);return i?Le(i):null;case"3d":case"2d-array":if(!Array.isArray(t)||0===t.length)return null;var o=Ne(t[0]);return o?Le(o):null;case"cube":var a,s=null!=(a=Object.keys(t)[0])?a:null;if(!s)return null;var l=Ne(t[s]);return l?Le(l):null;case"cube-array":var c;if(!Array.isArray(t)||0===t.length)return null;var u=t[0],f=null!=(c=Object.keys(u)[0])?c:null;if(!f)return null;var d=Ne(u[f]);return d?Le(d):null;default:return null}}function Le(e){if((0,Ie.x)(e))return(0,Ie.c)(e);if("object"==typeof e&&"width"in e&&"height"in e)return{width:e.width,height:e.height};throw new Error("Unsupported mip-level data")}function Fe(e){return"object"==typeof e&&null!==e&&"data"in e&&"width"in e&&"height"in e}function Me(e){var n=Pe[e];if(void 0===n)throw new Error("Invalid cube face: "+e);return n}function Oe(e,n){return 6*e+Me(n)}function we(e,n){for(var t,r=(t=n,Array.isArray(t)?t:[t]),i=e,o=[],a=0;a<r.length;a++){var s=r[a];if((0,Ie.x)(s))o.push({type:"external-image",image:s,z:i,mipLevel:a});else{if(!Fe(s))throw new Error("Unsupported 2D mip-level payload");o.push({type:"texture-data",data:s,z:i,mipLevel:a})}}return o}var Ue=function(){function e(n,t){var r=this;this._texture=null,this._sampler=null,this._view=null,this.isReady=!1,this.destroyed=!1,this.resolveReady=function(){},this.rejectReady=function(){},this.device=n;var i=fe("dynamic-texture"),o=t;this.props=Object.assign({},e.defaultProps,{id:i},t,{data:null}),this.id=this.props.id,this.ready=new Promise(function(e,n){r.resolveReady=e,r.rejectReady=n}),this.initAsync(o)}var n=e.prototype;return n.toString=function(){return'DynamicTexture:"'+this.id+'":'+this.texture.width+"x"+this.texture.height+"px:("+(this.isReady?"ready":"loading...")+")"},n.initAsync=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i,o,a,s,l,u,f,d,p,h=this;return(0,Ce.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:return e.p=0,e.n=1,this._loadAllData(n);case 1:if(r=e.v,this._checkNotDestroyed(),i=function(){if(h.props.width&&h.props.height)return{width:h.props.width,height:h.props.height};var e=ye(r);return e||{width:h.props.width||1,height:h.props.height||1}},!(!(o=i())||o.width<=0||o.height<=0)){e.n=2;break}throw new Error(this+" size could not be determined or was zero");case 2:if(a=Object.assign({},this.props,o,{mipLevels:1,data:void 0}),s=this.device.getMipLevelCount(a.width,a.height),l="auto"===this.props.mipLevels?s:Math.max(1,Math.min(s,null!=(t=this.props.mipLevels)?t:1)),u=Object.assign({},a,{mipLevels:l}),this._texture=this.device.createTexture(u),this._sampler=this.texture.sampler,this._view=this.texture.view,!r.data){e.n=10;break}d=r.dimension,e.n="1d"===d?3:"2d"===d?4:"3d"===d?5:"2d-array"===d?6:"cube"===d?7:"cube-array"===d?8:9;break;case 3:return this.setTexture1DData(r.data),e.a(3,10);case 4:return this.setTexture2DData(r.data),e.a(3,10);case 5:return this.setTexture3DData(r.data),e.a(3,10);case 6:return this.setTextureArrayData(r.data),e.a(3,10);case 7:return this.setTextureCubeData(r.data),e.a(3,10);case 8:return this.setTextureCubeArrayData(r.data),e.a(3,10);case 9:throw new Error("Unhandled dimension "+r.dimension);case 10:this.props.mipmaps&&this.generateMipmaps(),this.isReady=!0,this.resolveReady(this.texture),c.R.info(0,this+" created")(),e.n=12;break;case 11:throw e.p=11,p=e.v,f=p instanceof Error?p:new Error(String(p)),this.rejectReady(f),f;case 12:return e.a(2)}},e,this,[[0,11]])}));return function(n){return e.apply(this,arguments)}}(),n.destroy=function(){this._texture&&(this._texture.destroy(),this._texture=null,this._sampler=null,this._view=null),this.destroyed=!0},n.generateMipmaps=function(){if("webgl"!==this.device.type)throw new Error("Automatic mipmap generation not supported on this device");this.texture.generateMipmapsWebGL()},n.setSampler=function(e){void 0===e&&(e={}),this._checkReady();var n=e instanceof C.L?e:this.device.createSampler(e);this.texture.setSampler(n),this._sampler=n},n.resize=function(e){if(this._checkReady(),e.width===this.texture.width&&e.height===this.texture.height)return!1;var n=this.texture;return this._texture=n.clone(e),this._sampler=this.texture.sampler,this._view=this.texture.view,n.destroy(),c.R.info(this+" resized"),!0},n.getCubeFaceIndex=function(e){var n=Pe[e];if(void 0===n)throw new Error("Invalid cube face: "+e);return n},n.getCubeArrayFaceIndex=function(e,n){return 6*e+this.getCubeFaceIndex(n)},n.setTexture1DData=function(e){if(this._checkReady(),"1d"!==this.texture.props.dimension)throw new Error(this+" is not 1d");var n=function(){throw new Error("setTexture1DData not supported in WebGL.")}();this._setTextureSubresources(n)},n.setTexture2DData=function(e,n){if(void 0===n&&(n=0),this._checkReady(),"2d"!==this.texture.props.dimension)throw new Error(this+" is not 2d");var t=we(n,e);this._setTextureSubresources(t)},n.setTexture3DData=function(e){if("3d"!==this.texture.props.dimension)throw new Error(this+" is not 3d");var n=function(e){for(var n=[],t=0;t<e.length;t++)n.push.apply(n,we(t,e[t]));return n}(e);this._setTextureSubresources(n)},n.setTextureArrayData=function(e){if("2d-array"!==this.texture.props.dimension)throw new Error(this+" is not 2d-array");var n=function(e){for(var n=[],t=0;t<e.length;t++)n.push.apply(n,we(t,e[t]));return n}(e);this._setTextureSubresources(n)},n.setTextureCubeData=function(e){if("cube"!==this.texture.props.dimension)throw new Error(this+" is not cube");var n=function(e){for(var n=[],t=0,r=Object.entries(e);t<r.length;t++){var i=r[t],o=i[0],a=i[1],s=Me(o);n.push.apply(n,we(s,a))}return n}(e);this._setTextureSubresources(n)},n.setTextureCubeArrayData=function(e){if("cube-array"!==this.texture.props.dimension)throw new Error(this+" is not cube-array");var n=function(e){return e.forEach(function(e,n){for(var t=0,r=Object.entries(e);t<r.length;t++){var i=r[t],o=i[0],a=i[1];we(Oe(n,o),a)}}),[]}(e);this._setTextureSubresources(n)},n._setTextureSubresources=function(e){for(var n,t=(0,a.A)(e);!(n=t()).done;){var r=n.value,i=r.z,o=r.mipLevel;switch(r.type){case"external-image":var s=r.image,l=r.flipY;this.texture.copyExternalImage({image:s,z:i,mipLevel:o,flipY:l});break;case"texture-data":var c=r.data;this.texture.copyImageData({data:c.data,z:i,mipLevel:o});break;default:throw new Error("Unsupported 2D mip-level payload")}}},n._loadAllData=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,De(n.data);case 1:return r=e.v,i=null!=(t=n.dimension)?t:"2d",e.a(2,{dimension:i,data:null!=r?r:null})}},e)}));return function(n){return e.apply(this,arguments)}}(),n._checkNotDestroyed=function(){this.destroyed&&c.R.warn(this+" already destroyed")},n._checkReady=function(){this.isReady||c.R.warn(this+" Cannot perform this operation before ready")},(0,b.A)(e,[{key:"texture",get:function(){if(!this._texture)throw new Error("Texture not initialized yet");return this._texture}},{key:"sampler",get:function(){if(!this._sampler)throw new Error("Sampler not initialized yet");return this._sampler}},{key:"view",get:function(){if(!this._view)throw new Error("View not initialized yet");return this._view}},{key:Symbol.toStringTag,get:function(){return"DynamicTexture"}}])}();function De(e){return Be.apply(this,arguments)}function Be(){return Be=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i,o,a;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,n;case 1:if(n=e.v,!Array.isArray(n)){e.n=3;break}return e.n=2,Promise.all(n.map(De));case 2:return e.a(2,e.v);case 3:if(!n||"object"!=typeof n||n.constructor!==Object){e.n=5;break}return t=n,e.n=4,Promise.all(Object.values(t));case 4:for(r=e.v,i=Object.keys(t),o={},a=0;a<i.length;a++)o[i[a]]=r[a];return e.a(2,o);case 5:return e.a(2,n)}},e)})),Be.apply(this,arguments)}Ue.defaultProps=Object.assign({},R.g.defaultProps,{dimension:"2d",data:null,mipmaps:!1});var Ge=function(){function e(n,t){var r,i,o;this.userData={},this.isInstanced=void 0,this.instanceCount=0,this.indexBuffer=null,this.bufferAttributes={},this.constantAttributes={},this.bindings={},this.transformFeedback=null,this._attributeInfos={},this._gpuGeometry=null,this._pipelineNeedsUpdate="newly created",this._needsRedraw="initializing",this._destroyed=!1,this._lastDrawTimestamp=-1,this._lastLogTime=0,this._logOpen=!1,this._drawCount=0,this.props=Object.assign({},e.defaultProps,t),t=this.props,this.id=t.id||fe("model"),this.device=n,Object.assign(this.userData,t.userData);var a=Object.fromEntries((null==(r=this.props.modules)?void 0:r.map(function(e){return[e.name,e]}))||[]),s=t.shaderInputs||new Re(a,{disableWarnings:this.props.disableWarnings});this.setShaderInputs(s);var l=function(e){return{type:e.type,shaderLanguage:e.info.shadingLanguage,shaderLanguageVersion:e.info.shadingLanguageVersion,gpu:e.info.gpu,features:e.features}}(n),c=((null==(i=this.props.modules)?void 0:i.length)>0?this.props.modules:null==(o=this.shaderInputs)?void 0:o.getModules())||[];if("webgpu"===this.device.type&&this.props.source){var u,f=this.props.shaderAssembler.assembleWGSLShader(Object.assign({platformInfo:l},this.props,{modules:c})),d=f.source,p=f.getUniforms;this.source=d,this._getModuleUniforms=p,(u=this.props).shaderLayout||(u.shaderLayout=n.getShaderLayout(this.source))}else{var h=this.props.shaderAssembler.assembleGLSLShaderPair(Object.assign({platformInfo:l},this.props,{modules:c})),m=h.vs,g=h.fs,_=h.getUniforms;this.vs=m,this.fs=g,this._getModuleUniforms=_}this.vertexCount=this.props.vertexCount,this.instanceCount=this.props.instanceCount,this.topology=this.props.topology,this.bufferLayout=this.props.bufferLayout,this.parameters=this.props.parameters,t.geometry&&this.setGeometry(t.geometry),this.pipelineFactory=t.pipelineFactory||me.getDefaultPipelineFactory(this.device),this.shaderFactory=t.shaderFactory||_e.getDefaultShaderFactory(this.device),this.pipeline=this._updatePipeline(),this.vertexArray=n.createVertexArray({shaderLayout:this.pipeline.shaderLayout,bufferLayout:this.pipeline.bufferLayout}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry),"isInstanced"in t&&(this.isInstanced=t.isInstanced),t.instanceCount&&this.setInstanceCount(t.instanceCount),t.vertexCount&&this.setVertexCount(t.vertexCount),t.indexBuffer&&this.setIndexBuffer(t.indexBuffer),t.attributes&&this.setAttributes(t.attributes),t.constantAttributes&&this.setConstantAttributes(t.constantAttributes),t.bindings&&this.setBindings(t.bindings),t.transformFeedback&&(this.transformFeedback=t.transformFeedback)}var n=e.prototype;return n.toString=function(){return"Model("+this.id+")"},n.destroy=function(){var e;this._destroyed||(this.pipelineFactory.release(this.pipeline),this.shaderFactory.release(this.pipeline.vs),this.pipeline.fs&&this.shaderFactory.release(this.pipeline.fs),this._uniformStore.destroy(),null==(e=this._gpuGeometry)||e.destroy(),this._destroyed=!0)},n.needsRedraw=function(){this._getBindingsUpdateTimestamp()>this._lastDrawTimestamp&&this.setNeedsRedraw("contents of bound textures or buffers updated");var e=this._needsRedraw;return this._needsRedraw=!1,e},n.setNeedsRedraw=function(e){this._needsRedraw||(this._needsRedraw=e)},n.predraw=function(){this.updateShaderInputs(),this.pipeline=this._updatePipeline()},n.draw=function(e){var n,t=this._areBindingsLoading();if(t)return c.R.info(2,">>> DRAWING ABORTED "+this.id+": "+t+" not loaded")(),!1;try{e.pushDebugGroup(this+".predraw("+e+")"),this.predraw()}finally{e.popDebugGroup()}try{e.pushDebugGroup(this+".draw("+e+")"),this._logDrawCallStart(),this.pipeline=this._updatePipeline();var r=this._getBindings();this.pipeline.setBindings(r,{disableWarnings:this.props.disableWarnings});var i=this.vertexArray.indexBuffer,o=i?i.byteLength/("uint32"===i.indexType?4:2):void 0;n=this.pipeline.draw({renderPass:e,vertexArray:this.vertexArray,isInstanced:this.isInstanced,vertexCount:this.vertexCount,instanceCount:this.instanceCount,indexCount:o,transformFeedback:this.transformFeedback||void 0,parameters:this.parameters,topology:this.topology})}finally{e.popDebugGroup(),this._logDrawCallEnd()}return this._logFramebuffer(e),n?(this._lastDrawTimestamp=this.device.timestamp,this._needsRedraw=!1):this._needsRedraw="waiting for resource initialization",n},n.setGeometry=function(e){var n;null==(n=this._gpuGeometry)||n.destroy();var t=e&&pe(this.device,e);if(t){this.setTopology(t.topology||"triangle-list");var r=new Te(this.bufferLayout);this.bufferLayout=r.mergeBufferLayouts(t.bufferLayout,this.bufferLayout),this.vertexArray&&this._setGeometryAttributes(t)}this._gpuGeometry=t},n.setTopology=function(e){e!==this.topology&&(this.topology=e,this._setPipelineNeedsUpdate("topology"))},n.setBufferLayout=function(e){var n=new Te(this.bufferLayout);this.bufferLayout=this._gpuGeometry?n.mergeBufferLayouts(e,this._gpuGeometry.bufferLayout):e,this._setPipelineNeedsUpdate("bufferLayout"),this.pipeline=this._updatePipeline(),this.vertexArray=this.device.createVertexArray({shaderLayout:this.pipeline.shaderLayout,bufferLayout:this.pipeline.bufferLayout}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry)},n.setParameters=function(e){Ee(e,this.parameters,2)||(this.parameters=e,this._setPipelineNeedsUpdate("parameters"))},n.setInstanceCount=function(e){this.instanceCount=e,void 0===this.isInstanced&&e>0&&(this.isInstanced=!0),this.setNeedsRedraw("instanceCount")},n.setVertexCount=function(e){this.vertexCount=e,this.setNeedsRedraw("vertexCount")},n.setShaderInputs=function(e){this.shaderInputs=e,this._uniformStore=new g(this.shaderInputs.modules);for(var n=0,t=Object.entries(this.shaderInputs.modules);n<t.length;n++){var r=t[n],i=r[0];if(Xe(r[1])){var o=this._uniformStore.getManagedUniformBuffer(this.device,i);this.bindings[i+"Uniforms"]=o}}this.setNeedsRedraw("shaderInputs")},n.updateShaderInputs=function(){this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()),this.setBindings(this.shaderInputs.getBindingValues()),this.setNeedsRedraw("shaderInputs")},n.setBindings=function(e){Object.assign(this.bindings,e),this.setNeedsRedraw("bindings")},n.setTransformFeedback=function(e){this.transformFeedback=e,this.setNeedsRedraw("transformFeedback")},n.setIndexBuffer=function(e){this.vertexArray.setIndexBuffer(e),this.setNeedsRedraw("indexBuffer")},n.setAttributes=function(e,n){var t,r=null!=(t=null==n?void 0:n.disableWarnings)?t:this.props.disableWarnings;e.indices&&c.R.warn("Model:"+this.id+" setAttributes() - indexBuffer should be set using setIndexBuffer()")(),this.bufferLayout=function(e,n){var t=Object.fromEntries(e.attributes.map(function(e){return[e.name,e.location]})),r=n.slice();return r.sort(function(e,n){var r=e.attributes?e.attributes.map(function(e){return e.attribute}):[e.name],i=n.attributes?n.attributes.map(function(e){return e.attribute}):[n.name];return Math.min.apply(Math,r.map(function(e){return t[e]}))-Math.min.apply(Math,i.map(function(e){return t[e]}))}),r}(this.pipeline.shaderLayout,this.bufferLayout);for(var i=new Te(this.bufferLayout),o=0,s=Object.entries(e);o<s.length;o++){var l=s[o],u=l[0],f=l[1],d=i.getBufferLayout(u);if(d){for(var p,h=i.getAttributeNamesForBuffer(d),m=!1,g=(0,a.A)(h);!(p=g()).done;){var _=p.value,v=this._attributeInfos[_];if(v){var A="webgpu"===this.device.type?i.getBufferIndex(v.bufferName):v.location;this.vertexArray.setBuffer(A,f),m=!0}}m||r||c.R.warn("Model("+this.id+'): Ignoring buffer "'+f.id+'" for unknown attribute "'+u+'"')()}else r||c.R.warn("Model("+this.id+'): Missing layout for buffer "'+u+'".')()}this.setNeedsRedraw("attributes")},n.setConstantAttributes=function(e,n){for(var t=0,r=Object.entries(e);t<r.length;t++){var i,o=r[t],a=o[0],s=o[1],l=this._attributeInfos[a];l?this.vertexArray.setConstantWebGL(l.location,s):(null!=(i=null==n?void 0:n.disableWarnings)?i:this.props.disableWarnings)||c.R.warn('Model "'+this.id+': Ignoring constant supplied for unknown attribute "'+a+'"')()}this.setNeedsRedraw("constants")},n._areBindingsLoading=function(){for(var e=0,n=Object.values(this.bindings);e<n.length;e++){var t=n[e];if(t instanceof Ue&&!t.isReady)return t.id}return!1},n._getBindings=function(){for(var e={},n=0,t=Object.entries(this.bindings);n<t.length;n++){var r=t[n],i=r[0],o=r[1];o instanceof Ue?o.isReady&&(e[i]=o.texture):e[i]=o}return e},n._getBindingsUpdateTimestamp=function(){for(var e=0,n=0,t=Object.values(this.bindings);n<t.length;n++){var r=t[n];r instanceof x.X?e=Math.max(e,r.texture.updateTimestamp):r instanceof l.h||r instanceof R.g?e=Math.max(e,r.updateTimestamp):r instanceof Ue?e=r.texture?Math.max(e,r.texture.updateTimestamp):1/0:r instanceof C.L||(e=Math.max(e,r.buffer.updateTimestamp))}return e},n._setGeometryAttributes=function(e){for(var n=this,t=Object.assign({},e.attributes),r=function(){var e=o[i][0];n.pipeline.shaderLayout.attributes.find(function(n){return n.name===e})||"positions"===e||delete t[e]},i=0,o=Object.entries(t);i<o.length;i++)r();this.vertexCount=e.vertexCount,this.setIndexBuffer(e.indices||null),this.setAttributes(e.attributes,{disableWarnings:!0}),this.setAttributes(t,{disableWarnings:this.props.disableWarnings}),this.setNeedsRedraw("geometry attributes")},n._setPipelineNeedsUpdate=function(e){this._pipelineNeedsUpdate||(this._pipelineNeedsUpdate=e),this.setNeedsRedraw(e)},n._updatePipeline=function(){if(this._pipelineNeedsUpdate){var e=null,n=null;this.pipeline&&(c.R.log(1,"Model "+this.id+': Recreating pipeline because "'+this._pipelineNeedsUpdate+'".')(),e=this.pipeline.vs,n=this.pipeline.fs),this._pipelineNeedsUpdate=!1;var t=this.shaderFactory.createShader({id:this.id+"-vertex",stage:"vertex",source:this.source||this.vs,debugShaders:this.props.debugShaders}),r=null;this.source?r=t:this.fs&&(r=this.shaderFactory.createShader({id:this.id+"-fragment",stage:"fragment",source:this.source||this.fs,debugShaders:this.props.debugShaders})),this.pipeline=this.pipelineFactory.createRenderPipeline(Object.assign({},this.props,{bufferLayout:this.bufferLayout,topology:this.topology,parameters:this.parameters,bindings:this._getBindings(),vs:t,fs:r})),this._attributeInfos=(0,S.P)(this.pipeline.shaderLayout,this.bufferLayout),e&&this.shaderFactory.release(e),n&&this.shaderFactory.release(n)}return this.pipeline},n._logDrawCallStart=function(){var e=c.R.level>3?0:1e4;c.R.level<2||Date.now()-this._lastLogTime<e||(this._lastLogTime=Date.now(),this._logOpen=!0,c.R.group(2,">>> DRAWING MODEL "+this.id,{collapsed:c.R.level<=2})())},n._logDrawCallEnd=function(){if(this._logOpen){var e=function(e){var n,t,r={},i="Values";if(0===e.attributes.length&&(null==(n=e.varyings)||!n.length))return{"No attributes or varyings":(t={},t[i]="N/A",t)};for(var o,s=(0,a.A)(e.attributes);!(o=s()).done;){var l,c=o.value;c&&(r["in "+c.location+" "+c.name+": "+c.type]=((l={})[i]=c.stepMode||"vertex",l))}for(var u,f=(0,a.A)(e.varyings||[]);!(u=f()).done;){var d,p=u.value;r["out "+p.location+" "+p.name]=((d={})[i]=JSON.stringify(p),d)}return r}(this.pipeline.shaderLayout,this.id);c.R.table(2,e)();var n=this.shaderInputs.getDebugTable();c.R.table(2,n)();var t=this._getAttributeDebugTable();c.R.table(2,this._attributeInfos)(),c.R.table(2,t)(),c.R.groupEnd(2)(),this._logOpen=!1}},n._logFramebuffer=function(e){var n=this.device.props.debugFramebuffers;if(this._drawCount++,n){var t=e.props.framebuffer;t&&function(e,n){var t,r=n.id,i=(n.minimap,n.opaque),o=n.top,a=void 0===o?"0":o,s=n.left,l=void 0===s?"0":s,c=n.rgbaScale,u=void 0===c?1:c;ve||((ve=document.createElement("canvas")).id=r,ve.title=r,ve.style.zIndex="100",ve.style.position="absolute",ve.style.top=a,ve.style.left=l,ve.style.border="blue 5px solid",ve.style.transform="scaleY(-1)",document.body.appendChild(ve),Ae=ve.getContext("2d")),ve.width===e.width&&ve.height===e.height||(ve.width=e.width/2,ve.height=e.height/2,ve.style.width="400px",ve.style.height="400px");var f=e.device.readPixelsToArrayWebGL(e),d=null==(t=Ae)?void 0:t.createImageData(e.width,e.height);if(d){for(var p,h=0;h<f.length;h+=4)d.data[0+h+0]=f[h+0]*u,d.data[0+h+1]=f[h+1]*u,d.data[0+h+2]=f[h+2]*u,d.data[0+h+3]=i?255:f[h+3]*u;null==(p=Ae)||p.putImageData(d,0,0)}}(t,{id:t.id,minimap:!0})}},n._getAttributeDebugTable=function(){for(var e={},n=0,t=Object.entries(this._attributeInfos);n<t.length;n++){var r=t[n],i=r[0],o=r[1],a=this.vertexArray.attributes[o.location];e[o.location]={name:i,type:o.shaderType,values:a?this._getBufferOrConstantValues(a,o.bufferDataType):"null"}}if(this.vertexArray.indexBuffer){var s=this.vertexArray.indexBuffer,l="uint32"===s.indexType?new Uint32Array(s.debugData):new Uint16Array(s.debugData);e.indices={name:"indices",type:s.indexType,values:l.toString()}}return e},n._getBufferOrConstantValues=function(e,n){var t=(0,d.Ak)(n);return(e instanceof l.h?new t(e.debugData):e).toString()},(0,b.A)(e,[{key:Symbol.toStringTag,get:function(){return"Model"}}])}();function Xe(e){return Boolean(e.uniformTypes&&!function(e){for(var n in e)return!1;return!0}(e.uniformTypes))}Ge.defaultProps=Object.assign({},I.r.defaultProps,{source:void 0,vs:null,fs:null,id:"unnamed",handle:void 0,userData:{},defines:{},modules:[],geometry:null,indexBuffer:null,attributes:{},constantAttributes:{},varyings:[],isInstanced:void 0,instanceCount:0,vertexCount:0,shaderInputs:void 0,pipelineFactory:void 0,shaderFactory:void 0,transformFeedback:void 0,shaderAssembler:le.getDefaultShaderAssembler(),debugShaders:void 0,disableWarnings:void 0});var He=function(){function e(e){this.userData={};var n=e.attributes,t=void 0===n?{}:n,r=e.indices,i=void 0===r?null:r,o=e.vertexCount,a=void 0===o?null:o;this.id=e.id||fe("geometry"),this.topology=e.topology,i&&(this.indices=ArrayBuffer.isView(i)?{value:i,size:1}:i),this.attributes={};for(var s=0,l=Object.entries(t);s<l.length;s++){var c=l[s],u=c[0],f=c[1],d=ArrayBuffer.isView(f)?{value:f}:f;if(!ArrayBuffer.isView(d.value))throw new Error(this._print(u)+": must be typed array or object with value as typed array");if("POSITION"!==u&&"positions"!==u||d.size||(d.size=3),"indices"===u){if(this.indices)throw new Error("Multiple indices detected");this.indices=d}else this.attributes[u]=d}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=a||this._calculateVertexCount(this.attributes,this.indices)}var n=e.prototype;return n.getVertexCount=function(){return this.vertexCount},n.getAttributes=function(){return this.indices?Object.assign({indices:this.indices},this.attributes):this.attributes},n._print=function(e){return"Geometry "+this.id+" attribute "+e},n._setAttributes=function(e,n){return this},n._calculateVertexCount=function(e,n){if(n)return n.value.length;for(var t=1/0,r=0,i=Object.values(e);r<i.length;r++){var o=i[r],a=o.value,s=o.size;!o.constant&&a&&void 0!==s&&s>=1&&(t=Math.min(t,a.length/s))}return t},e}(),Ve=function(e){function n(n){void 0===n&&(n={});var t=n,r=t.id,i=void 0===r?fe("cube-geometry"):r,o=t.indices,a=void 0===o||o;return e.call(this,a?Object.assign({},n,{id:i,topology:"triangle-list",indices:{size:1,value:ke},attributes:Object.assign({},Ze,n.attributes)}):Object.assign({},n,{id:i,topology:"triangle-list",indices:void 0,attributes:Object.assign({},qe,n.attributes)}))||this}return(0,s.A)(n,e),n}(He),ke=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),ze=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),je=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),We=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),Ye=new Float32Array([1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1]),Qe=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),Ke=new Float32Array([1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,1]),Ze={POSITION:{size:3,value:ze},NORMAL:{size:3,value:je},TEXCOORD_0:{size:2,value:We}},qe={POSITION:{size:3,value:Ye},TEXCOORD_0:{size:2,value:Qe},COLOR_0:{size:3,value:Ke}},Je=function(){function e(e){}return e.prototype.onInitialize=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n){return(0,Ce.A)().w(function(e){for(;;)if(0===e.n)return e.a(2,null)},e)}));return function(n){return e.apply(this,arguments)}}(),e}(),$e={props:{},uniforms:{},name:"dirlight",dependencies:[],source:"  \nstruct dirlightUniforms {\n  lightDirection: vec3<f32>,\n};\n\nalias DirlightNormal = vec3<f32>;\n\nstruct DirlightInputs {\n  normal: DirlightNormal,\n};\n\n@binding(1) @group(0) var<uniform> dirlight : dirlightUniforms;\n\n// For vertex\nfn dirlight_setNormal(normal: vec3<f32>) -> DirlightNormal {\n  return normalize(normal);\n}\n\n// Returns color attenuated by angle from light source\nfn dirlight_filterColor(color: vec4<f32>, inputs: DirlightInputs) -> vec4<f32> {\n  // TODO - fix default light direction\n  // let lightDirection = dirlight.lightDirection;\n  let lightDirection = vec3<f32>(1, 1, 1);\n  let d: f32 = abs(dot(inputs.normal, normalize(lightDirection)));\n  return vec4<f32>(color.rgb * d, color.a);\n}\n",vs:"out vec3 dirlight_vNormal;\n\nvoid dirlight_setNormal(vec3 normal) {\n  dirlight_vNormal = normalize(normal);\n}\n",fs:"uniform dirlightUniforms {\n  vec3 lightDirection;\n} dirlight;\n\nin vec3 dirlight_vNormal;\n\n// Returns color attenuated by angle from light source\nvec4 dirlight_filterColor(vec4 color) {\n  float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n",uniformTypes:{lightDirection:"vec3<f32>"},defaultUniforms:{lightDirection:[1,1,2]},getUniforms:function(e){void 0===e&&(e=$e.defaultUniforms);var n={};e.lightDirection&&(n.lightDirection=e.lightDirection);return n}};var en=t(5663),nn=t(4901),tn=_(),rn={uniformTypes:{uColor:"vec3<f32>",uModel:"mat4x4<f32>",uView:"mat4x4<f32>",uProjection:"mat4x4<f32>"}},on=function(e){function n(n){var t,r=n.device,i=n.aspect,o=n.animationLoop;(t=e.call(this)||this).translations=[[2,-2,0],[2,2,0],[-2,2,0],[-2,-2,0]],t.rotations=[[tn(),tn(),tn()],[tn(),tn(),tn()],[tn(),tn(),tn()],[tn(),tn(),tn()]],t.colors=[[1,0,0],[0,1,0],[0,0,1],[1,1,0]],t.keyFrameData=[[0,0],[1e3,2*Math.PI],[2e3,Math.PI],[3e3,2*Math.PI],[4e3,0]],t.globalUniformStore=new g({dirlight:$e});var a=document.getElementById("play"),s=document.getElementById("pause");t.timeSlider=document.getElementById("time"),a&&s&&(a.addEventListener("click",function(){return t.timeline.play()}),s.addEventListener("click",function(){return t.timeline.pause()}),t.timeSlider.addEventListener("input",function(e){return t.timeline.setTime(parseFloat(e.target.value))})),t.timeline=new E,o.attachTimeline(t.timeline),t.timeline.play();var l=[t.timeline.addChannel({delay:2e3,rate:.5,duration:8e3,repeat:2}),t.timeline.addChannel({delay:1e4,rate:.2,duration:2e4,repeat:1}),t.timeline.addChannel({delay:7e3,rate:1,duration:4e3,repeat:8}),t.timeline.addChannel({delay:0,rate:.8,duration:5e3,repeat:Number.POSITIVE_INFINITY})];t.cubes=new Array(4);for(var c=[new T(t.keyFrameData),new T(t.keyFrameData),new T(t.keyFrameData),new T(t.keyFrameData)],u=0;u<4;++u){t.timeline.attachAnimation(c[u],l[u]);var f=new g({app:rn});f.setUniforms({app:{uProjection:(new en.k).perspective({fovy:(0,nn.F2)(60),aspect:i,near:1,far:20}),uView:(new en.k).lookAt({center:[0,0,0],eye:[0,0,-8]}),uColor:t.colors[u]}}),t.cubes[u]={uniformStore:f,translation:t.translations[u],rotation:t.rotations[u],keyFrames:c[u],model:new Ge(r,{id:"cube-"+u,source:"struct Uniforms {\n  uColor : vec3<f32>,\n  uModel : mat4x4<f32>,\n  uView : mat4x4<f32>,\n  uProjection : mat4x4<f32>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) normals : vec3<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) color : vec3<f32>,\n  @location(1) dirlightNormal: DirlightNormal,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  // gl_Position = app.uProjection * app.uView * app.uModel * vec4(positions, 1.0);\n  outputs.Position = app.uProjection * app.uView * app.uModel * inputs.positions;\n  outputs.color = app.uColor;\n\n  let normal: vec3<f32> = (app.uModel * vec4<f32>(inputs.normals, 0.0)).xyz;\n  outputs.dirlightNormal = dirlight_setNormal(normal);\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  var fragColor = vec4(inputs.color, 1.);\n  fragColor = dirlight_filterColor(fragColor, DirlightInputs(inputs.dirlightNormal));\n  return fragColor;\n}\n",vs:"#version 300 es\n\nin vec3 positions;\nin vec3 normals;\n\nuniform appUniforms {\n  vec3 uColor;\n  mat4 uModel;\n  mat4 uView;\n  mat4 uProjection;\n} app;\n\nout vec3 color;\n\nvoid main(void) {\n  vec3 normal = vec3(app.uModel * vec4(normals, 0.0));\n\n  // Set up data for modules\n  color = app.uColor;\n  dirlight_setNormal(normal);\n  gl_Position = app.uProjection * app.uView * app.uModel * vec4(positions, 1.0);\n}\n",fs:"#version 300 es\n\nprecision highp float;\n\nin vec3 color;\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(color, 1.);\n  fragColor = dirlight_filterColor(fragColor);\n}\n",instanceCount:1,modules:[$e],geometry:new Ve,parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"},bindings:{app:f.getManagedUniformBuffer(r,"app"),dirlight:t.globalUniformStore.getManagedUniformBuffer(r,"dirlight")}})}}return t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){for(var e,n=(0,a.A)(this.cubes);!(e=n()).done;){e.value.model.destroy()}},t.onRender=function(e){var n=e.device;this.timeSlider&&(this.timeSlider.value=this.timeline.getTime());for(var t,r=new en.k,i=(0,a.A)(this.cubes);!(t=i()).done;){var o=t.value,s=o.keyFrames.getStartData(),l=o.keyFrames.getEndData(),c=s+o.keyFrames.factor*(l-s),u=o.rotation[0]+c,f=o.rotation[1]+c,d=o.rotation[2];r.identity().translate(o.translation).rotateXYZ([u,f,d]),o.uniformStore.setUniforms({app:{uModel:r}}),o.uniformStore.updateUniformBuffers()}for(var p,h=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0}),m=(0,a.A)(this.cubes);!(p=m()).done;){p.value.model.draw(h)}h.end()},n}(Je);on.info='Key frame animation based on multiple hierarchical timelines.\n<button id="play">Play</button>\n<button id="pause">Pause</button><BR>\nTime: <input type="range" id="time" min="0" max="30000" step="1"><BR>\n';var an=t(4327),sn={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",viewMatrix:"mat4x4<f32>",projectionMatrix:"mat4x4<f32>",eyePosition:"vec3<f32>"}},ln=function(e){function n(t,r){return e.call(this,t,Object.assign({},r,{id:"room-cube",geometry:new Ve,source:n.source,vs:n.vs,fs:n.fs}))||this}return(0,s.A)(n,e),n}(Ge);ln.source="struct appUniforms {\n  modelMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  projectionMatrix: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> app : appUniforms;\n@group(0) @binding(1) var cubeTexture : texture_cube<f32>;\n@group(0) @binding(2) var cubeTextureSampler : sampler;\n\nstruct VertexInputs {\n  @location(0) positions : vec3<f32>,\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) dir : vec3<f32>,\n};\n\n@vertex \nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4<f32>(inputs.positions, 1.0);\n  outputs.dir = (app.modelMatrix * vec4<f32>(inputs.positions, 0.0)).xyz;\n  return outputs;\n}\n\n@fragment \nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  // The outer cube just samples the texture cube directly\n  return textureSample(cubeTexture, cubeTextureSampler, normalize(inputs.dir));\n}\n  ",ln.vs="#version 300 es\nin vec3 positions;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n} app;\n\nout vec3 vPosition;\n\nvoid main(void) {\n  gl_Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4(positions, 1.0);\n  vPosition = positions;\n}\n  ",ln.fs="#version 300 es\nprecision highp float;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n} app;\n\nuniform samplerCube cubeTexture;\n\nin vec3 vPosition;\nout vec4 fragColor;\n\nvoid main(void) {\n  // The outer cube just samples the texture cube directly\n  fragColor = texture(cubeTexture, normalize(vPosition));\n}\n  ";var cn=function(e){function n(t,r){return e.call(this,t,Object.assign({},r,{id:"prism",geometry:new Ve({indices:!0}),source:n.source,vs:n.vs,fs:n.fs}))||this}return(0,s.A)(n,e),n}(Ge);cn.source="struct appUniforms {\n  modelMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  projectionMatrix: mat4x4<f32>,\n  eyePosition: vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> app : appUniforms;\n@group(0) @binding(1) var cubeTexture : texture_cube<f32>;\n@group(0) @binding(2) var cubeTextureSampler : sampler;\n@group(0) @binding(3) var prismTexture : texture_2d<f32>;\n@group(0) @binding(4) var prismTextureSampler : sampler;\n\nstruct VertexInputs {\n  @location(0) positions : vec3<f32>,\n  @location(1) normals : vec3<f32>,\n  @location(2) texCoords : vec2<f32>,\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec3<f32>,\n  @location(1) normal : vec3<f32>,\n  @location(2) uv : vec2<f32>,\n};\n\n@vertex \nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4(inputs.positions, 1.0);\n  outputs.position = (app.modelMatrix * vec4(inputs.positions, 1.0)).xyz;\n  outputs.normal = normalize((app.modelMatrix * vec4(inputs.normals, 0.0)).xyz);\n  outputs.uv = inputs.texCoords;\n  return outputs;\n}\n\n@fragment \nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  let color = textureSample(prismTexture, prismTextureSampler, vec2(inputs.uv.x, 1.0 - inputs.uv.y));\n  let reflectedDir = reflect(normalize(inputs.position - app.eyePosition), inputs.normal);\n  let reflectedColor = textureSample(cubeTexture, cubeTextureSampler, reflectedDir);\n\n  return mix(color, reflectedColor, 0.8);\n}\n    ",cn.vs="#version 300 es\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec2 vUV;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  vec3 eyePosition;\n} app;\n\nvoid main(void) {\n  gl_Position = app.projectionMatrix * app.viewMatrix * app.modelMatrix * vec4(positions, 1.0);\n  vPosition = vec3(app.modelMatrix * vec4(positions, 1.0));\n  vNormal = normalize(vec3(app.modelMatrix * vec4(normals, 0.0)));\n  vUV = texCoords;\n}\n  ",cn.fs="#version 300 es\nprecision highp float;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vUV;\n\nout vec4 fragColor;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  vec3 eyePosition;\n} app;\n\nuniform sampler2D prismTexture;\nuniform samplerCube cubeTexture;\n\nvoid main(void) {\n  vec4 color = texture(prismTexture, vec2(vUV.x, 1.0 - vUV.y));\n  vec3 reflectedDir = reflect(normalize(vPosition - app.eyePosition), vNormal);\n  vec4 reflectedColor = texture(cubeTexture, reflectedDir);\n  fragColor = mix(color, reflectedColor, 0.8);\n}\n  ";var un=function(e){function n(n){var t,r=n.device;(t=e.call(this)||this).roomShaderInputs=new Re({app:sn}),t.prismShaderInputs=new Re({app:sn});var i=new Ue(r,{dimension:"cube",mipmaps:!0,data:(0,Se.A)((0,Ce.A)().m(function e(){var n,t,r,i,o,a;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,(0,an.Dt)("sky-posx.png");case 1:return n=e.v,e.n=2,(0,an.Dt)("sky-negx.png");case 2:return t=e.v,e.n=3,(0,an.Dt)("sky-posy.png");case 3:return r=e.v,e.n=4,(0,an.Dt)("sky-negy.png");case 4:return i=e.v,e.n=5,(0,an.Dt)("sky-posz.png");case 5:return o=e.v,e.n=6,(0,an.Dt)("sky-negz.png");case 6:return a=e.v,e.a(2,{"+X":n,"-X":t,"+Y":r,"-Y":i,"+Z":o,"-Z":a})}},e)}))(),sampler:{magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest"}}),o=new Ue(r,{data:(0,an.Dt)("vis-logo.png"),mipmaps:!0,sampler:{magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest"}});return t.cube=new ln(r,{shaderInputs:t.roomShaderInputs,instanceCount:1,bindings:{cubeTexture:i},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),t.prism=new cn(r,{shaderInputs:t.prismShaderInputs,instanceCount:1,bindings:{prismTexture:o,cubeTexture:i},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.prism.destroy(),this.cube.destroy()},t.onRender=function(e){var n=e.device,t=e.aspect,r=.01*e.tick,i=7*-Math.abs(Math.cos(r)),o=7*-Math.abs(Math.sin(r)),a=[i,7*-Math.abs(Math.sin(r))*2,o],s=(new en.k).lookAt({eye:a}),l=(new en.k).perspective({fovy:(0,nn.F2)(45),aspect:t,near:.001,far:1e3}),c=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});this.roomShaderInputs.setProps({app:{viewMatrix:s,projectionMatrix:l,modelMatrix:(new en.k).scale([20,20,20])}}),this.cube.draw(c),this.prismShaderInputs.setProps({app:{eyePosition:a,viewMatrix:s,projectionMatrix:l,modelMatrix:new en.k}}),this.prism.draw(c),c.end()},n}(Je);function fn(e,n,t){return e+t*(n-e)}function dn(e,n){for(var t=[],r=e;r<=n;r++)t.push(r);return t}function pn(e,n){for(var t,r=e.length,i=0;r;)t=Math.floor(n()*r),i=e[r-=1],e[r]=e[t],e[t]=i;return e}un.info="Uses a luma.gl <code>TextureCube</code> to simulate a reflective surface\n";var hn=function(e){return e*e*e*(e*(6*e-15)+10)},mn=function(e,n,t,r){var i=15&e,o=i<8?n:t,a=i<4?t:12==i||14==i?n:r;return(1&i?-o:o)+(2&i?-a:a)};var gn=_(),_n={name:"app",uniformTypes:{mvpMatrix:"mat4x4<f32>",time:"f32"}},vn=function(e){function n(n){var t,r=n.device;(t=e.call(this)||this).mvpMatrix=new en.k,t.viewMat=(new en.k).lookAt({eye:[1,1,1]}),t.shaderInputs=new Re({app:_n});var i=function(e){for(var n=1/e,t=new Float32Array(3*Math.pow(e,3)),r=0,i=-.5,o=0;o<e;++o){for(var a=-.5,s=0;s<e;++s){for(var l=-.5,c=0;c<e;++c)t[r++]=i,t[r++]=a,t[r++]=l,l+=n;a+=n}i+=n}return t}(128),o=r.createBuffer(i),a=function(e){for(var n=function(e){if("object"!=typeof e)throw new TypeError("params is not an object");if("function"!=typeof e.interpolation)throw new TypeError("params.interpolation is not a function");if(!Array.isArray(e.permutation))throw new TypeError("params.permutation is not an array");if(256!=e.permutation.length)throw new Error("params.permutation must have 256 items");for(var n=e.interpolation,t=e.permutation.slice(0),r=0;r<256;r++)t[256+r]=t[r];return function(e,r,i){var o=Math.floor(e),a=Math.floor(r),s=Math.floor(i),l=255&o,c=255&a,u=255&s;r-=a,i-=s;var f=hn(e-=o),d=hn(r),p=hn(i),h=t[l]+c,m=t[h]+u,g=t[h+1]+u,_=t[l+1]+c,v=t[_]+u,A=t[_+1]+u;return n(n(n(mn(t[m],e,r,i),mn(t[v],e-1,r,i),f),n(mn(t[g],e,r-1,i),mn(t[A],e-1,r-1,i),f),d),n(n(mn(t[m+1],e,r,i-1),mn(t[v+1],e-1,r,i-1),f),n(mn(t[g+1],e,r-1,i-1),mn(t[A+1],e-1,r-1,i-1),f),d),p)}}({interpolation:fn,permutation:pn(dn(0,255),gn)}),t=.07*e,r=new Uint8Array(Math.pow(e,3)),i=0,o=0;o<e;++o)for(var a=0;a<e;++a)for(var s=0;s<e;++s){var l=n(o/t,a/t,s/t);r[i++]=255*(.5+.5*l)}return r}(16);return t.texture3d=r.createTexture({dimension:"3d",data:a,width:16,height:16,depth:16,format:"r8unorm",sampler:{magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest",addressModeU:"repeat",addressModeV:"repeat",addressModeW:"repeat"}}),t.cloud=new Ge(r,{source:"struct Uniforms {\n  mvpMatrix : mat4x4<f32>,\n  time : f32,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n@group(0) @binding(1) var uTexture : texture_3d<f32>;\n@group(0) @binding(2) var uTextureSampler : sampler;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) position : vec4<f32>,\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUVW : vec3<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.mvpMatrix * inputs.position;\n  outputs.fragUVW = inputs.position.xyz;\n  // outputs.fragPosition = 0.5 * (inputs.position + vec4(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  let sampleColor = textureSample(uTexture, uTextureSampler, inputs.fragUVW + vec3<f32>(0.0, 0.0, app.time));\n  let alpha = sampleColor.r * 0.1;\n  return vec4(fract(inputs.fragUVW) * alpha, alpha);\n}\n",vs:"#version 300 es\nin vec3 position;\n\nuniform appUniforms {\n  mat4 mvpMatrix;\n  float time;\n} app;\n\nout vec3 vUVW;\nvoid main() {\n  vUVW = position.xyz + 0.5;\n  gl_Position = app.mvpMatrix * vec4(position, 1.0);\n  gl_PointSize = 1.0;\n}",fs:"#version 300 es\nprecision highp float;\nprecision lowp sampler3D;\n\nuniform appUniforms {\n  mat4 mvpMatrix;\n  float time;\n} app;\n\nuniform sampler3D uTexture;\n\nin vec3 vUVW;\nout vec4 fragColor;\n\nvoid main() {\n  vec4 sampleColor = texture(uTexture, vUVW + vec3(0.0, 0.0, app.time));\n  float alpha = sampleColor.r * 0.1;\n  fragColor = vec4(fract(vUVW) * alpha, alpha);\n}",topology:"point-list",vertexCount:i.length/3,bufferLayout:[{name:"position",format:"float32x3"}],attributes:{position:o},bindings:{uTexture:t.texture3d},shaderInputs:t.shaderInputs,parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",blend:!0,blendColorOperation:"add",blendAlphaOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one-minus-src",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one-minus-src-alpha"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.cloud.destroy()},t.onRender=function(e){var n=e.device,t=e.tick,r=e.aspect;this.mvpMatrix.perspective({fovy:(0,nn.F2)(75),aspect:r,near:.1,far:10}).multiplyRight(this.viewMat),this.shaderInputs.setProps({app:{time:t/100,mvpMatrix:this.mvpMatrix}}),this.cloud.updateShaderInputs();var i=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});this.cloud.draw(i),i.end()},n}(Je);vn.info="  <p>\n  Volumetric 3D noise visualized using a <b>3D texture</b>.\n  <p>\n  Uses the luma.gl <code>Texture3D</code> class.\n  ",vn.props={useDevicePixels:!0};var An=t(6443),En=t.n(An),Tn=t(7221),bn=new Float32Array([0,.15,0,-.1,-.15,0,.1,-.15,0,0,.15,0,.1,-.15,0,0,-.35,0]),xn=new Float32Array([0,.6,1,0,.4,.8,0,.8,.8,0,.6,1,0,.8,.8,0,.4,.8]);function Rn(){return Rn=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i,o,a,s,l,c,u,f,d,p,h;return(0,Ce.A)().w(function(e){for(;;)if(0===e.n)return void 0===n&&(n={}),t=n.container||document.body,r=new g({app:{uniformTypes:{uModelViewProjection:"mat4x4<f32>"}}}),i=null,o=null,a=null,s=null,l=null,c=new en.k,u=new en.k,new en.k,f=new(En().Map)({container:t,style:"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",center:[-122.43,37.77],pitch:60,zoom:12.5,antialias:!0}),d=function(e){i&&i.canvasContext.resize({width:e.drawingBufferWidth,height:e.drawingBufferHeight})},p={id:"luma-gl-overlay",type:"custom",renderingMode:"3d",onAdd:function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n,t){var u,f;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:if(t instanceof WebGL2RenderingContext){e.n=1;break}throw new Error("MapLibre needs to provide a WebGL2RenderingContext to attach a luma.gl device.");case 1:return a=t,e.n=2,Tn.l.attach(t,{createCanvasContext:{autoResize:!1}});case 2:i=e.v,d(t),u=En().MercatorCoordinate.fromLngLat(n.getCenter(),250),f=u.meterInMercatorCoordinateUnits(),c.identity().translate([u.x,u.y,u.z]).scale([800*f,800*-f,800*f]),s=i.createBuffer({data:bn}),l=i.createBuffer({data:xn}),o=new Ge(i,{id:"maplibre-overlay-model",source:"struct AppUniforms {\n  uModelViewProjection : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> app : AppUniforms;\n\nstruct VertexInput {\n  @location(0) positions : vec3<f32>,\n  @location(1) colors : vec3<f32>\n}\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) colors : vec3<f32>\n}\n\n@vertex\nfn vertexMain(input : VertexInput) -> VertexOutput {\n  var output : VertexOutput;\n  output.position = app.uModelViewProjection * vec4<f32>(input.positions, 1.0);\n  output.colors = input.colors;\n  return output;\n}\n\n@fragment\nfn fragmentMain(input : VertexOutput) -> @location(0) vec4<f32> {\n  return vec4<f32>(input.colors, 0.8);\n}\n",vs:"#version 300 es\nlayout(location = 0) in vec3 positions;\nlayout(location = 1) in vec3 colors;\n\nlayout(std140) uniform app {\n  mat4 uModelViewProjection;\n};\n\nout vec3 vColor;\n\nvoid main(void) {\n  gl_Position = uModelViewProjection * vec4(positions, 1.0);\n  vColor = colors;\n}\n",fs:"#version 300 es\nprecision highp float;\n\nin vec3 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(vColor, 0.8);\n}\n",bufferLayout:[{name:"positions",format:"float32x3"},{name:"colors",format:"float32x3"}],attributes:{positions:s,colors:l},vertexCount:bn.length/3,bindings:{app:r.getManagedUniformBuffer(i,"app")},parameters:{depthWriteEnabled:!1,depthCompare:"always"}});case 3:return e.a(2)}},e)}));return function(n,t){return e.apply(this,arguments)}}(),render:function(e,n){if(e instanceof WebGL2RenderingContext&&i&&o){var t=n.modelViewProjectionMatrix;if(Array.from(t).some(function(e){return!Number.isFinite(e)}))throw new Error("Invalid values in modelViewProjectionMatrix");a=e,d(e),r.setUniforms({app:{uModelViewProjection:u.toFloat32Array()}}),r.updateUniformBuffers();var s=i.beginRenderPass({clearColor:!1,clearDepth:1});o.draw(s),s.end(),f.triggerRepaint()}}},h=function(){a&&d(a)},f.on("load",function(){f.addLayer(p),h()}),f.on("resize",h),e.a(2,{destroy:function(){var e,n,t,a;f.off("resize",h),f.getLayer(p.id)&&f.removeLayer(p.id),f.remove(),null==(e=s)||e.destroy(),null==(n=l)||n.destroy(),null==(t=o)||t.destroy(),r.destroy(),null==(a=i)||a.destroy()}})},e)})),Rn.apply(this,arguments)}const Cn=function(e){return Rn.apply(this,arguments)};var Sn=-1,In="precision highp float;\nprecision highp int;\n\nuniform pickingUniforms {\n  int isActive;\n  int indexMode;\n  int batchIndex;\n\n  int isHighlightActive;\n  int highlightedBatchIndex;\n  int highlightedObjectIndex;\n  vec4 highlightColor;\n} picking;\n";var Pn={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"i32",indexMode:"i32",batchIndex:"i32",isHighlightActive:"i32",highlightedBatchIndex:"i32",highlightedObjectIndex:"i32",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,indexMode:0,batchIndex:0,isHighlightActive:!0,highlightedBatchIndex:Sn,highlightedObjectIndex:Sn,highlightColor:[0,1,1,1]},getUniforms:function(e,n){void 0===e&&(e={});var t=Object.assign({},n);switch(void 0!==e.isActive&&(t.isActive=Boolean(e.isActive)),e.indexMode){case"instance":t.indexMode=0;break;case"custom":t.indexMode=1}switch(e.highlightedObjectIndex){case void 0:break;case null:t.isHighlightActive=!1,t.highlightedObjectIndex=Sn;break;default:t.isHighlightActive=!0,t.highlightedObjectIndex=e.highlightedObjectIndex}return"number"==typeof e.highlightedBatchIndex&&(t.highlightedBatchIndex=e.highlightedBatchIndex),e.highlightColor&&(t.highlightColor=e.highlightColor),t}},Nn=In+"\n\nconst int INDEX_PICKING_MODE_INSTANCE = 0;\nconst int INDEX_PICKING_MODE_CUSTOM = 1;\n\nconst int INDEX_PICKING_INVALID_INDEX = "+"-1; // 2^32 - 1\n\nflat out int picking_objectIndex;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nvoid picking_setObjectIndex(int objectIndex) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE:\n      picking_objectIndex = gl_InstanceID;\n      break;\n    case INDEX_PICKING_MODE_CUSTOM:\n      picking_objectIndex = objectIndex;\n      break;\n  }\n}\n",yn=In+"\n\nconst int INDEX_PICKING_INVALID_INDEX = "+"-1; // 2^32 - 1\n\nflat in int picking_objectIndex;\n\n/**\n * Check if this vertex is highlighted (part of the selected batch and object)\n */ \nbool picking_isFragmentHighlighted() {\n  return \n    bool(picking.isHighlightActive) &&\n    picking.highlightedBatchIndex == picking.batchIndex &&\n    picking.highlightedObjectIndex == picking_objectIndex\n    ;\n}\n\n/**\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (bool(picking.isActive)) {\n    return color;\n  }\n\n  // If we are not highlighted, return color as is\n  if (!picking_isFragmentHighlighted()) {\n    return color;\n  }\n   \n  // Blend in highlight color based on its alpha value\n  float highLightAlpha = picking.highlightColor.a;\n  float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n  float highLightRatio = highLightAlpha / blendedAlpha;\n\n  vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nivec4 picking_getPickingColor() {\n  // Assumes that colorAttachment0 is rg32int\n  // TODO? - we could render indices into a second color attachment and not mess with fragColor\n  return ivec4(picking_objectIndex, picking.batchIndex, 0u, 0u);  \n}\n\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_objectIndex == INDEX_PICKING_INVALID_INDEX) {\n      discard;\n    }\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 outColor = color;\n  outColor = picking_filterHighlightColor(outColor);\n  outColor = picking_filterPickingColor(outColor);\n  return outColor;\n}\n",Ln=Object.assign({},Pn,{name:"picking",source:"struct pickingUniforms {\n  isActive: int32;\n  indexMode: int32;\n  batchIndex: int32;\n\n  isHighlightActive: int32;\n  highlightedBatchIndex: int32;\n  highlightedObjectIndex: int32;\n  highlightColor: vec4<f32>;\n} picking;\n\n\nconst INDEX_PICKING_MODE_INSTANCE = 0;\nconst INDEX_PICKING_MODE_CUSTOM = 1;\nconst INDEX_PICKING_INVALID_INDEX = -1; // 2^32 - 1\n\nstruct indexPickingFragmentInputs = {\n  objectIndex: int32;\n};\n\nlet indexPickingFragmentInputs: indexPickingFragmentInputs;\n\n/**\n * Vertex shaders should call this function to set the object index.\n * If using instance or vertex mode, argument will be ignored, 0 can be supplied.\n */\nfn picking_setObjectIndex(objectIndex: int32) {\n  switch (picking.indexMode) {\n    case INDEX_PICKING_MODE_INSTANCE, default: {\n      picking_objectIndex = instance_index;\n    };\n    case INDEX_PICKING_MODE_CUSTOM: {\n      picking_objectIndex = objectIndex;\n    };\n  }\n}\n\n",vs:Nn,fs:yn}),Fn=function(){function e(n,t){this.pickInfo={batchIndex:null,objectIndex:null},this.framebuffer=null,this.device=n,this.props=Object.assign({},e.defaultProps,t)}var n=e.prototype;return n.destroy=function(){var e;null==(e=this.framebuffer)||e.destroy()},n.getFramebuffer=function(){return this.framebuffer||(this.framebuffer=this.device.createFramebuffer({colorAttachments:["rgba8unorm","rg32sint"],depthStencilAttachment:"depth24plus"})),this.framebuffer},n.clearPickState=function(){this.props.shaderInputs.setProps({picking:{highlightedObjectIndex:null}})},n.beginRenderPass=function(){var e,n=this.getFramebuffer();return n.resize(this.device.getDefaultCanvasContext().getDevicePixelSize()),null==(e=this.props.shaderInputs)||e.setProps({picking:{isActive:!0}}),this.device.beginRenderPass({framebuffer:n,clearColors:[new Float32Array([0,0,0,0]),new Int32Array([-1,-1,0,0])],clearDepth:1})},n.updatePickInfo=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i,o,a,s,l;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:if(r=this.getFramebuffer(),i=this.getPickPosition(n),o=i[0],a=i[1],s=this.device.readPixelsToArrayWebGL(r,{sourceX:o,sourceY:a,sourceWidth:1,sourceHeight:1,sourceAttachment:1})){e.n=1;break}return e.a(2,null);case 1:return(l={objectIndex:s[0]===Sn?null:s[0],batchIndex:s[1]===Sn?null:s[1]}).objectIndex===this.pickInfo.objectIndex&&l.batchIndex===this.pickInfo.batchIndex||(this.pickInfo=l,this.props.onObjectPicked(l)),null==(t=this.props.shaderInputs)||t.setProps({picking:{isActive:!1,highlightedBatchIndex:l.batchIndex,highlightedObjectIndex:l.objectIndex}}),e.a(2,this.pickInfo)}},e,this)}));return function(n){return e.apply(this,arguments)}}(),n.getPickPosition=function(e){var n=this.device.getDefaultCanvasContext().cssToDevicePixels(e);return[n.x+Math.floor(n.width/2),n.y+Math.floor(n.height/2)]},e}();Fn.defaultProps={shaderInputs:void 0,onObjectPicked:function(){}};var Mn=_(),On=256,wn=function(e){function n(n,t){for(var r=[],i=0;i<On;i++)for(var o=3*i-382.5,a=0;a<On;a++){var s=3*a-382.5;r.push(o,s)}for(var l=new Float32Array(r),c=new Uint8Array(262144).map(function(e,n){return 255*(.75*Mn()+.25)}),u=0;u<c.length;u+=4)c[u+3]=255;var f=new Int32Array(65536).fill(0).map(function(e,n){return n}),d=n.createBuffer(l),p=n.createBuffer(c),h=n.createBuffer(f);return e.call(this,n,Object.assign({},t,{source:"\n// APPLICATION\n\nstruct AppUniforms {\n  modelMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  projectionMatrix: mat4x4<f32>,\n  time: f32,\n};\n\n@group(0) @binding(0) var<uniform> app : AppUniforms;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) normals : vec3<f32>,\n  // INSTANCED ATTRIBUTES\n  @location(2) instanceOffsets : vec2<f32>,\n  @location(3) instanceColors : vec4<f32>,\n  @location(4) instanceIndexes : i32,\n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) normal : vec3<f32>,\n  @location(1) color : vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n\n  // Vertex position (z coordinate undulates with time), and model rotates around center\n  let delta = length(inputs.instanceOffsets);\n  let offset = vec4<f32>(inputs.instanceOffsets, sin((app.time + delta) * 0.1) * 16.0, 0);\n  outputs.Position = app.projectionMatrix * app.viewMatrix * (app.modelMatrix * inputs.positions + offset);\n\n  outputs.normal = dirlight_setNormal((app.modelMatrix * vec4<f32>(inputs.normals, 0.0)).xyz);\n  outputs.color = inputs.instanceColors;\n\n  // vec4 pickColor = vec4(0., instanceIndexes, 1.0);\n  // picking_setPickingColor(0);\n  \n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  var fragColor = inputs.color;\n  fragColor = dirlight_filterColor(fragColor, DirlightInputs(inputs.normal));\n  return fragColor;\n}\n",vs:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec3 positions;\nin vec3 normals;\n\nin vec2 instanceOffsets;\nin vec3 instanceColors;\nin int instanceIndexes;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 viewMatrix;\n  mat4 projectionMatrix;\n  float time;\n} app;\n\nout vec3 color;\n\nvoid main(void) {\n  color = instanceColors;\n\n  vec3 normal = vec3(app.modelMatrix * vec4(normals, 1.0));\n  dirlight_setNormal(normal);\n  picking_setObjectIndex(instanceIndexes);\n\n  // Vertex position (z coordinate undulates with time), and model rotates around center\n  float delta = length(instanceOffsets);\n  vec4 offset = vec4(instanceOffsets, sin((app.time + delta) * 0.1) * 16.0, 0);\n  gl_Position = app.projectionMatrix * app.viewMatrix * (app.modelMatrix * vec4(positions * 1., 1.0) + offset);\n}\n",fs:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nin vec3 color;\nlayout(location=0) out vec4 fragColor;\nlayout(location=1) out ivec4 pickingColor;\n\nvoid main(void) {\n  pickingColor = picking_getPickingColor();\n\n  fragColor = vec4(color, 1.);\n  fragColor = dirlight_filterColor(fragColor);\n  fragColor = picking_filterColor(fragColor);\n}\n",modules:"webgpu"!==n.info.type?[$e,Ln]:[$e],instanceCount:65536,geometry:new Ve({indices:!0}),bufferLayout:[{name:"instanceOffsets",format:"float32x2"},{name:"instanceColors",format:"unorm8x4"},{name:"instanceIndexes",format:"sint32"}],attributes:{instanceOffsets:d,instanceColors:p,instanceIndexes:h},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}))||this}return(0,s.A)(n,e),n}(Ge),Un={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",viewMatrix:"mat4x4<f32>",projectionMatrix:"mat4x4<f32>",time:"f32"}},Dn=function(e){function n(n){var t,r=n.device,i=n.animationLoop;return(t=e.call(this)||this).shaderInputs=new Re({app:Un,dirlight:$e,picking:Ln}),t.timeline=new E,i.attachTimeline(t.timeline),t.timeline.play(),t.timelineChannels={timeChannel:t.timeline.addChannel({rate:.01}),eyeXChannel:t.timeline.addChannel({rate:3e-4}),eyeYChannel:t.timeline.addChannel({rate:4e-4}),eyeZChannel:t.timeline.addChannel({rate:2e-4})},t.cube=new wn(r,{shaderInputs:t.shaderInputs}),t.picker=new Fn(r,{shaderInputs:t.shaderInputs}),t}(0,s.A)(n,e);var t=n.prototype;return t.onRender=function(e){var n=e.device,t=e.aspect,r=e.tick,i=e._mousePosition,o=this.timelineChannels,a=o.timeChannel,s=o.eyeXChannel,l=o.eyeYChannel,c=o.eyeZChannel;this.shaderInputs.setProps({app:{time:this.timeline.getTime(a),projectionMatrix:(new en.k).perspective({fovy:(0,nn.F2)(60),aspect:t,near:1,far:2048}),viewMatrix:(new en.k).lookAt({center:[0,0,0],eye:[Math.cos(this.timeline.getTime(s))*On/2,Math.sin(this.timeline.getTime(l))*On/2,(Math.sin(this.timeline.getTime(c))+1)*On/4+32]}),modelMatrix:(new en.k).rotateX(.01*r).rotateY(.013*r)}}),this.pickInstance(i);var u=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});this.cube.draw(u),u.end()},t.onFinalize=function(e){this.cube.destroy()},t.pickInstance=function(e){if(e){var n=this.picker.beginRenderPass();this.cube.draw(n),n.end(),"webgl"!==this.picker.device.type&&this.picker.getPickInfo(e)}else this.picker.clearPickState()},n}(Je);Dn.info="  <p>\n  A luma.gl <code>Cube</code>, rendering 65,536 instances in a\n  single GPU draw call using instanced vertex attributes.\n  </P>\n  ",Dn.props={createFramebuffer:!0,debug:!0};var Bn=[-1,-1,1,-1,-1,1,1,1],Gn=function(e){function n(n,t){var r=Bn.map(function(e){return-1===e?0:e});return t.source&&(t=Object.assign({},t,{source:"struct VertexInputs {\n  @location(0) clipSpacePosition: vec2<f32>,\n  @location(1) texCoord: vec2<f32>,\n  @location(2) coordinate: vec2<f32>  \n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) position : vec2<f32>,\n  @location(1) coordinate : vec2<f32>,\n  @location(2) uv : vec2<f32>\n};\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.Position = vec4(inputs.clipSpacePosition, 0., 1.);\n  outputs.position = inputs.clipSpacePosition;\n  outputs.coordinate = inputs.coordinate;\n  outputs.uv = inputs.texCoord;\n  return outputs;\n}\n\n"+t.source})),e.call(this,n,Object.assign({id:t.id||fe("clip-space")},t,{vs:"#version 300 es\nin vec2 clipSpacePositions;\nin vec2 texCoords;\nin vec2 coordinates;\n\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(clipSpacePositions, 0., 1.);\n  position = clipSpacePositions;\n  coordinate = coordinates;\n  uv = texCoords;\n}\n",vertexCount:4,geometry:new He({topology:"triangle-strip",vertexCount:4,attributes:{clipSpacePositions:{size:2,value:new Float32Array(Bn)},texCoords:{size:2,value:new Float32Array(r)},coordinates:{size:2,value:new Float32Array(r)}}})}))||this}return(0,s.A)(n,e),n}(Ge),Xn={name:"background",uniformTypes:{scale:"vec2<f32>"}},Hn=function(e){function n(n,t){var r;if((r=e.call(this,n,{id:t.id||"background-texture-model",source:"@group(0) @binding(0) var backgroundTexture: texture_2d<f32>;\n@group(0) @binding(1) var backgroundTextureSampler: sampler;\nstruct backgroundUniforms {\n  scale: vec2<f32>,\n};\n@group(0) @binding(2) var<uniform> background: backgroundUniforms;\n\nfn billboardTexture_getTextureUV(coordinates: vec2<f32>) -> vec2<f32> {\n        let scale: vec2<f32> = background.scale;\n        var position: vec2<f32> = (coordinates - vec2<f32>(0.5, 0.5)) / scale + vec2<f32>(0.5, 0.5);\n        return position;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n        let position: vec2<f32> = billboardTexture_getTextureUV(inputs.coordinate);\n        return textureSample(backgroundTexture, backgroundTextureSampler, position);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nuniform sampler2D backgroundTexture;\n\nuniform backgroundUniforms {\n  vec2 scale;\n} background;\n\nin vec2 coordinate;\nout vec4 fragColor;\n\nvec2 billboardTexture_getTextureUV(vec2 coord) {\n  vec2 position = (coord - 0.5) / background.scale + 0.5;\n  return position;\n}\n\nvoid main(void) {\n  vec2 position = billboardTexture_getTextureUV(coordinate);\n  fragColor = texture(backgroundTexture, position);\n}\n",modules:[Xn],parameters:Object.assign({depthWriteEnabled:!1},t.blend?{blend:!0,blendColorOperation:"add",blendAlphaOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one-minus-src",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one-minus-src-alpha"}:{})})||this).backgroundTexture=null,!t.backgroundTexture)throw new Error("BackgroundTextureModel requires a backgroundTexture prop");return r.setProps(t),r}(0,s.A)(n,e);var t=n.prototype;return t.setProps=function(e){var n=this,t=e.backgroundTexture;if(t)if(this.setBindings({backgroundTexture:t}),t.isReady){var r=t instanceof Ue?t.texture:t;this.backgroundTexture=r,this.updateScale(r)}else t.ready.then(function(e){n.backgroundTexture=e,n.updateScale(e)})},t.predraw=function(){e.prototype.predraw.call(this)},t.updateScale=function(e){if(e){var n=this.device.getCanvasContext().getDrawingBufferSize(),t=n[0]/n[1],r=e.width/e.height,i=1,o=1;t>r?o=t/r:i=r/t,this.shaderInputs.setProps({background:{scale:[i,o]}})}else this.shaderInputs.setProps({background:{scale:[1,1]}})},n}(Gn),Vn=function(e){function n(n){void 0===n&&(n={});var t=n.id,r=void 0===t?fe("sphere-geometry"):t,i=function(e){for(var n=e.nlat,t=void 0===n?10:n,r=e.nlong,i=void 0===r?10:r,o=0,a=Math.PI-o,s=0,l=2*Math.PI-s,c=(t+1)*(i+1),u=function(n,t,r,i,o){return e.radius||1},f=new Float32Array(3*c),d=new Float32Array(3*c),p=new Float32Array(2*c),h=new(c>65535?Uint32Array:Uint16Array)(t*i*6),m=0;m<=t;m++)for(var g=0;g<=i;g++){var _=g/i,v=m/t,A=g+m*(i+1),E=2*A,T=3*A,b=l*_,x=a*v,R=Math.sin(b),C=Math.cos(b),S=Math.sin(x),I=C*S,P=Math.cos(x),N=R*S,y=u(I,P,N,_,v);f[T+0]=y*I,f[T+1]=y*P,f[T+2]=y*N,d[T+0]=I,d[T+1]=P,d[T+2]=N,p[E+0]=_,p[E+1]=1-v}for(var L=i+1,F=0;F<i;F++)for(var M=0;M<t;M++){var O=6*(F*t+M);h[O+0]=M*L+F,h[O+1]=M*L+F+1,h[O+2]=(M+1)*L+F,h[O+3]=(M+1)*L+F,h[O+4]=M*L+F+1,h[O+5]=(M+1)*L+F+1}return{indices:{size:1,value:h},attributes:{POSITION:{size:3,value:f},NORMAL:{size:3,value:d},TEXCOORD_0:{size:2,value:p}}}}(n),o=i.indices,a=i.attributes;return e.call(this,Object.assign({},n,{id:r,topology:"triangle-list",indices:o,attributes:Object.assign({},a,n.attributes)}))||this}return(0,s.A)(n,e),n}(He);var kn=t(7597),zn={uniformTypes:{color:"vec3<f32>",lighting:"f32",modelViewMatrix:"mat4x4<f32>",projectionMatrix:"mat4x3<f32>"}},jn="#version 300 es\n\nstruct VertexInputs {\n  positions: vec3<f32>;\n  normals: vec3<f32>;\n}\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4<f32>;\n  normal: vec3<f32>;\n}\n\nuniform sphereUniforms {\n  // fragment shader\n  color: vec3<f32>;\n  lighting: bool;\n  // vertex shader\n  modelViewMatrix: mat4<f32>;\n  projectionMatrix: mat4<f32>;\n} sphere;\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  const outputs: VertexOutputs;\n  gl_Position = sphere.projectionMatrix * sphere.modelViewMatrix * vec4(inputs.positions, 1.0);\n  outputs.normal = vec3((sphere.modelViewMatrix * vec4(inputs.normals, 0.0)));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  let attenuation = 1.0;\n  if (sphere.lighting) {\n    light = normalize(vec3(1,1,2));\n    attenuation = dot(normal, light);\n  }\n  return vec4(sphere.color * attenuation, 1);\n}\n",Wn="#version 300 es\n\nin vec3 positions;\nin vec3 normals;\n\nuniform sphereUniforms {\n  // fragment shader\n  vec3 color;\n  bool lighting;\n  // vertex shader\n  mat4 modelViewMatrix;\n  mat4 projectionMatrix;\n} sphere;\n\nout vec3 normal;\n\nvoid main(void) {\n  gl_Position = sphere.projectionMatrix * sphere.modelViewMatrix * vec4(positions, 1.0);\n  normal = vec3((sphere.modelViewMatrix * vec4(normals, 0.0)));\n}\n",Yn="#version 300 es\n\nprecision highp float;\n\nuniform sphereUniforms {\n  // fragment\n  vec3 color;\n  bool lighting;\n  // vertex\n  mat4 modelViewMatrix;\n  mat4 projectionMatrix;\n} sphere;\n\nin vec3 normal;\nout vec4 fragColor;\n\nvoid main(void) {\n  float attenuation = 1.0;\n  if (sphere.lighting) {\n    vec3 light = normalize(vec3(1,1,2));\n    attenuation = dot(normal, light);\n  }\n  fragColor = vec4(sphere.color * attenuation, 1);\n}\n",Qn={uniformTypes:{resolution:"vec2<f32>"}},Kn="fn getQuadVertex(vertexIndex : u32) -> vec2f {\n  // SCREEN QUAD\n  let positions = array(\n    // 1st triangle\n    vec2f( 0.0,  0.0),  // center\n    vec2f( 1.0,  0.0),  // right, center\n    vec2f( 0.0,  1.0),  // center, top\n    // 2st triangle\n    vec2f( 0.0,  1.0),  // center, top\n    vec2f( 1.0,  0.0),  // right, center\n    vec2f( 1.0,  1.0),  // right, top\n  );\n  return positions[vertexIndex];\n}\n",Zn="\n"+Kn+"\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4f,\n  @location(0) texcoord: vec2f,\n};\n\n@vertex fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  let xy = getQuadVertex(vertexIndex);\n  outputs.position = vec4f(xy, 0.0, 1.0);\n  outputs.texcoord = xy;\n  return outputs;\n}\n\n@group(0) @binding(0) var texture : texture_2d<f32>;\n@group(0) @binding(1) var sampler : sampler;\n\n@fragment fn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  return textureSample(texture, sampler, inputs.texcoord);\n}\n",qn="#version 300 es\n\nin vec2 aPosition;\n\nvoid main(void) {\n  gl_Position = vec4(aPosition, 0, 1);\n}\n",Jn={uniformTypes:{resolution:"vec2<f32>"}},$n="\n"+Kn+"\n\nstruct FragmentInputs {\n  @builtin(position) position: vec4f,\n  @location(0) texcoord: vec2f,\n};\n\n@vertex fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  let xy = getQuadVertex(vertexIndex);\n  outputs.position = vec4f(xy, 0.0, 1.0);\n  outputs.texcoord = xy;\n  return outputs;\n}\n\n@group(0) @binding(0) var sceneTexture : texture_2d<f32>;\n@group(0) @binding(1) var persistenceTexture : texture_2d<f32>;\n@group(0) @binding(2) var sampler : sampler;\n\n@fragment \nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let sceneColor = textureSample(sceneTexture, sampler, inputs.texcoord);\n  let persistenceColor = textureSample(persistenceTexture, sampler, inputs.texcoord);\n  return mix(sceneColor * 4.0, persistenceColor, 0.9);\n}\n",et=_(),nt=[],tt=[],rt=[],it=function(e){function n(n){var t,r=n.device,i=n.width,o=n.height;(t=e.call(this)||this).uniformStore=new g({sphere:zn,screenQuad:Qn,persistenceQuad:Jn}),t.backgroundTextureModel=new Hn(r,{backgroundTexture:new Ue(r,{data:(0,an.Dt)("background.png")}),blend:!0}),t.electron=new Ge(r,{id:"electron",source:jn,vs:Wn,fs:Yn,geometry:new Vn({nlat:20,nlong:30}),bindings:{sphere:t.uniformStore.getManagedUniformBuffer(r,"sphere")},parameters:{depthWriteEnabled:!0,depthCompare:"less",cullMode:"back"}}),t.nucleon=new Ge(r,{id:"nucleon",source:jn,vs:Wn,fs:Yn,geometry:new Vn({nlat:20,nlong:30}),parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"},bindings:{sphere:t.uniformStore.getManagedUniformBuffer(r,"sphere")}}),t.mainFramebuffer=r.createFramebuffer({width:i,height:o,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"}),t.pingpongFramebuffers=[r.createFramebuffer({width:i,height:o,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"}),r.createFramebuffer({width:i,height:o,colorAttachments:["rgba8unorm"],depthStencilAttachment:"depth24plus"})];var a=new He({topology:"triangle-list",attributes:{aPosition:{value:new Float32Array([-1,-1,1,-1,1,1,-1,-1,1,1,-1,1]),size:2}},vertexCount:6});t.screenQuad=new Ge(r,{id:"quad",source:Zn,vs:qn,fs:"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D uTexture;\n\nuniform screenQuadUniforms {\n  vec2 resolution;\n} screenQuad;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec2 p = gl_FragCoord.xy/screenQuad.resolution.xy;\n  fragColor = texture(uTexture, p);\n}\n",geometry:a,bindings:{screenQuad:t.uniformStore.getManagedUniformBuffer(r,"screenQuad")},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"}}),t.persistenceQuad=new Ge(r,{id:"persistence-quad",source:$n,vs:qn,fs:"#version 300 es\n\nprecision highp float;\n\nuniform sampler2D uScene;\nuniform sampler2D uPersistence;\n\nuniform persistenceQuadUniforms {\n  vec2 resolution;\n} persistence;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec2 p = gl_FragCoord.xy / persistence.resolution.xy;\n  vec4 cS = texture(uScene, p);\n  vec4 cP = texture(uPersistence, p);\n  fragColor = mix(cS*4.0, cP, 0.9);\n}\n",geometry:a,bindings:{persistenceQuad:t.uniformStore.getManagedUniformBuffer(r,"persistenceQuad")},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal",cullMode:"back"}});for(var s=0;s<64;s++){var l=new kn.P(et()-.5,et()-.5,et()-.5),c=et()+1;l.normalize().scale(c);l.scale(1.25),nt.push(l);var u=new kn.P(et()-.5,et()-.5,et()-.5),f=l.clone().cross(u).normalize(),d=4/c*.0125,p=(new en.k).rotateAxis(d,f);tt.push(p)}for(var h=0;h<64;h++){var m=new kn.P(et()-.5,et()-.5,et()-.5);m=m.normalize().scale(.5),rt.push(m)}return t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(e){this.electron.destroy(),this.nucleon.destroy(),this.mainFramebuffer.destroy(),this.pingpongFramebuffers[0].destroy(),this.pingpongFramebuffers[1].destroy(),this.screenQuad.destroy(),this.persistenceQuad.destroy()},t.onRender=function(e){var n=e.device,t=e.tick,r=e.width,i=e.height,o=e.aspect;this.mainFramebuffer.resize({width:r,height:i}),this.pingpongFramebuffers[0].resize({width:r,height:i}),this.pingpongFramebuffers[1].resize({width:r,height:i});var a=(new en.k).perspective({fovy:(0,nn.F2)(75),aspect:o}),s=(new en.k).lookAt({eye:[0,0,4]}),l=n.beginRenderPass({framebuffer:this.mainFramebuffer,clearColor:[0,0,0,1],clearDepth:1});this.uniformStore.setUniforms({sphere:{color:[0,.5,1],lighting:!1}});for(var c=0;c<64;c++){nt[c]=tt[c].transformVector(nt[c]);var u=(new en.k).translate(nt[c]).scale([.06125,.06125,.06125]);this.uniformStore.setUniforms({sphere:{modelViewMatrix:s.clone().multiplyRight(u),projectionMatrix:a}}),this.uniformStore.updateUniformBuffers(),this.electron.draw(l)}this.uniformStore.setUniforms({sphere:{color:[1,.25,.25],lighting:!0}});for(var f=0;f<64;f++){var d=(new en.k).rotateXYZ([.013*t,0,0]).rotateXYZ([0,.021*t,0]).translate(rt[f]),p=[d[12],d[13],d[14]];d.identity().translate(p).scale([.25,.25,.25]),this.uniformStore.setUniforms({sphere:{modelViewMatrix:s.clone().multiplyRight(d),projectionMatrix:a}}),this.uniformStore.updateUniformBuffers(),this.nucleon.draw(l)}l.end();var h=t%2,m=this.pingpongFramebuffers[h],g=this.pingpongFramebuffers[1-h],_=n.beginRenderPass({framebuffer:m,clearColor:[0,0,0,0]});this.persistenceQuad.setBindings({uScene:this.mainFramebuffer.colorAttachments[0],uPersistence:g.colorAttachments[0]}),this.uniformStore.setUniforms({persistenceQuad:{resolution:[r,i]}}),this.uniformStore.updateUniformBuffers(),this.persistenceQuad.draw(_),_.end();var v=n.beginRenderPass({clearColor:[0,0,0,1]});this.screenQuad.setBindings({uTexture:m.colorAttachments[0]}),this.uniformStore.setUniforms({screenQuad:{resolution:[r,i]}}),this.uniformStore.updateUniformBuffers(),this.screenQuad.draw(v),this.backgroundTextureModel.draw(v),v.end()},n}(Je);it.info="\n<p>\n  Electron trails renderings persist across multiple frames.\n<p>\n  Uses multiple luma.gl <code>Framebuffer</code>s to hold previously rendered data between frames.\n</p>\n";var ot=function(){function e(e){this.id=e.id||"swap",this.current=e.current,this.next=e.next}var n=e.prototype;return n.destroy=function(){var e,n;null==(e=this.current)||e.destroy(),null==(n=this.next)||n.destroy()},n.swap=function(){var e=this.current;this.current=this.next,this.next=e},e}(),at=function(e){function n(n,t){var r,i,o=t=Object.assign({},t),a=o.width,s=void 0===a?1:a,l=o.height,c=void 0===l?1:l,u=null==(r=t.colorAttachments)?void 0:r.map(function(e){return"string"!=typeof e?e:n.createTexture({id:t.id+"-texture-0",format:e,usage:R.g.SAMPLE|R.g.RENDER|R.g.COPY_SRC|R.g.COPY_DST,width:s,height:c})}),f=n.createFramebuffer(Object.assign({},t,{colorAttachments:u}));u=null==(i=t.colorAttachments)?void 0:i.map(function(e){return"string"!=typeof e?e:n.createTexture({id:t.id+"-texture-1",format:e,usage:R.g.SAMPLE|R.g.RENDER|R.g.COPY_SRC|R.g.COPY_DST,width:s,height:c})});var d=n.createFramebuffer(Object.assign({},t,{colorAttachments:u}));return e.call(this,{current:f,next:d})||this}return(0,s.A)(n,e),n.prototype.resize=function(e){if(e.width===this.current.width&&e.height===this.current.height)return!1;var n=this.current,t=this.next;return this.current=n.clone(e),n.destroy(),this.next=t.clone(e),t.destroy(),!0},n}(ot);var st=function(){function e(e,n){this.device=e,n.shaderPasses.map(function(e){return X(e)});var t=n.shaderPasses.reduce(function(e,n){var t;return Object.assign({},e,((t={})[n.name]=n,t))},{});this.shaderInputs=n.shaderInputs||new Re(t);var r=e.getCanvasContext().getDrawingBufferSize();this.swapFramebuffers=new at(e,{colorAttachments:[e.preferredColorFormat],width:r[0],height:r[1]}),this.textureModel=new Hn(e,{backgroundTexture:this.swapFramebuffers.current.colorAttachments[0].texture}),this.clipSpace=new Gn(e,{source:"  @group(0) @binding(0) var sourceTexture: texture_2d<f32>;\n  @group(0) @binding(1) var sourceTextureSampler: sampler;\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n\tlet texCoord: vec2<f32> = inputs.coordinate;\n\treturn textureSample(sourceTexture, sourceTextureSampler, texCoord);\n}\n",fs:"#version 300 es\n\nuniform sampler2D sourceTexture;\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = texture(sourceTexture, uv);\n}\n"}),this.passRenderers=n.shaderPasses.map(function(n){return new lt(e,n)})}var n=e.prototype;return n.destroy=function(){for(var e,n=(0,a.A)(this.passRenderers);!(e=n()).done;){e.value.destroy()}this.swapFramebuffers.destroy(),this.clipSpace.destroy(),this.textureModel.destroy()},n.resize=function(e){e||(e=this.device.getCanvasContext().getDrawingBufferSize()),this.swapFramebuffers.resize({width:e[0],height:e[1]})},n.renderToScreen=function(e){var n=this.renderToTexture(e);if(!n)return!1;var t=this.device.getDefaultCanvasContext().getCurrentFramebuffer({depthStencilAttachment:!1}),r=this.device.beginRenderPass({id:"shader-pass-renderer-to-screen",framebuffer:t,clearDepth:1});return this.clipSpace.setBindings({sourceTexture:n}),this.clipSpace.draw(r),r.end(),!0},n.renderToTexture=function(e){var n=e.sourceTexture;if(!n.isReady)return null;if(0===this.passRenderers.length)return n.texture;this.textureModel.setProps({backgroundTexture:n});var t=this.device.beginRenderPass({id:"shader-pass-renderer-clear-texture",framebuffer:this.swapFramebuffers.current,clearColor:[1,0,0,1]});this.textureModel.draw(t),t.end();for(var r,i=!0,o=(0,a.A)(this.passRenderers);!(r=o()).done;)for(var s,l=r.value,c=(0,a.A)(l.subPassRenderers);!(s=c()).done;){var u=s.value;i||this.swapFramebuffers.swap(),i=!1;var f={sourceTexture:this.swapFramebuffers.current.colorAttachments[0].texture},d=this.device.beginRenderPass({id:"shader-pass-renderer-run-pass",framebuffer:this.swapFramebuffers.next,clearColor:[0,0,0,1],clearDepth:1});u.render({renderPass:d,bindings:f}),d.end()}return this.swapFramebuffers.swap(),this.swapFramebuffers.current.colorAttachments[0].texture},e}(),lt=function(){function e(e,n,t){void 0===t&&(t={}),this.shaderPass=n;var r=n.passes||[];this.subPassRenderers=r.map(function(t){return new ct(e,n,t)})}return e.prototype.destroy=function(){for(var e,n=(0,a.A)(this.subPassRenderers);!(e=n()).done;){e.value.destroy()}},e}(),ct=function(){function e(e,n,t){this.shaderPass=n,this.subPass=t;var r=function(e){var n=e.shaderPass,t=e.action,r=e.shadingLanguage;switch(t){case"filter":var i=n.name+"_filterColor_ext";return"wgsl"===r?"// Binding 0:1 is reserved for shader passes\n// @group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var textureSampler: sampler;\n\n// This needs to be aligned with\n// struct FragmentInputs {\n//   @location(0) fragUV: vec2f,\n//   @location(1) fragPosition: vec4f,\n//   @location(2) fragCoordinate: vec4f\n// };\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let fragUV = inputs.uv;\n  let fragCoordinate = inputs.coordinate;\n  let texSize = vec2f(textureDimensions(texture, 0));\n\n  var fragColor = textureSample(texture, textureSampler, fragUV);\n  fragColor = "+i+"(fragColor, texSize, fragCoordinate);\n  return fragColor;\n}\n":"#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = texture(sourceTexture, texCoord);\n  fragColor = "+i+"(fragColor, texSize, texCoord);\n}\n";case"sample":var o=n.name+"_sampleColor";return"wgsl"===r?function(e){return"// Binding 0:1 is reserved for shader passes\n@group(0) @binding(0) var<uniform> brightnessContrast : brightnessContrastUniforms;\n@group(0) @binding(1) var texture: texture_2d<f32>;\n@group(0) @binding(2) var sampler: sampler;\n\nstruct FragmentInputs = {\n  @location(0) fragUV: vec2f,\n  @location(1) fragPosition: vec4f,\n  @location(2) fragCoordinate: vec4f\n};\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4f {\n  let texSize = vec2f(textureDimensions(texture, 0));\n  var fragColor = textureSample(texture, sampler, fragUV);\n  fragColor = "+e+"(fragColor, texSize, texCoord);\n  return fragColor;\n}\n"}(o):function(e){return"#version 300 es\n\nuniform sampler2D sourceTexture;\n\nin vec2 position;\nin vec2 coordinate;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n  ivec2 iTexSize = textureSize(sourceTexture, 0);\n  vec2 texSize = vec2(float(iTexSize.x), float(iTexSize.y));\n\n  fragColor = "+e+"(sourceTexture, texSize, texCoord);\n}\n"}(o);default:throw new Error(n.name+" no fragment shader generated for shader pass")}}({shaderPass:n,action:t.action||t.filter&&"filter"||t.sampler&&"sample"||"filter",shadingLanguage:e.info.shadingLanguage});this.model=new Gn(e,{id:n.name+"-subpass",source:r,fs:r,modules:[n],parameters:{depthWriteEnabled:!1}})}var n=e.prototype;return n.destroy=function(){this.model.destroy()},n.render=function(e){var n,t,r=e.renderPass,i=e.bindings;this.model.shaderInputs.setProps(((n={})[this.shaderPass.name]=this.shaderPass.uniforms||{},n)),this.model.shaderInputs.setProps(((t={})[this.shaderPass.name]=this.subPass.uniforms||{},t)),this.model.setBindings(i||{}),this.model.draw(r)},e}(),ut={name:"brightnessContrast",source:"struct brightnessContrastUniforms {\n  brightness: f32,\n  contrast: f32\n};\n\n// Binding 0:1 is reserved for shader passes\n@group(0) @binding(1) var<uniform> brightnessContrast : brightnessContrastUniforms;\n\nfn brightnessContrast_filterColor_ext(color: vec4f, texSize: vec2<f32>, texCoords: vec2<f32>) -> vec4f {\n  color.rgb += brightnessContrast.brightness;\n  if (brightnessContrast.contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;\n  }\n  return vec4f(1.0, 0.0, 0.0, 1.0);\n}\n",fs:"uniform brightnessContrastUniforms {\n  float brightness;\n  float contrast;\n} brightnessContrast;\n\nvec4 brightnessContrast_filterColor(vec4 color) {\n  color.rgb += brightnessContrast.brightness;\n  if (brightnessContrast.contrast > 0.0) {\n    color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;\n  } else {\n    color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;\n  }\n  return color;\n}\n\nvec4 brightnessContrast_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return brightnessContrast_filterColor(color);\n}\n",props:{},uniformTypes:{brightness:"f32",contrast:"f32"},defaultUniforms:{brightness:0,contrast:0},propTypes:{brightness:{format:"f32",value:0,min:-1,max:1},contrast:{format:"f32",value:0,min:-1,max:1}},passes:[{filter:!0}]},ft={props:{},uniforms:{},name:"denoise",uniformTypes:{strength:"f32"},propTypes:{strength:{format:"f32",value:.5,min:0,max:1}},source:"\nstruct denoiseUniforms {\n  strength: f32\n};\n\n@group(0), @binding(1) var<uniform> denoise: denoiseUniforms;\n\nfn denoise_sampleColor(source: sampler2D, texSize: vec2<f32>, texCoord: vec2<f32>) -> vec4<f32> {\n\tlet adjustedExponent: f32 = 3. + 200. * pow(1. - denoise.strength, 4.);\n\tlet center: vec4<f32> = sample_texture(BUFFER_source, texCoord);\n\tvar color: vec4<f32> = vec4<f32>(0.);\n\tvar total: f32 = 0.;\n\n\tfor (var x: f32 = -4.; x <= 4.; x = x + (1.)) {\n\n\t\tfor (var y: f32 = -4.; y <= 4.; y = y + (1.)) {\n\t\t\tlet offsetColor: vec4<f32> = sample_texture(BUFFER_source, texCoord + vec2<f32>(x, y) / texSize);\n\t\t\tvar weight: f32 = 1. - abs(dot(offsetColor.rgb - center.rgb, vec3<f32>(0.25)));\n\t\t\tweight = pow(weight, adjustedExponent);\n\t\t\tcolor = color + (offsetColor * weight);\n\t\t\ttotal = total + (weight);\n\t\t}\n\n\t}\n\n\treturn color / total;\n} \n",fs:"uniform dedenoiseUniforms {\n  float strength;\n} denoise;\n\nvec4 dedenoise_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  float adjustedExponent = 3. + 200. * pow(1. - noise.strength, 4.);\n\n  vec4 center = texture(source, texCoord);\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  for (float x = -4.0; x <= 4.0; x += 1.0) {\n    for (float y = -4.0; y <= 4.0; y += 1.0) {\n      vec4 offsetColor = texture(source, texCoord + vec2(x, y) / texSize);\n      float weight = 1.0 - abs(dot(offsetColor.rgb - center.rgb, vec3(0.25)));\n      weight = pow(weight, adjustedExponent);\n      color += offsetColor * weight;\n      total += weight;\n    }\n  }\n\n  return color / total;\n}\n",passes:[{sampler:!0},{sampler:!0}]},dt={props:{},name:"hueSaturation",source:"\nstruct hueSaturationUniforms {\n  hue: f32,\n  saturation: f32,\n};\n\n@group(0), @binding(1) var<uniform> hueSaturation: hueSaturationUniforms;\n\nfn hueSaturation_filterColor(color: vec4<f32>) -> vec4<f32> {\n\tlet angle: f32 = hueSaturation.hue * 3.1415927;\n\tlet s: f32 = sin(angle);\n\tlet c: f32 = cos(angle);\n\tlet weights: vec3<f32> = (vec3<f32>(2. * c, -sqrt(3.) * s - c, sqrt(3.) * s - c) + 1.) / 3.;\n\tlet len: f32 = length(color.rgb);\n\tvar colorrgb = color.rgb;\n\tcolorrgb = vec3<f32>(dot(color.rgb, weights.xyz), dot(color.rgb, weights.zxy), dot(color.rgb, weights.yzx));\n\tcolor.r = colorrgb.x;\n\tcolor.g = colorrgb.y;\n\tcolor.b = colorrgb.z;\n\tlet average: f32 = (color.r + color.g + color.b) / 3.;\n\tif (hueSaturation.saturation > 0.) {\n\t\tvar colorrgb = color.rgb;\n\tcolorrgb = color.rgb + ((average - color.rgb) * (1. - 1. / (1.001 - hueSaturation.saturation)));\n\tcolor.r = colorrgb.x;\n\tcolor.g = colorrgb.y;\n\tcolor.b = colorrgb.z;\n\t} else { \n\t\tvar colorrgb = color.rgb;\n\tcolorrgb = color.rgb + ((average - color.rgb) * -hueSaturation.saturation);\n\tcolor.r = colorrgb.x;\n\tcolor.g = colorrgb.y;\n\tcolor.b = colorrgb.z;\n\t}\n\treturn color;\n} \n\nfn hueSaturation_filterColor_ext(color: vec4<f32>, texSize: vec2<f32>, texCoord: vec2<f32>) -> vec4<f32> {\n\treturn hueSaturation_filterColor(color);\n} \n",fs:"uniform hueSaturationUniforms {\n  float hue;\n  float saturation;\n} hueSaturation;\n\nvec4 hueSaturation_filterColor(vec4 color) {\n  // hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}]\n  float angle = hueSaturation.hue * 3.14159265;\n  float s = sin(angle), c = cos(angle);\n  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\n  float len = length(color.rgb);\n  color.rgb = vec3(\n    dot(color.rgb, weights.xyz),\n    dot(color.rgb, weights.zxy),\n    dot(color.rgb, weights.yzx)\n  );\n\n  // saturation adjustment\n  float average = (color.r + color.g + color.b) / 3.0;\n  if (hueSaturation.saturation > 0.0) {\n    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - hueSaturation.saturation));\n  } else {\n    color.rgb += (average - color.rgb) * (-hueSaturation.saturation);\n  }\n\n  return color;\n}\n\nvec4 hueSaturation_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return hueSaturation_filterColor(color);\n}\n",uniformTypes:{hue:"f32",saturation:"f32"},propTypes:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},passes:[{filter:!0}]},pt={name:"noise",fs:"uniform noiseUniforms {\n  float amount;\n} noise;\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float diff = (rand(texCoord) - 0.5) * noise.amount;\n  color.r += diff;\n  color.g += diff;\n  color.b += diff;\n  return color;\n}\n",source:"struct noiseUniforms {\n  amount: f32\n};\n\n@group(0) @binding(1) var<uniform> noise: noiseUniforms;\n\nfn rand(co: vec2f) -> f32 {\n\treturn fract(sin(dot(co.xy, vec2f(12.9898, 78.233))) * 43758.547);\n} \n\nfn noise_filterColor_ext(color: vec4f, texSize: vec2f, texCoord: vec2f) -> vec4f {\n\tlet diff: f32 = (rand(texCoord) - 0.5) * noise.amount;\n\tcolor.r = color.r + (diff);\n\tcolor.g = color.g + (diff);\n\tcolor.b = color.b + (diff);\n\treturn color;\n} \n",props:{},uniforms:{},uniformTypes:{amount:"f32"},propTypes:{amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]},ht={props:{},uniforms:{},name:"sepia",uniformTypes:{amount:"f32"},propTypes:{amount:{value:.5,min:0,max:1}},fs:"uniform sepiaUniforms {\n  float amount;\n} sepia;\n\nvec4 sepia_filterColor(vec4 color) {\n  float r = color.r;\n  float g = color.g;\n  float b = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));\n  color.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));\n  color.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n",source:"struct sepiaUniforms {\n  amount: f32\n};\n\n@group(0) @binding(1) var<uniform> sepia: sepiaUniforms;\n\nfn sepia_filterColor(color: vec4f) -> vec4f {\n  let r: f32 = color.r;\n  let g: f32 = color.g;\n  let b: f32 = color.b;\n\n  color.r =\n    min(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));\n  color.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));\n  color.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));\n\n  return color;\n}\n\nvec4 sepia_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return sepia_filterColor(color);\n}\n",passes:[{filter:!0}]},mt={props:{},uniforms:{},name:"vibrance",uniformTypes:{amount:"f32"},propTypes:{amount:{value:0,min:-1,max:1}},source:"struct vibranceUniforms {\n  amount: f32\n};\n\n@group(0) @binding(1) var<uniform> vibrance: vibranceUniforms;\n\nfn vibrance_filterColor(vec4f color) -> vec4f {\n  let average: f32 = (color.r + color.g + color.b) / 3.0;\n  let mx: f32 = max(color.r, max(color.g, color.b));\n  let amt: f32 = (mx - average) * (-vibrance.amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n",fs:"uniform vibranceUniforms {\n  float amount;\n} vibrance;\n\nvec4 vibrance_filterColor(vec4 color) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  float mx = max(color.r, max(color.g, color.b));\n  float amt = (mx - average) * (-vibrance.amount * 3.0);\n  color.rgb = mix(color.rgb, vec3(mx), amt);\n  return color;\n}\n\nvec4 vibrance_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return vibrance_filterColor(color);\n}\n",passes:[{filter:!0}]},gt={props:{},uniforms:{},name:"vignette",source:"struct vignetteUniforms {\n  radius: f32,\n  amount: f32\n};\n\n@group(0) @binding(1) var<uniform> vignette: vignetteUniforms;\n\nfn vibrance_filterColor(color: vec4f) -> vec4f {\n  let average: f32 = (color.r + color.g + color.b) / 3.0;\n  let mx: f32 = max(color.r, max(color.g, color.b));\n  let amt: f32 = (mx - average) * (-vibrance.amount * 3.0);\n  color.rgb = mix(color.rgb, vec3f(mx), amt);\n  return color;\n}\n\nfn vignette_filterColor_ext(color: vec4f, texSize: vec2f, texCoord: vec2f) ->vec4f {\n  let dist: f32 = distance(texCoord, vec2f(0.5, 0.5));\n  let ratio: f32 = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4f(0.0, 0.0, 0.0, 1.0);\n}\n",fs:"uniform vignetteUniforms {\n  float radius;\n  float amount;\n} vignette;\n\nvec4 vignette_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float dist = distance(texCoord, vec2(0.5, 0.5));\n  float ratio = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));\n  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);\n}\n",uniformTypes:{radius:"f32",amount:"f32"},defaultUniforms:{radius:.5,amount:.5},propTypes:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]},_t={name:"random",source:"fn random(scale: vec3f, seed: float) -> f32 {\n  /* use the fragment position for a different seed per-pixel */\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n",fs:"float random(vec3 scale, float seed) {\n  /* use the fragment position for a different seed per-pixel */\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n"},vt={name:"tiltShift",dependencies:[_t],source:"uniform tiltShiftUniforms {\n  blurRadius: f32,\n  gradientRadius: f32,\n  start: vec2f,\n  end: vec2f,\n  invert: u32,\n};\n\n@group(0) @binding(1) var<uniform> tiltShift: tiltShiftUniforms;\n\nfn tiltShift_getDelta(vec2 texSize) -> vec2f {\n  vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);\n  return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nfn tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  return color;\n}\n",fs:"uniform tiltShiftUniforms {\n  float blurRadius;\n  float gradientRadius;\n  vec2 start;\n  vec2 end;\n  bool invert;\n} tiltShift;\n\nvec2 tiltShift_getDelta(vec2 texSize) {\n  vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);\n  return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;\n}\n\nvec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));\n  float radius = smoothstep(0.0, 1.0,\n    abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  return color;\n}\n",props:{},uniforms:{},uniformTypes:{blurRadius:"f32",gradientRadius:"f32",start:"vec2<f32>",end:"vec2<f32>",invert:"i32"},propTypes:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:{value:[0,0]},end:{value:[1,1]},invert:{value:0,private:!0}},passes:[{sampler:!0,uniforms:{invert:0}},{sampler:!0,uniforms:{invert:1}}]},At={name:"triangleBlur",dependencies:[_t],source:"uniform triangleBlurUniforms {\n  radius: f32,\n  delta: vec2f,\n}\n\n@group(0) @binding(1) var<uniform> triangleBlur: triangleBlurUniforms;\n\nvec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",fs:"uniform triangleBlurUniforms {\n  float radius;\n  vec2 delta;\n} triangleBlur;\n\nvec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;\n\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);\n\n    /* switch to pre-multiplied alpha to correctly blur transparent images */\n    offsetColor.rgb *= offsetColor.a;\n\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n\n  /* switch back from pre-multiplied alpha */\n  color.rgb /= color.a + 0.00001;\n\n  return color;\n}\n",props:{},uniforms:{},uniformTypes:{radius:"f32",delta:"vec2<f32>"},propTypes:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]},Et={name:"zoomBlur",dependencies:[_t],source:"\nuniform zoomBlurUniforms {\n  center: vec2f,\n  strength: f32,\n};\n\n@group(0) @binding(1) var<uniform> zoomBlur : zoomBlurUniforms;\n\n\nfn zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  return color;\n}\n",fs:"\nuniform zoomBlurUniforms {\n  vec2 center;\n  float strength;\n} zoomBlur;\n\nvec4 zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec4 color = vec4(0.0);\n  float total = 0.0;\n  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = 0.0; t <= 40.0; t++) {\n    float percent = (t + offset) / 40.0;\n    float weight = 4.0 * (percent - percent * percent);\n    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);\n    color += offsetColor * weight;\n    total += weight;\n  }\n\n  color = color / total;\n  return color;\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",strength:"f32"},propTypes:{center:{value:[.5,.5]},strength:{value:.3,min:0,softMax:1}},passes:[{sampler:!0}]},Tt={name:"colorHalftone",source:"struct colorHalftoneUniforms {\n  center: vec2f,\n  angle: f32,\n  size: f32.\n};\n\n@group(0) @binding(1) var<uniform> colorHalftone: colorHalftoneUniforms;\n\nfn pattern(angle: f32, scale: f32, texSize: vec2f, texCoord: vec2f) -> f32 {\n  let s: f32 = sin(angle), c = cos(angle);\n  let tex: vec2f = texCoord * texSize - colorHalftone.center * texSize;\n  let point: vec2f = vec2(\n\t  c * tex.x - s * tex.y,\n\t  s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nfn colorHalftone_filterColor_ext(vec4f color, vec2f texSize, vec2f texCoord) -> vec4f {\n  let scale: f32 = 3.1514 / colorHalftone.size;\n  let cmy: vec3f = 1.0 - color.rgb;\n  let k: f32 = min(cmy.x, min(cmy.y, cmy.z));\n\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\t  cmy * 10.0 - 3.0 + vec3(\n      pattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),\n\t    pattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),\n      pattern(colorHalftone.angle, scale, texSize, texCoord)\n    ),\n\t  0.0,\n\t  1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n",fs:"uniform colorHalftoneUniforms {\n  vec2 center;\n  float angle;\n  float size;\n} colorHalftone;\n\nfloat pattern(float angle, float scale, vec2 texSize, vec2 texCoord) {\n  float s = sin(angle), c = cos(angle);\n  vec2 tex = texCoord * texSize - colorHalftone.center * texSize;\n  vec2 point = vec2(\n\tc * tex.x - s * tex.y,\n\ts * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 colorHalftone_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float scale = 3.1514 / colorHalftone.size;\n  vec3 cmy = 1.0 - color.rgb;\n  float k = min(cmy.x, min(cmy.y, cmy.z));\n\n  cmy = (cmy - k) / (1.0 - k);\n  cmy = clamp(\n\t  cmy * 10.0 - 3.0 + vec3(\n      pattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),\n\t    pattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),\n      pattern(colorHalftone.angle, scale, texSize, texCoord)\n    ),\n\t  0.0,\n\t  1.0\n  );\n  k = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);\n  return vec4(1.0 - cmy - k, color.a);\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},propTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},passes:[{filter:!0}]},bt={name:"dotScreen",source:"uniform dotScreenUniforms {\n  center: vec2f,\n  angle: f32,\n  size: f32,\n};\n\n@group(0) @binding(1) dotScreen: dotScreenUniforms;\n\nfn pattern(texSize: vec2f, texCoord: vec2f) -> f32 {\n  let scale: f32 = 3.1415 / dotScreen.size;\n\n  let s: f32 = sin(dotScreen.angle), c = cos(dotScreen.angle);\n  tex: vec2f = texCoord * texSize - dotScreen.center * texSize;\n  point = vec2f( \n    c: * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nfn dotScreen_filterColor_ext(vec4 color, texSize: vec2f, texCoord: vec2f) -> vec4f {\n  let average: f32 = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n",fs:"uniform dotScreenUniforms {\n  vec2 center;\n  float angle;\n  float size;\n} dotScreen;\n\nfloat pattern(vec2 texSize, vec2 texCoord) {\n  float scale = 3.1415 / dotScreen.size;\n\n  float s = sin(dotScreen.angle), c = cos(dotScreen.angle);\n  vec2 tex = texCoord * texSize - dotScreen.center * texSize;\n  vec2 point = vec2(\n    c * tex.x - s * tex.y,\n    s * tex.x + c * tex.y\n  ) * scale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvec4 dotScreen_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  float average = (color.r + color.g + color.b) / 3.0;\n  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},propTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},passes:[{filter:!0}]},xt={name:"edgeWork",dependencies:[_t],source:"struct edgeWorkUniforms {\n  radius: f32,\n  int mode: uint32,\n};\n\n@group(0) @binding(1) var<uniform> edgeWork: edgeWorkUniforms;\n\nfn edgeWork_sampleColorRGB(sampler2D source, vec2 texSize, vec2 texCoord, vec2 delta) -> vec4f {\n  vec2 relativeDelta = edgeWork.radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n",fs:"uniform edgeWorkUniforms {\n  float radius;\n  int mode;\n} edgeWork;\n\nvec4 edgeWork_sampleColorRGB(sampler2D source, vec2 texSize, vec2 texCoord, vec2 delta) {\n  vec2 relativeDelta = edgeWork.radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;\n    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;\n    color.x += average * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += average * weight;\n      total.y += weight;\n    }\n  }\n  return vec4(color / total, 0.0, 1.0);\n}\n\nvec4 edgeWork_sampleColorXY(sampler2D source, vec2 texSize, vec2 texCoord, vec2 delta) {\n  vec2 relativeDelta = edgeWork.radius * delta / texSize;\n\n  vec2 color = vec2(0.0);\n  vec2 total = vec2(0.0);\n\n  /* randomize the lookup values to hide the fixed number of samples */\n  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n  for (float t = -30.0; t <= 30.0; t++) {\n    float percent = (t + offset - 0.5) / 30.0;\n    float weight = 1.0 - abs(percent);\n    vec2 sampleColor = texture(source, texCoord + relativeDelta * percent).xy;\n    color.x += sampleColor.x * weight;\n    total.x += weight;\n    if (abs(t) < 15.0) {\n      weight = weight * 2.0 - 1.0;\n      color.y += sampleColor.y * weight;\n      total.y += weight;\n    }\n  }\n  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\n  return vec4(c, c, c, 1.0);\n}\n\nvec4 edgeWork_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  switch (edgeWork.mode) {\n    case 0: \n    return edgeWork_sampleColorRGB(source, texSize, texCoord, vec2(1., 0.));\n    case 1: \n    default:\n      return edgeWork_sampleColorXY(source, texSize, texCoord, vec2(0., 1.));\n  }\n}\n",props:{},uniforms:{},uniformTypes:{radius:"f32",mode:"i32"},propTypes:{radius:{value:2,min:1,softMax:50},mode:{value:0,private:!0}},passes:[{sampler:!0,uniforms:{mode:0}},{sampler:!0,uniforms:{mode:1}}]},Rt={name:"hexagonalPixelate",source:"struct hexagonalPixelateUniforms {\n  center: vec2f,\n  scale: f32,\n};\n\n@group(0) @binding(1) var<uniform> hexagonalPixelate: hexagonalPixelateUniforms;\n\nfn hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= hexagonalPixelate.scale / texSize;\n\n  return texture(source, choice + hexagonalPixelate.center);\n}\n",fs:"uniform hexagonalPixelateUniforms {\n  vec2 center;\n  float scale;\n} hexagonalPixelate;\n\nvec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;\n  tex.y /= 0.866025404;\n  tex.x -= tex.y * 0.5;\n\n  vec2 a;\n  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {\n    a = vec2(floor(tex.x), floor(tex.y));\n  }\n  else a = vec2(ceil(tex.x), ceil(tex.y));\n  vec2 b = vec2(ceil(tex.x), floor(tex.y));\n  vec2 c = vec2(floor(tex.x), ceil(tex.y));\n\n  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n\n  float alen = length(TEX - A);\n  float blen = length(TEX - B);\n  float clen = length(TEX - C);\n\n  vec2 choice;\n  if (alen < blen) {\n    if (alen < clen) choice = a;\n    else choice = c;\n  } else {\n    if (blen < clen) choice = b;\n    else choice = c;\n  }\n\n  choice.x += choice.y * 0.5;\n  choice.y *= 0.866025404;\n  choice *= hexagonalPixelate.scale / texSize;\n\n  return texture(source, choice + hexagonalPixelate.center);\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",scale:"f32"},propTypes:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},passes:[{sampler:!0}]},Ct={name:"ink",source:"uniform inkUniforms {\n  strength: f32,\n};\n\n@group(0) @binding(1) var<uniform> ink: inkUniforms;\n\nfn ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture(source, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;\n      bigAverage += offsetColor;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += offsetColor;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n",fs:"uniform inkUniforms {\n  float strength;\n} ink;\n\nvec4 ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 dx = vec2(1.0 / texSize.x, 0.0);\n  vec2 dy = vec2(0.0, 1.0 / texSize.y);\n  vec4 color = texture(source, texCoord);\n  float bigTotal = 0.0;\n  float smallTotal = 0.0;\n  vec3 bigAverage = vec3(0.0);\n  vec3 smallAverage = vec3(0.0);\n  for (float x = -2.0; x <= 2.0; x += 1.0) {\n    for (float y = -2.0; y <= 2.0; y += 1.0) {\n      vec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;\n      bigAverage += offsetColor;\n      bigTotal += 1.0;\n      if (abs(x) + abs(y) < 2.0) {\n        smallAverage += offsetColor;\n        smallTotal += 1.0;\n      }\n    }\n  }\n  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\n  float power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;\n  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);\n}\n",props:{},uniforms:{},uniformTypes:{strength:"f32"},propTypes:{strength:{value:.25,min:0,softMax:1}},passes:[{sampler:!0}]},St={name:"magnify",source:"uniform magnifyUniforms {\n  screenXY: vec2f;\n  radiusPixels: f32;\n  zoom: f32;\n  borderWidthPixels: f32;\n  borderColor: vec4f;\n};\n\n@group(0) @binding(1) var<uniform> magnify: magnifyUniforms;\n\nfn magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < magnify.radiusPixels) {\n    return texture(source, (texCoord - pos) / magnify.zoom + pos);\n  }\n\n  if (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {\n    return magnify.borderColor;\n  }\n  return texture(source, texCoord);\n}\n",fs:"uniform magnifyUniforms {\n  vec2 screenXY;\n  float radiusPixels;\n  float zoom;\n  float borderWidthPixels;\n  vec4 borderColor;\n} magnify;\n\nvec4 magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);\n  float dist = distance(texCoord * texSize, pos * texSize);\n  if (dist < magnify.radiusPixels) {\n    return texture(source, (texCoord - pos) / magnify.zoom + pos);\n  }\n\n  if (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {\n    return magnify.borderColor;\n  }\n  return texture(source, texCoord);\n}\n",uniformTypes:{screenXY:"vec2<f32>",radiusPixels:"f32",zoom:"f32",borderWidthPixels:"f32",borderColor:"vec4<f32>"},propTypes:{screenXY:{value:[0,0]},radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:{value:[255,255,255,255]}},passes:[{sampler:!0}]},It={name:"warp",source:"vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {\n  vec4 color = texture(source, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    /* fade to transparent if we are outside the image */\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n  return color;\n}\n",fs:"vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {\n  vec4 color = texture(source, coord / texSize);\n  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\n  if (coord != clampedCoord) {\n    /* fade to transparent if we are outside the image */\n    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));\n  }\n  return color;\n}\n",passes:[]},Pt={name:"bulgePinch",dependencies:[It],source:"uniform bulgePinchUniforms {\n  radius: f32,\n  strength: f32,\n  center: vec2f,\n};\n\n@group(0) @binding(1) var<uniform> bulgePinch: bulgePinchUniforms;\n\nfn bulgePinch_warp(vec2 coord, vec2 texCenter) -> vec2f {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < bulgePinch.radius) {\n    float percent = distance / bulgePinch.radius;\n    if (bulgePinch.strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nfn bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, bulgePinch.center * texSize);\n  return warp_sampleColor(source, texSize, coord);\n}\n",fs:"uniform bulgePinchUniforms {\n  float radius;\n  float strength;\n  vec2 center;\n} bulgePinch;\n\nvec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < bulgePinch.radius) {\n    float percent = distance / bulgePinch.radius;\n    if (bulgePinch.strength > 0.0) {\n      coord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);\n    } else {\n      coord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);\n    }\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = bulgePinch_warp(coord, bulgePinch.center * texSize);\n\n  return warp_sampleColor(source, texSize, coord);\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",radius:"f32",strength:"f32"},propTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},passes:[{sampler:!0}]},Nt={name:"swirl",dependencies:[It],source:"uniform swirlUniforms {\n  radius: f32,\n  angle: f32,\n  center: vec2f,\n};\n\n@group(0) @binding(1) swirl: swirlUniforms;\n\nfn swirl_warp(vec2 coord, vec2 texCenter) -> vec2f {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < swirl.radius) {\n    float percent = (swirl.radius - distance) / swirl.radius;\n    float theta = percent * percent * swirl.angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nfn swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) -> vec4f {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, swirl.center * texSize);\n  return warp_sampleColor(source, texSize, coord);\n}\n",fs:"uniform swirlUniforms {\n  float radius;\n  float angle;\n  vec2 center;\n} swirl;\n\nvec2 swirl_warp(vec2 coord, vec2 texCenter) {\n  coord -= texCenter;\n  float distance = length(coord);\n  if (distance < swirl.radius) {\n    float percent = (swirl.radius - distance) / swirl.radius;\n    float theta = percent * percent * swirl.angle;\n    float s = sin(theta);\n    float c = cos(theta);\n    coord = vec2(\n      coord.x * c - coord.y * s,\n      coord.x * s + coord.y * c\n    );\n  }\n  coord += texCenter;\n  return coord;\n}\n\nvec4 swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  vec2 coord = texCoord * texSize;\n  coord = swirl_warp(coord, swirl.center * texSize);\n\n  return warp_sampleColor(source, texSize, coord);\n}\n",props:{},uniforms:{},uniformTypes:{center:"vec2<f32>",radius:"f32",angle:"f32"},propTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},passes:[{sampler:!0}]},yt={name:"fxaa",propTypes:{},fs:"\n#define FXAA_QUALITY_PRESET 29\n\n#if (FXAA_QUALITY_PRESET == 10)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 3.0\n    #define FXAA_QUALITY_P2 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 11)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 3.0\n    #define FXAA_QUALITY_P3 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 12)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 4.0\n    #define FXAA_QUALITY_P4 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 13)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 4.0\n    #define FXAA_QUALITY_P5 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 14)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 4.0\n    #define FXAA_QUALITY_P6 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 15)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 12.0\n#endif\n#if (FXAA_QUALITY_PRESET == 20)\n    #define FXAA_QUALITY_PS 3\n    #define FXAA_QUALITY_P0 1.5\n    #define FXAA_QUALITY_P1 2.0\n    #define FXAA_QUALITY_P2 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 21)\n    #define FXAA_QUALITY_PS 4\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 22)\n    #define FXAA_QUALITY_PS 5\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 23)\n    #define FXAA_QUALITY_PS 6\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 24)\n    #define FXAA_QUALITY_PS 7\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 3.0\n    #define FXAA_QUALITY_P6 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 25)\n    #define FXAA_QUALITY_PS 8\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 4.0\n    #define FXAA_QUALITY_P7 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 26)\n    #define FXAA_QUALITY_PS 9\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 4.0\n    #define FXAA_QUALITY_P8 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 27)\n    #define FXAA_QUALITY_PS 10\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 4.0\n    #define FXAA_QUALITY_P9 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 28)\n    #define FXAA_QUALITY_PS 11\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 4.0\n    #define FXAA_QUALITY_P10 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 29)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.5\n    #define FXAA_QUALITY_P2 2.0\n    #define FXAA_QUALITY_P3 2.0\n    #define FXAA_QUALITY_P4 2.0\n    #define FXAA_QUALITY_P5 2.0\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n#if (FXAA_QUALITY_PRESET == 39)\n    #define FXAA_QUALITY_PS 12\n    #define FXAA_QUALITY_P0 1.0\n    #define FXAA_QUALITY_P1 1.0\n    #define FXAA_QUALITY_P2 1.0\n    #define FXAA_QUALITY_P3 1.0\n    #define FXAA_QUALITY_P4 1.0\n    #define FXAA_QUALITY_P5 1.5\n    #define FXAA_QUALITY_P6 2.0\n    #define FXAA_QUALITY_P7 2.0\n    #define FXAA_QUALITY_P8 2.0\n    #define FXAA_QUALITY_P9 2.0\n    #define FXAA_QUALITY_P10 4.0\n    #define FXAA_QUALITY_P11 8.0\n#endif\n\n#define FxaaBool bool\n#define FxaaFloat float\n#define FxaaFloat2 vec2\n#define FxaaFloat3 vec3\n#define FxaaFloat4 vec4\n#define FxaaHalf float\n#define FxaaHalf2 vec2\n#define FxaaHalf3 vec3\n#define FxaaHalf4 vec4\n#define FxaaInt2 vec2\n#define FxaaTex sampler2D\n\n#define FxaaSat(x) clamp(x, 0.0, 1.0)\n#define FxaaTexTop(t, p) texture(t, p)\n#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))\n\nFxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }\n\nFxaaFloat4 FxaaPixelShader_(\n    //\n    // Use noperspective interpolation here (turn off perspective interpolation).\n    // {xy} = center of pixel\n    FxaaFloat2 pos,\n    //\n    // Input color texture.\n    // {rgb_} = color in linear or perceptual color space\n    // if (FXAA_GREEN_AS_LUMA == 0)\n    //     {___a} = luma in perceptual color space (not linear)\n    FxaaTex tex,\n    //\n    // Only used on FXAA Quality.\n    // This must be from a constant/uniform.\n    // {x_} = 1.0/screenWidthInPixels\n    // {_y} = 1.0/screenHeightInPixels\n    FxaaFloat2 fxaaQualityRcpFrame,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // It is here now to allow easier tuning.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    FxaaFloat fxaaQualitySubpix,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // It is here now to allow easier tuning.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    FxaaFloat fxaaQualityEdgeThreshold,\n    //\n    // Only used on FXAA Quality.\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // It is here now to allow easier tuning.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    // Special notes when using FXAA_GREEN_AS_LUMA,\n    //   Likely want to set this to zero.\n    //   As colors that are mostly not-green\n    //   will appear very dark in the green channel!\n    //   Tune by looking at mostly non-green content,\n    //   then start at zero and increase until aliasing is a problem.\n    FxaaFloat fxaaQualityEdgeThresholdMin\n) {\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n    #define lumaM rgbyM.y\n    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat maxSM = max(lumaS, lumaM);\n    FxaaFloat minSM = min(lumaS, lumaM);\n    FxaaFloat maxESM = max(lumaE, maxSM);\n    FxaaFloat minESM = min(lumaE, minSM);\n    FxaaFloat maxWN = max(lumaN, lumaW);\n    FxaaFloat minWN = min(lumaN, lumaW);\n    FxaaFloat rangeMax = max(maxWN, maxESM);\n    FxaaFloat rangeMin = min(minWN, minESM);\n    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    FxaaFloat range = rangeMax - rangeMin;\n    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    FxaaBool earlyExit = range < rangeMaxClamped;\n/*--------------------------------------------------------------------------*/\n    if(earlyExit)\n        return rgbyM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNS = lumaN + lumaS;\n    FxaaFloat lumaWE = lumaW + lumaE;\n    FxaaFloat subpixRcpRange = 1.0/range;\n    FxaaFloat subpixNSWE = lumaNS + lumaWE;\n    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNESE = lumaNE + lumaSE;\n    FxaaFloat lumaNWNE = lumaNW + lumaNE;\n    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat lumaNWSW = lumaNW + lumaSW;\n    FxaaFloat lumaSWSE = lumaSW + lumaSE;\n    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n    FxaaBool horzSpan = edgeHorz >= edgeVert;\n    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n/*--------------------------------------------------------------------------*/\n    if(!horzSpan) lumaN = lumaW;\n    if(!horzSpan) lumaS = lumaE;\n    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat gradientN = lumaN - lumaM;\n    FxaaFloat gradientS = lumaS - lumaM;\n    FxaaFloat lumaNN = lumaN + lumaM;\n    FxaaFloat lumaSS = lumaS + lumaM;\n    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n    if(pairN) lengthSign = -lengthSign;\n    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posB;\n    posB.x = posM.x;\n    posB.y = posM.y;\n    FxaaFloat2 offNP;\n    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n    if(!horzSpan) posB.x += lengthSign * 0.5;\n    if( horzSpan) posB.y += lengthSign * 0.5;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat2 posN;\n    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat2 posP;\n    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));\n    FxaaFloat subpixE = subpixC * subpixC;\n    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));\n/*--------------------------------------------------------------------------*/\n    if(!pairN) lumaNN = lumaSS;\n    FxaaFloat gradientScaled = gradient * 1.0/4.0;\n    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n    FxaaFloat subpixF = subpixD * subpixE;\n    FxaaBool lumaMLTZero = lumaMM < 0.0;\n/*--------------------------------------------------------------------------*/\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n    FxaaBool doneNP = (!doneN) || (!doneP);\n    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n/*--------------------------------------------------------------------------*/\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 3)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 4)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 5)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 6)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n/*--------------------------------------------------------------------------*/\n                        #if (FXAA_QUALITY_PS > 7)\n                        if(doneNP) {\n                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                            doneN = abs(lumaEndN) >= gradientScaled;\n                            doneP = abs(lumaEndP) >= gradientScaled;\n                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                            doneNP = (!doneN) || (!doneP);\n                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n/*--------------------------------------------------------------------------*/\n    #if (FXAA_QUALITY_PS > 8)\n    if(doneNP) {\n        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n        doneNP = (!doneN) || (!doneP);\n        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n/*--------------------------------------------------------------------------*/\n        #if (FXAA_QUALITY_PS > 9)\n        if(doneNP) {\n            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n            doneNP = (!doneN) || (!doneP);\n            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n/*--------------------------------------------------------------------------*/\n            #if (FXAA_QUALITY_PS > 10)\n            if(doneNP) {\n                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                doneN = abs(lumaEndN) >= gradientScaled;\n                doneP = abs(lumaEndP) >= gradientScaled;\n                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                doneNP = (!doneN) || (!doneP);\n                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n/*--------------------------------------------------------------------------*/\n                #if (FXAA_QUALITY_PS > 11)\n                if(doneNP) {\n                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                    doneN = abs(lumaEndN) >= gradientScaled;\n                    doneP = abs(lumaEndP) >= gradientScaled;\n                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                    doneNP = (!doneN) || (!doneP);\n                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n/*--------------------------------------------------------------------------*/\n                    #if (FXAA_QUALITY_PS > 12)\n                    if(doneNP) {\n                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));\n                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));\n                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                        doneN = abs(lumaEndN) >= gradientScaled;\n                        doneP = abs(lumaEndP) >= gradientScaled;\n                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                        doneNP = (!doneN) || (!doneP);\n                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n    #endif\n/*--------------------------------------------------------------------------*/\n                        }\n                        #endif\n/*--------------------------------------------------------------------------*/\n                    }\n                    #endif\n/*--------------------------------------------------------------------------*/\n                }\n                #endif\n/*--------------------------------------------------------------------------*/\n            }\n            #endif\n/*--------------------------------------------------------------------------*/\n        }\n        #endif\n/*--------------------------------------------------------------------------*/\n    }\n/*--------------------------------------------------------------------------*/\n    FxaaFloat dstN = posM.x - posN.x;\n    FxaaFloat dstP = posP.x - posM.x;\n    if(!horzSpan) dstN = posM.y - posN.y;\n    if(!horzSpan) dstP = posP.y - posM.y;\n/*--------------------------------------------------------------------------*/\n    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    FxaaFloat spanLength = (dstP + dstN);\n    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    FxaaFloat spanLengthRcp = 1.0/spanLength;\n/*--------------------------------------------------------------------------*/\n    FxaaBool directionN = dstN < dstP;\n    FxaaFloat dst = min(dstN, dstP);\n    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n    FxaaFloat subpixG = subpixF * subpixF;\n    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n/*--------------------------------------------------------------------------*/\n    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n    return FxaaTexTop(tex, posM);\n}\n\nvec4 fxaa_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n    const float fxaa_QualitySubpix = 0.5;\n    const float fxaa_QualityEdgeThreshold = 0.125;\n    const float fxaa_QualityEdgeThresholdMin = 0.0833;\n\n    return FxaaPixelShader_(\n        texCoord,\n        source,\n        vec2(1.0) / texSize,\n        fxaa_QualitySubpix,\n        fxaa_QualityEdgeThreshold,\n        fxaa_QualityEdgeThresholdMin\n    );\n}\n",passes:[{sampler:!0}],getUniforms:function(e){return e}},Lt=function(e){function n(n){var t,i,o=n.device;(t=e.call(this)||this).scenes=[],t.center=[0,0,0],t.vantage=[0,0,0],t.time=0,t.device=o,t.imageTexture=new Ue(o,{data:(0,an.Dt)("./image2.png",{imageOrientation:"flipY"})}),t.shaderPassMap=(i={},Object.entries(r).forEach(function(e){var n=e[0],t=e[1];t.passes&&!n.startsWith("_")&&(i[n]=t)}),i),t.setShaderPasses([]);var s=["No effect"].concat(Object.keys(t.shaderPassMap));return t.selector=function(e,n,t){var r=document.createElement("select");r.id="selector",e.appendChild(r),r.style.cssText="position: absolute; top: 0; right: 0; margin: 20px; z-index: 1000;";for(var i,o=(0,a.A)(n);!(i=o()).done;){var s=i.value,l=document.createElement("option");l.value=s,l.text=s,l.id=s,r.appendChild(l)}return null==r||r.addEventListener("change",function(e){return t(e.target.value)}),r}(document.body,s,function(e){var n=t.shaderPassMap[e]?[t.shaderPassMap[e]]:[];t.setShaderPasses(n)}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){var e;null==(e=this.shaderPassRenderer)||e.destroy()},t.onRender=function(e){var n;e.device;null==(n=this.shaderPassRenderer)||n.resize(),this.shaderPassRenderer.renderToScreen({sourceTexture:this.imageTexture})},t.setShaderPasses=function(e){var n;null==(n=this.shaderPassRenderer)||n.destroy(),this.shaderPassRenderer=new st(this.device,{shaderPasses:e})},n}(Je);Lt.info='<div class="contents">Copyright 2011 <a href="http://madebyevan.com">Evan Wallace</a>\n  <br><br>This application is powered by <a href="http://evanw.github.com/glfx.js/">glfx.js</a>, \n  an open-source image effect library that uses WebGL.&nbsp; The source code for this application is \n  also <a href="http://github.com/evanw/webgl-filter/">available on GitHub</a>.\n</div>\n';var Ft=function(e){function n(n){var t,r=n.device;t=e.call(this)||this;var i=new Float32Array([0,0,-.5,-.5,1,0,0,.5,-.5,0,1,0,0,.5,0,0,1]);return t.interleavedBuffer=r.createBuffer(i),t.model=new Ge(r,{id:"triangle",source:"struct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragColor : vec3<f32>\n};\n\n@vertex\nfn vertexMain(@location(0) position : vec2<f32>, @location(1) color : vec3<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = vec4<f32>(position.x, position.y, 0.0, 1.0);\n  output.fragColor = color;\n  return output;\n}\n\n@fragment\nfn fragmentMain(@location(0) fragColor: vec3<f32>) -> @location(0) vec4<f32> {\n  return vec4<f32>(fragColor, 1.0);\n}\n",vs:"#version 300 es\n\nin vec2 position;\nin vec3 color;\n\nout vec3 vColor;\n\nvoid main() {\n  vColor = color;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n",fs:"#version 300 es\n\nin vec3 vColor;\nout vec4 fragColor;\nvoid main() {\n  fragColor = vec4(vColor, 1.0);\n}\n",bufferLayout:[{name:"vertexData",byteStride:20,attributes:[{attribute:"position",format:"float32x2",byteOffset:8},{attribute:"color",format:"float32x3",byteOffset:16}]}],attributes:{vertexData:t.interleavedBuffer},vertexCount:3}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model.destroy(),this.interleavedBuffer.destroy()},t.onRender=function(e){var n=e.device.beginRenderPass({clearColor:[0,0,0,1]});this.model.draw(n),n.end()},n}(Je);Ft.info="\nHave to start somewhere...\n";var Mt=function(e){function n(n){var t,r=n.device;return(t=e.call(this)||this).model=new Ge(r,{source:"@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4<f32> {\n  var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  return vec4<f32>(positions[vertexIndex], 0.0, 1.0);\n}\n\n@fragment\nfn fragmentMain() -> @location(0) vec4<f32> {\n  return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n",vs:"#version 300 es\nconst vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexID], 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\nlayout(location = 0) out vec4 outColor;\nvoid main() {\n    outColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n",topology:"triangle-list",vertexCount:3,shaderLayout:{attributes:[],bindings:[]},parameters:{depthFormat:"depth24plus"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model.destroy()},t.onRender=function(e){var n=e.device.beginRenderPass({clearColor:[1,1,1,1]});this.model.draw(n),n.end()},n}(Je);Mt.info="<p>Have to start somewhere...</p>\n";var Ot={uniformTypes:{mvpMatrix:"mat4x4<f32>"}},wt=[0,0,-4],Ut=function(e){function n(n){var t,r=n.device;(t=e.call(this)||this).mvpMatrix=new en.k,t.viewMatrix=(new en.k).lookAt({eye:wt}),t.uniformStore=new g({app:Ot});var i=new Ue(r,{usage:R.g.TEXTURE|R.g.RENDER_ATTACHMENT|R.g.COPY_DST,data:(0,an.Dt)("vis-logo.png"),flipY:!0,mipmaps:!0,sampler:r.createSampler({minFilter:"linear",magFilter:"linear",mipmapFilter:"linear"})});return t.model=new Ge(r,{id:"rotating-cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> app : Uniforms;\n@group(0) @binding(1) var uTexture : texture_2d<f32>;\n@group(0) @binding(2) var uTextureSampler : sampler;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  // return inputs.fragPosition;\n  return textureSample(uTexture, uTextureSampler, inputs.fragUV);\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = 0.5 * (vec4(positions, 1.) + vec4(1., 1., 1., 1.));\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\n\nuniform sampler2D uTexture;\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n  fragColor = texture(uTexture, vec2(fragUV.x, 1.0 - fragUV.y));\n}\n",geometry:new Ve({indices:!1}),bindings:{app:t.uniformStore.getManagedUniformBuffer(r,"app"),uTexture:i},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model.destroy(),this.uniformStore.destroy()},t.onRender=function(e){var n=e.device,t=e.aspect,r=e.tick;this.mvpMatrix.perspective({fovy:Math.PI/3,aspect:t}).multiplyRight(this.viewMatrix).rotateX(.01*r).rotateY(.013*r),this.uniformStore.setUniforms({app:{mvpMatrix:this.mvpMatrix}});var i=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});this.model.draw(i),i.end()},n}(Je);Ut.info="<p>\nDrawing a textured cube\n</p>\n\n<p>\nRendered using the luma.gl <code>Model</code>, <code>CubeGeometry</code> and <code>AnimationLoop</code> classes.\n</p>\n";var Dt=function(e){function n(n){var t,r=n.device;return(t=e.call(this)||this).uniformBuffer1=r.createBuffer({id:"uniforms-1",usage:l.h.UNIFORM|l.h.COPY_DST,byteLength:64}),t.uniformBuffer2=r.createBuffer({id:"uniforms-2",usage:l.h.UNIFORM|l.h.COPY_DST,byteLength:64}),t.cubeModel=new Ge(r,{id:"cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n};\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return inputs.fragPosition;\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = vec4(positions, 1.);\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix;\n} app;\n\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n}\n",geometry:new Ve({indices:!1}),parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},bindings:{app:t.uniformBuffer1}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.cubeModel.destroy(),this.uniformBuffer1.destroy(),this.uniformBuffer2.destroy()},t.onRender=function(e){var n,t=e.device,r=new en.k,i=new en.k,o=new en.k,a=null==(n=t.canvasContext)?void 0:n.getAspect(),s=Date.now()/1e3;r.perspective({fovy:2*Math.PI/5,aspect:a,near:1,far:100}),i.identity().translate([-2,0,-7]).rotateAxis(1,[Math.sin(s),Math.cos(s),0]),o.copy(i).multiplyLeft(r),this.uniformBuffer1.write(new Float32Array(o)),i.identity().translate([2,0,-7]).rotateAxis(1,[Math.cos(s),Math.sin(s),0]),o.copy(i).multiplyLeft(r),this.uniformBuffer2.write(new Float32Array(o));var l=t.beginRenderPass({clearColor:[0,0,0,1]});this.cubeModel.setBindings({app:this.uniformBuffer1}),this.cubeModel.draw(l),this.cubeModel.setBindings({app:this.uniformBuffer2}),this.cubeModel.draw(l),l.end()},n}(Je),Bt=function(e){function n(n){var t,r=n.device;return(t=e.call(this)||this).uniformBuffer=r.createBuffer({id:"uniforms",usage:l.h.UNIFORM|l.h.COPY_DST,byteLength:1024}),t.cubeModel=new Ge(r,{id:"cube",source:"struct Uniforms {\n  modelViewProjectionMatrix : array<mat4x4<f32>, 16>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n\nstruct VertexInputs {\n  @builtin(instance_index) instanceIdx : u32,\n  // CUBE GEOMETRY\n  @location(0) positions : vec4<f32>,\n  @location(1) texCoords : vec2<f32>\n}\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec4<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.modelViewProjectionMatrix[inputs.instanceIdx] * inputs.positions;\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = 0.5 * (inputs.positions + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return inputs.fragPosition;\n}\n",vs:"#version 300 es\n#define SHADER_NAME cube-vs\n\nuniform appUniforms {\n  mat4 modelViewProjectionMatrix[16];\n} app;\n\n// CUBE GEOMETRY\nlayout(location=0) in vec3 positions;\nlayout(location=1) in vec2 texCoords;\n\nout vec2 fragUV;\nout vec4 fragPosition;\n\nvoid main() {\n  gl_Position = app.modelViewProjectionMatrix[gl_InstanceID] * vec4(positions, 1.0);\n  fragUV = texCoords;\n  fragPosition = vec4(positions, 1.);\n}\n",fs:"#version 300 es\n#define SHADER_NAME cube-fs\nprecision highp float;\nin vec2 fragUV;\nin vec4 fragPosition;\n\nlayout (location=0) out vec4 fragColor;\n\nvoid main() {\n  fragColor = fragPosition;\n}\n",geometry:new Ve({indices:!1}),instanceCount:16,parameters:{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},bindings:{app:t.uniformBuffer}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(e){this.uniformBuffer.destroy(),this.cubeModel.destroy()},t.onRender=function(e){var n,t=e.device,r=new en.k,i=null==(n=t.canvasContext)?void 0:n.getAspect(),o=Date.now()/1e3;r.perspective({fovy:2*Math.PI/5,aspect:i,near:1,far:100});var a=function(e,n){for(var t=(new en.k).translate([0,0,-12]),r=new en.k,i=0,o=0,a=0;a<4;a++)for(var s=0;s<4;s++)r.copy(Gt[i]).rotateAxis(1,[Math.sin((a+.5)*n),Math.cos((s+.5)*n),0]).multiplyLeft(t).multiplyLeft(e),Vt.set(r,o),i++,o+=16;return Vt}(r,o);this.uniformBuffer.write(a);var s=t.beginRenderPass();this.cubeModel.draw(s),s.end()},n}(Je);Bt.info="Instanced cubes drawn using luma.gl's high-level API.\n  ";for(var Gt=[],Xt=0;Xt<4;Xt++)for(var Ht=0;Ht<4;Ht++)Gt.push((new en.k).translate([4*(Xt-2+.5),4*(Ht-2+.5),0]));var Vt=new Float32Array(256);var kt={name:"color",source:"// struct ColorVaryings {\n//   color: vec3<f32>,\n// };\n\n// @vertex\n// fn color_setColor(color: vec3f, input: ColorVaryings) -> ColorVaryings {\n//   var output = input;\n//   output.color = color;\n//   return output;\n// }\n\n// @fragment\n// fn color_getColor(input: ColorVaryings) -> vec4<f32> {\n//   return vec4<f32>(input.color, 1.0);\n// }\n  ",vs:"out vec3 color_vColor;\n\nvoid color_setColor(vec3 color) {\n  color_vColor = color;\n}\n  ",fs:"in vec3 color_vColor;\n\nvec3 color_getColor() {\n  return color_vColor;\n}\n  "},zt=function(e){function n(n){var t,r=n.device;return(t=e.call(this)||this).positionBuffer=r.createBuffer(new Float32Array([-.2,-.2,.2,-.2,0,.2])),t.colorBuffer=r.createBuffer(new Float32Array([1,0,0,0,1,0,0,0,1,1,1,0])),t.offsetBuffer=r.createBuffer(new Float32Array([.5,.5,-.5,.5,.5,-.5,-.5,-.5])),t.model=new Ge(r,{source:"struct VertexInputs {\n  @location(0) position: vec2<f32>,\n  @location(1) instanceColor: vec3<f32>,\n  @location(2) instanceOffset: vec2<f32>,\n};  \n\nstruct FragmentInputs {\n  @builtin(position) Position: vec4<f32>,\n  @location(0) color: vec3<f32>,\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs: FragmentInputs;\n  outputs.color = inputs.instanceColor;\n  outputs.Position = vec4<f32>(inputs.position + inputs.instanceOffset, 0.0, 1.0);\n  return outputs;\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  return vec4<f32>(inputs.color, 1.0);\n}\n",vs:"#version 300 es\nin vec2 position;\nin vec3 instanceColor;\nin vec2 instanceOffset;\n\nvoid main() {\n  color_setColor(instanceColor);\n  gl_Position = vec4(position + instanceOffset, 0.0, 1.0);\n}\n",fs:"#version 300 es\nout vec4 fragColor;\nvoid main() {\n  fragColor = vec4(color_getColor(), 1.0);\n}\n",modules:[kt],bufferLayout:[{name:"position",format:"float32x2"},{name:"instanceColor",format:"float32x3",stepMode:"instance"},{name:"instanceOffset",format:"float32x2",stepMode:"instance"}],attributes:{position:t.positionBuffer,instanceColor:t.colorBuffer,instanceOffset:t.offsetBuffer},vertexCount:3,instanceCount:4,parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model.destroy(),this.positionBuffer.destroy(),this.colorBuffer.destroy(),this.offsetBuffer.destroy()},t.onRender=function(e){var n=e.device.beginRenderPass({clearColor:[0,0,0,1]});this.model.draw(n),n.end()},n}(Je),jt=t(6093),Wt=function(){function e(e){void 0===e&&(e={}),this.matrix=new en.k,this.display=!0,this.position=new kn.P,this.rotation=new kn.P,this.scale=new kn.P(1,1,1),this.userData={},this.props={};var n=e.id;this.id=n||fe(this.constructor.name),this._setScenegraphNodeProps(e)}var n=e.prototype;return n.getBounds=function(){return null},n.destroy=function(){},n.delete=function(){this.destroy()},n.setProps=function(e){return this._setScenegraphNodeProps(e),this},n.toString=function(){return"{type: ScenegraphNode, id: "+this.id+")}"},n.setPosition=function(e){return this.position=e,this},n.setRotation=function(e){return this.rotation=e,this},n.setScale=function(e){return this.scale=e,this},n.setMatrix=function(e,n){void 0===n&&(n=!0),n?this.matrix.copy(e):this.matrix=e},n.setMatrixComponents=function(e){var n=e.position,t=e.rotation,r=e.scale,i=e.update,o=void 0===i||i;return n&&this.setPosition(n),t&&this.setRotation(t),r&&this.setScale(r),o&&this.updateMatrix(),this},n.updateMatrix=function(){var e=this.position,n=this.rotation,t=this.scale;return this.matrix.identity(),this.matrix.translate(e),this.matrix.rotateXYZ(n),this.matrix.scale(t),this},n.update=function(e){void 0===e&&(e={});var n=e,t=n.position,r=n.rotation,i=n.scale;return t&&this.setPosition(t),r&&this.setRotation(r),i&&this.setScale(i),this.updateMatrix(),this},n.getCoordinateUniforms=function(e,n){n=n||this.matrix;var t=new en.k(e).multiplyRight(n),r=t.invert(),i=r.transpose();return{viewMatrix:e,modelMatrix:n,objectMatrix:n,worldMatrix:t,worldInverseMatrix:r,worldInverseTransposeMatrix:i}},n._setScenegraphNodeProps=function(e){"position"in e&&this.setPosition(e.position),"rotation"in e&&this.setRotation(e.rotation),"scale"in e&&this.setScale(e.scale),"matrix"in e&&this.setMatrix(e.matrix),Object.assign(this.props,e)},e}(),Yt=function(e){function n(n){var t;void 0===n&&(n={});var r=(n=Array.isArray(n)?{children:n}:n).children,i=void 0===r?[]:r;return c.R.assert(i.every(function(e){return e instanceof Wt}),"every child must an instance of ScenegraphNode"),(t=e.call(this,n)||this).children=i,t}(0,s.A)(n,e);var t=n.prototype;return t.getBounds=function(){var e=[[1/0,1/0,1/0],[-1/0,-1/0,-1/0]];return this.traverse(function(n,t){var r=t.worldMatrix,i=n.getBounds();if(i){var o=i[0],a=i[1],s=new kn.P(o).add(a).divide([2,2,2]);r.transformAsPoint(s,s);var l=new kn.P(a).subtract(o).divide([2,2,2]);r.transformAsVector(l,l);for(var c=0;c<8;c++)for(var u=new kn.P(1&c?-1:1,2&c?-1:1,4&c?-1:1).multiply(l).add(s),f=0;f<3;f++)e[0][f]=Math.min(e[0][f],u[f]),e[1][f]=Math.max(e[1][f],u[f])}}),Number.isFinite(e[0][0])?e:null},t.destroy=function(){this.children.forEach(function(e){return e.destroy()}),this.removeAll(),e.prototype.destroy.call(this)},t.add=function(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];for(var r=0,i=n;r<i.length;r++){var o=i[r];Array.isArray(o)?this.add.apply(this,o):this.children.push(o)}return this},t.remove=function(e){var n=this.children,t=n.indexOf(e);return t>-1&&n.splice(t,1),this},t.removeAll=function(){return this.children=[],this},t.traverse=function(e,t){for(var r,i=(void 0===t?{}:t).worldMatrix,o=void 0===i?new en.k:i,s=new en.k(o).multiplyRight(this.matrix),l=(0,a.A)(this.children);!(r=l()).done;){var c=r.value;c instanceof n?c.traverse(e,{worldMatrix:s}):e(c,{worldMatrix:s})}},n}(Wt),Qt=function(e){return e[e.POINTS=0]="POINTS",e[e.LINES=1]="LINES",e[e.LINE_LOOP=2]="LINE_LOOP",e[e.LINE_STRIP=3]="LINE_STRIP",e[e.TRIANGLES=4]="TRIANGLES",e[e.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",e[e.TRIANGLE_FAN=6]="TRIANGLE_FAN",e}({});var Kt=t(8587),Zt="precision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n",qt=function(e){return e[e.POINT=0]="POINT",e[e.DIRECTIONAL=1]="DIRECTIONAL",e}({}),Jt={props:{},uniforms:{},name:"lighting",defines:{},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:qt.POINT,directionalLightCount:0,pointLightCount:0,ambientColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:"// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n",vs:Zt,fs:Zt,getUniforms:function(e,n){void 0===n&&(n={});if(!(e=e?Object.assign({},e):e))return Object.assign({},Jt.defaultUniforms);e.lights&&(e=Object.assign({},e,function(e){for(var n,t,r,i={pointLights:[],directionalLights:[]},o=(0,a.A)(e||[]);!(r=o()).done;){var s=r.value;switch(s.type){case"ambient":i.ambientLight=s;break;case"directional":null==(n=i.directionalLights)||n.push(s);break;case"point":null==(t=i.pointLights)||t.push(s)}}return i}(e.lights),{lights:void 0}));var t=e||{},r=t.ambientLight,i=t.pointLights,o=t.directionalLights;if(!(r||i&&i.length>0||o&&o.length>0))return Object.assign({},Jt.defaultUniforms,{enabled:0});var s=Object.assign({},Jt.defaultUniforms,n,function(e){var n=e.ambientLight,t=e.pointLights,r=void 0===t?[]:t,i=e.directionalLights,o=void 0===i?[]:i,s={};s.ambientColor=$t(n);for(var l,u=0,f=(0,a.A)(r);!(l=f()).done;){var d=l.value;s.lightType=qt.POINT;var p=u;s["lightColor"+p]=$t(d),s["lightPosition"+p]=d.position,s["lightAttenuation"+p]=d.attenuation||[1,0,0],u++}for(var h,m=(0,a.A)(o);!(h=m()).done;){var g=h.value;s.lightType=qt.DIRECTIONAL;var _=u;s["lightColor"+_]=$t(g),s["lightDirection"+_]=g.direction,u++}u>5&&c.R.warn("MAX_LIGHTS exceeded")();return s.directionalLightCount=o.length,s.pointLightCount=r.length,s}({ambientLight:r,pointLights:i,directionalLights:o}));void 0!==e.enabled&&(s.enabled=e.enabled?1:0);return s}};function $t(e){void 0===e&&(e={});var n=e,t=n.color,r=void 0===t?[0,0,0]:t,i=n.intensity,o=void 0===i?1:i;return r.map(function(e){return e*o/255})}var er="uniform pbrProjectionUniforms {\n  mat4 modelViewProjectionMatrix;\n  mat4 modelMatrix;\n  mat4 normalMatrix;\n  vec3 camera;\n} pbrProjection;\n",nr={props:{},uniforms:{},name:"pbrMaterial",dependencies:[Jt,{name:"pbrProjection",vs:er,fs:er,getUniforms:function(e){return e},uniformTypes:{modelViewProjectionMatrix:"mat4x4<f32>",modelMatrix:"mat4x4<f32>",normalMatrix:"mat4x4<f32>",camera:"vec3<i32>"}}],source:"struct PBRFragmentInputs {\n  pbr_vPosition: vec3f,\n  pbr_vUV: vec2f,\n  pbr_vTBN: mat3f,\n  pbr_vNormal: vec3f\n};\n\nvar fragmentInputs: PBRFragmentInputs;\n\nfn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)\n{\n  var pos: vec4f = pbrProjection.modelMatrix * position;\n  fragmentInputs.pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;\n  fragmentInputs.pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  fragmentInputs.pbr_vUV = uv;\n#else\n  fragmentInputs.pbr_vUV = vec2(0.,0.);\n#endif\n}\n\nstruct pbrMaterialUniforms {\n  // Material is unlit\n  unlit: uint32,\n\n  // Base color map\n  baseColorMapEnabled: uint32,\n  baseColorFactor: vec4f,\n\n  normalMapEnabled : uint32,\n  normalScale: f32,  // #ifdef HAS_NORMALMAP\n\n  emissiveMapEnabled: uint32,\n  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP\n\n  metallicRoughnessValues: vec2f,\n  metallicRoughnessMapEnabled: uint32,\n\n  occlusionMapEnabled: i32,\n  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP\n  \n  alphaCutoffEnabled: i32,\n  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF\n  \n  // IBL\n  IBLenabled: i32,\n  scaleIBLAmbient: vec2f, // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  scaleDiffBaseMR: vec4f,\n  scaleFGDSpec: vec4f\n  // #endif\n}\n\n@binding(2) @group(0) var<uniform> pbrMaterial : pbrMaterialUniforms;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  NdotL: f32,                  // cos angle between normal and light direction\n  NdotV: f32,                  // cos angle between normal and view direction\n  NdotH: f32,                  // cos angle between normal and half vector\n  LdotH: f32,                  // cos angle between light direction and half vector\n  VdotH: f32,                  // cos angle between view direction and half vector\n  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)\n  metalness: f32,              // metallic value at the surface\n  reflectance0: vec3f,            // full reflectance color (normal incidence angle)\n  reflectance90: vec3f,           // reflectance color at grazing angle\n  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  diffuseColor: vec3f,            // color contribution from diffuse lighting\n  specularColor: vec3f,           // color contribution from specular lighting\n  n: vec3f,                       // normal at surface point\n  v: vec3f,                       // vector from surface point to camera\n};\n\nconst M_PI = 3.141592653589793;\nconst c_MinRoughness = 0.04;\n\nfn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);\n  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4f(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nfn getNormal() -> vec3f\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  var pos_dx: vec3f = dFdx(fragmentInputs.pbr_vPosition);\n  var pos_dy: vec3f = dFdy(fragmentInputs.pbr_vPosition);\n  var tex_dx: vec3f = dFdx(vec3(fragmentInputs.pbr_vUV, 0.0));\n  var tex_dy: vec3f = dFdy(vec3(fragmentInputs.pbr_vUV, 0.0));\n  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  var ng: vec3f = normalize(fragmentInputs.pbr_vNormal);\n#else\n  var ng: vec3f = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  var b: vec3f = normalize(cross(ng, t));\n  var tbn: mat3f = mat3f(t, b, ng);\n#else // HAS_TANGENTS\n  var tbn: mat3f = fragmentInputs.pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, fragmentInputs.pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nfn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nfn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nfn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {\n  let NdotL: f32 = pbrInfo.NdotL;\n  let NdotV: f32 = pbrInfo.NdotV;\n  let r: f32 = pbrInfo.alphaRoughness;\n\n  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {\n  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (PI * f * f);\n}\n\nfn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {\n  (*pbrInfo).NdotL = 1.0;\n  (*pbrInfo).NdotH = 0.0;\n  (*pbrInfo).LdotH = 0.0;\n  (*pbrInfo).VdotH = 1.0;\n}\n\nfn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {\n  let n = (*pbrInfo).n;\n  let v = (*pbrInfo).v;\n  let l = normalize(lightDirection);             // Vector from surface point to light\n  let h = normalize(l + v);                      // Half vector between both l and v\n\n  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);\n  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);\n  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);\n  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nfn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {\n  let light_direction = normalize(pointLight.position - fragmentInputs.pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nfn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {\n  // Calculate the shading terms for the microfacet specular shading model\n  let F = specularReflection(pbrInfo);\n  let G = geometricOcclusion(pbrInfo);\n  let D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nfn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {\n  // The albedo may be defined from a base texture or a flat color\n  var baseColor: vec4<f32>;\n  #ifdef HAS_BASECOLORMAP\n  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, fragmentInputs.pbr_vUV)) * pbrMaterial.baseColorFactor;\n  #else\n  baseColor = pbrMaterial.baseColorFactor;\n  #endif\n\n  #ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n  #endif\n\n  var color = vec3<f32>(0.0, 0.0, 0.0);\n\n  if (pbrMaterial.unlit) {\n    color = baseColor.rgb;\n  } else {\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    var metallic = pbrMaterial.metallicRoughnessValues.x;\n    #ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, fragmentInputs.pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n    #endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    let alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    let f0 = vec3<f32>(0.04);\n    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    let specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflectance to 0%.\n    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    let specularEnvironmentR0 = specularColor;\n    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;\n\n    let n = getNormal();                          // normal at surface point\n    let v = normalize(pbrProjection.camera - fragmentInputs.pbr_vPosition);  // Vector from surface point to camera\n\n    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    let reflection = -normalize(reflect(v, n));\n\n    var pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n    #ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(&pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for (var i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for (var i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));\n        let attenuation = getPointLightAttenuation(\n          lighting_getPointLight(i),\n          distance(lighting_getPointLight(i).position, fragmentInputs.pbr_vPosition)\n        );\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n    #endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n    #ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n    #endif\n\n    // Apply optional PBR terms for additional (optional) shading\n    #ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, fragmentInputs.pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n    #endif\n\n    #ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, fragmentInputs.pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n    #endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n    #ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n    #endif\n  }\n\n  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);\n}\n",vs:"out vec3 pbr_vPosition;\nout vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nout mat3 pbr_vTBN;\n# else\nout vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = pbrProjection.modelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else // HAS_TANGENTS != 1\n  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n",fs:"precision highp float;\n\nuniform pbrMaterialUniforms {\n  // Material is unlit\n  bool unlit;\n\n  // Base color map\n  bool baseColorMapEnabled;\n  vec4 baseColorFactor;\n\n  bool normalMapEnabled;  \n  float normalScale; // #ifdef HAS_NORMALMAP\n\n  bool emissiveMapEnabled;\n  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP\n\n  vec2 metallicRoughnessValues;\n  bool metallicRoughnessMapEnabled;\n\n  bool occlusionMapEnabled;\n  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP\n  \n  bool alphaCutoffEnabled;\n  float alphaCutoff; // #ifdef ALPHA_CUTOFF\n\n  vec3 specularColorFactor;\n  float specularIntensityFactor;\n  bool specularColorMapEnabled;\n  bool specularIntensityMapEnabled;\n\n  float ior;\n\n  float transmissionFactor;\n  bool transmissionMapEnabled;\n\n  float thicknessFactor;\n  float attenuationDistance;\n  vec3 attenuationColor;\n\n  float clearcoatFactor;\n  float clearcoatRoughnessFactor;\n  bool clearcoatMapEnabled;\n\n  vec3 sheenColorFactor;\n  float sheenRoughnessFactor;\n  bool sheenColorMapEnabled;\n\n  float iridescenceFactor;\n  float iridescenceIor;\n  vec2 iridescenceThicknessRange;\n  bool iridescenceMapEnabled;\n\n  float anisotropyStrength;\n  float anisotropyRotation;\n  vec2 anisotropyDirection;\n  bool anisotropyMapEnabled;\n\n  float emissiveStrength;\n  \n  // IBL\n  bool IBLenabled;\n  vec2 scaleIBLAmbient; // #ifdef USE_IBL\n  \n  // debugging flags used for shader output of intermediate PBR variables\n  // #ifdef PBR_DEBUG\n  vec4 scaleDiffBaseMR;\n  vec4 scaleFGDSpec;\n  // #endif\n} pbrMaterial;\n\n// Samplers\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D pbr_baseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D pbr_normalSampler;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D pbr_emissiveSampler;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D pbr_metallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D pbr_occlusionSampler;\n#endif\n#ifdef HAS_SPECULARCOLORMAP\nuniform sampler2D pbr_specularColorSampler;\n#endif\n#ifdef HAS_SPECULARINTENSITYMAP\nuniform sampler2D pbr_specularIntensitySampler;\n#endif\n#ifdef HAS_TRANSMISSIONMAP\nuniform sampler2D pbr_transmissionSampler;\n#endif\n#ifdef HAS_CLEARCOATMAP\nuniform sampler2D pbr_clearcoatSampler;\nuniform sampler2D pbr_clearcoatRoughnessSampler;\n#endif\n#ifdef HAS_SHEENCOLORMAP\nuniform sampler2D pbr_sheenColorSampler;\nuniform sampler2D pbr_sheenRoughnessSampler;\n#endif\n#ifdef HAS_IRIDESCENCEMAP\nuniform sampler2D pbr_iridescenceSampler;\n#endif\n#ifdef HAS_ANISOTROPYMAP\nuniform sampler2D pbr_anisotropySampler;\n#endif\n#ifdef USE_IBL\nuniform samplerCube pbr_diffuseEnvSampler;\nuniform samplerCube pbr_specularEnvSampler;\nuniform sampler2D pbr_brdfLUT;\n#endif\n\n// Inputs from vertex shader\n\nin vec3 pbr_vPosition;\nin vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nin mat3 pbr_vTBN;\n#else\nin vec3 pbr_vNormal;\n#endif\n#endif\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo {\n  float NdotL;                  // cos angle between normal and light direction\n  float NdotV;                  // cos angle between normal and view direction\n  float NdotH;                  // cos angle between normal and half vector\n  float LdotH;                  // cos angle between light direction and half vector\n  float VdotH;                  // cos angle between view direction and half vector\n  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n  float metalness;              // metallic value at the surface\n  vec3 reflectance0;            // full reflectance color (normal incidence angle)\n  vec3 reflectance90;           // reflectance color at grazing angle\n  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n  vec3 diffuseColor;            // color contribution from diffuse lighting\n  vec3 specularColor;           // color contribution from specular lighting\n  vec3 n;                       // normal at surface point\n  vec3 v;                       // vector from surface point to camera\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else // SRGB_FAST_APPROXIMATION\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif //SRGB_FAST_APPROXIMATION\n  return vec4(linOut,srgbIn.w);;\n#else //MANUAL_SRGB\n  return srgbIn;\n#endif //MANUAL_SRGB\n}\n\n// Find the normal for this fragment, pulling either from a predefined normal map\n// or from the interpolated mesh normal and tangent attributes.\nvec3 getNormal()\n{\n  // Retrieve the tangent space matrix\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else // HAS_TANGENTS\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));\n#else\n  // The tbn matrix is linearly interpolated, so we need to re-normalize\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n// Calculation of the lighting contribution from an optional Image Based Light source.\n// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].\n// See our README.md on Environment Maps [3] for additional discussion.\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0; // resolution of 512x512\n  float lod = (pbrInfo.perceptualRoughness * mipCount);\n  // retrieve a scale and bias to F0. See [1], Figure 3\n  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,\n    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;\n  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);\n\n  // For presentation, this allows us to disable IBL terms\n  diffuse *= pbrMaterial.scaleIBLAmbient.x;\n  specular *= pbrMaterial.scaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(PBRInfo pbrInfo)\n{\n  return pbrInfo.diffuseColor / M_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(PBRInfo pbrInfo)\n{\n  return pbrInfo.reflectance0 +\n    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *\n    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(PBRInfo pbrInfo)\n{\n  float NdotL = pbrInfo.NdotL;\n  float NdotV = pbrInfo.NdotV;\n  float r = pbrInfo.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across\n// the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface\n// for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes\n// from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(PBRInfo pbrInfo)\n{\n  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;\n  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {\n  pbrInfo.NdotL = 1.0;\n  pbrInfo.NdotH = 0.0;\n  pbrInfo.LdotH = 0.0;\n  pbrInfo.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {\n  vec3 n = pbrInfo.n;\n  vec3 v = pbrInfo.v;\n  vec3 l = normalize(lightDirection);             // Vector from surface point to light\n  vec3 h = normalize(l+v);                        // Half vector between both l and v\n\n  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInfo, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {\n  // Calculate the shading terms for the microfacet specular shading model\n  vec3 F = specularReflection(pbrInfo);\n  float G = geometricOcclusion(pbrInfo);\n  float D = microfacetDistribution(pbrInfo);\n\n  // Calculation of analytical lighting contribution\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);\n  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);\n  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n  // The albedo may be defined from a base texture or a flat color\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;\n#else\n  vec4 baseColor = pbrMaterial.baseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < pbrMaterial.alphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbrMaterial.unlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n    // Metallic and Roughness material properties are packed together\n    // In glTF, these factors can be specified by fixed scalar values\n    // or from a metallic-roughness map\n    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;\n    float metallic = pbrMaterial.metallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n    // Roughness is authored as perceptual roughness; as is convention,\n    // convert to material roughness by squaring the perceptual roughness [2].\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n\n    // Compute reflectance.\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n    // For typical incident reflectance range (between 4% to 100%) set the grazing\n    // reflectance to 100% for typical fresnel effect.\n    // For very low reflectance range on highly diffuse objects (below 4%),\n    // incrementally reduce grazing reflecance to 0%.\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();                          // normal at surface point\n    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInfo = PBRInfo(\n      0.0, // NdotL\n      NdotV,\n      0.0, // NdotH\n      0.0, // LdotH\n      0.0, // VdotH\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n\n#ifdef USE_LIGHTS\n    // Apply ambient light\n    PBRInfo_setAmbientLight(pbrInfo);\n    color += calculateFinalColor(pbrInfo, lighting.ambientColor);\n\n    // Apply directional light\n    for(int i = 0; i < lighting.directionalLightCount; i++) {\n      if (i < lighting.directionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);\n        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);\n      }\n    }\n\n    // Apply point light\n    for(int i = 0; i < lighting.pointLightCount; i++) {\n      if (i < lighting.pointLightCount) {\n        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));\n        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));\n        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);\n      }\n    }\n#endif\n\n    // Calculate lighting contribution from image based lighting source (IBL)\n#ifdef USE_IBL\n    if (pbrMaterial.IBLenabled) {\n      color += getIBLContribution(pbrInfo, n, reflection);\n    }\n#endif\n\n // Apply optional PBR terms for additional (optional) shading\n#ifdef HAS_OCCLUSIONMAP\n    if (pbrMaterial.occlusionMapEnabled) {\n      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;\n      color = mix(color, color * ao, pbrMaterial.occlusionStrength);\n    }\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    if (pbrMaterial.emissiveMapEnabled) {\n      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;\n      color += emissive;\n    }\n#endif\n\n    // This section uses mix to override final color for reference app visualization\n    // of various parameters in the lighting equation.\n#ifdef PBR_DEBUG\n    // TODO: Figure out how to debug multiple lights\n\n    // color = mix(color, F, pbr_scaleFGDSpec.x);\n    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);\n    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);\n    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);\n\n    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);\n    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n",defines:{LIGHTING_FRAGMENT:!0,HAS_NORMALMAP:!1,HAS_EMISSIVEMAP:!1,HAS_OCCLUSIONMAP:!1,HAS_BASECOLORMAP:!1,HAS_METALROUGHNESSMAP:!1,HAS_SPECULARCOLORMAP:!1,HAS_SPECULARINTENSITYMAP:!1,HAS_TRANSMISSIONMAP:!1,HAS_CLEARCOATMAP:!1,HAS_SHEENCOLORMAP:!1,HAS_IRIDESCENCEMAP:!1,HAS_ANISOTROPYMAP:!1,ALPHA_CUTOFF:!1,USE_IBL:!1,PBR_DEBUG:!1},getUniforms:function(e){return e},uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>",specularColorFactor:"vec3<f32>",specularIntensityFactor:"f32",specularColorMapEnabled:"i32",specularIntensityMapEnabled:"i32",ior:"f32",transmissionFactor:"f32",transmissionMapEnabled:"i32",thicknessFactor:"f32",attenuationDistance:"f32",attenuationColor:"vec3<f32>",clearcoatFactor:"f32",clearcoatRoughnessFactor:"f32",clearcoatMapEnabled:"i32",sheenColorFactor:"vec3<f32>",sheenRoughnessFactor:"f32",sheenColorMapEnabled:"i32",iridescenceFactor:"f32",iridescenceIor:"f32",iridescenceThicknessRange:"vec2<f32>",iridescenceMapEnabled:"i32",anisotropyStrength:"f32",anisotropyRotation:"f32",anisotropyDirection:"vec2<f32>",anisotropyMapEnabled:"i32",emissiveStrength:"f32"}},tr=function(e){function n(n){var t;return(t=e.call(this,n)||this).bounds=null,t.model=n.model,t.managedResources=n.managedResources||[],t.bounds=n.bounds||null,t.setProps(n),t}(0,s.A)(n,e);var t=n.prototype;return t.destroy=function(){this.model&&(this.model.destroy(),this.model=null),this.managedResources.forEach(function(e){return e.destroy()}),this.managedResources=[]},t.getBounds=function(){return this.bounds},t.draw=function(e){return this.model.draw(e)},n}(Wt),rr=["camera"];var ir=t(3369);function or(e){return Object.assign({addressModeU:ar(e.wrapS),addressModeV:ar(e.wrapT),magFilter:sr(e.magFilter)},function(e){switch(e){case ir.GL.NEAREST:return{minFilter:"nearest"};case ir.GL.LINEAR:return{minFilter:"linear"};case ir.GL.NEAREST_MIPMAP_NEAREST:return{minFilter:"nearest",mipmapFilter:"nearest"};case ir.GL.LINEAR_MIPMAP_NEAREST:return{minFilter:"linear",mipmapFilter:"nearest"};case ir.GL.NEAREST_MIPMAP_LINEAR:return{minFilter:"nearest",mipmapFilter:"linear"};case ir.GL.LINEAR_MIPMAP_LINEAR:return{minFilter:"linear",mipmapFilter:"linear"};default:return{}}}(e.minFilter))}function ar(e){switch(e){case ir.GL.CLAMP_TO_EDGE:return"clamp-to-edge";case ir.GL.REPEAT:return"repeat";case ir.GL.MIRRORED_REPEAT:return"mirror-repeat";default:return}}function sr(e){switch(e){case ir.GL.NEAREST:return"nearest";case ir.GL.LINEAR:return"linear";default:return}}function lr(e,n,t,r){var i={defines:{MANUAL_SRGB:!0,SRGB_FAST_APPROXIMATION:!0},bindings:{},uniforms:{camera:[0,0,0],metallicRoughnessValues:[1,1]},parameters:{},glParameters:{},generatedTextures:[]};i.defines.USE_TEX_LOD=!0;var o=r.imageBasedLightingEnvironment;return o&&(i.bindings.pbr_diffuseEnvSampler=o.diffuseEnvSampler.texture,i.bindings.pbr_specularEnvSampler=o.specularEnvSampler.texture,i.bindings.pbr_BrdfLUT=o.brdfLutTexture.texture,i.uniforms.scaleIBLAmbient=[1,1]),null!=r&&r.pbrDebug&&(i.defines.PBR_DEBUG=!0,i.uniforms.scaleDiffBaseMR=[0,0,0,0],i.uniforms.scaleFGDSpec=[0,0,0,0]),t.NORMAL&&(i.defines.HAS_NORMALS=!0),t.TANGENT&&null!=r&&r.useTangents&&(i.defines.HAS_TANGENTS=!0),t.TEXCOORD_0&&(i.defines.HAS_UV=!0),null!=r&&r.imageBasedLightingEnvironment&&(i.defines.USE_IBL=!0),null!=r&&r.lights&&(i.defines.USE_LIGHTS=!0),n&&function(e,n,t){t.uniforms.unlit=Boolean(n.unlit),n.pbrMetallicRoughness&&function(e,n,t){n.baseColorTexture&&cr(e,n.baseColorTexture,"pbr_baseColorSampler","HAS_BASECOLORMAP",t);t.uniforms.baseColorFactor=n.baseColorFactor||[1,1,1,1],n.metallicRoughnessTexture&&cr(e,n.metallicRoughnessTexture,"pbr_metallicRoughnessSampler","HAS_METALROUGHNESSMAP",t);var r=n.metallicFactor,i=void 0===r?1:r,o=n.roughnessFactor,a=void 0===o?1:o;t.uniforms.metallicRoughnessValues=[i,a]}(e,n.pbrMetallicRoughness,t);if(n.normalTexture){cr(e,n.normalTexture,"pbr_normalSampler","HAS_NORMALMAP",t);var r=n.normalTexture.scale,i=void 0===r?1:r;t.uniforms.normalScale=i}if(n.occlusionTexture){cr(e,n.occlusionTexture,"pbr_occlusionSampler","HAS_OCCLUSIONMAP",t);var o=n.occlusionTexture.strength,a=void 0===o?1:o;t.uniforms.occlusionStrength=a}n.emissiveTexture&&(cr(e,n.emissiveTexture,"pbr_emissiveSampler","HAS_EMISSIVEMAP",t),t.uniforms.emissiveFactor=n.emissiveFactor||[0,0,0]);switch(n.alphaMode||"MASK"){case"MASK":var s=n.alphaCutoff,l=void 0===s?.5:s;t.defines.ALPHA_CUTOFF=!0,t.uniforms.alphaCutoff=l;break;case"BLEND":c.R.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(),t.parameters.blend=!0,t.parameters.blendColorOperation="add",t.parameters.blendColorSrcFactor="src-alpha",t.parameters.blendColorDstFactor="one-minus-src-alpha",t.parameters.blendAlphaOperation="add",t.parameters.blendAlphaSrcFactor="one",t.parameters.blendAlphaDstFactor="one-minus-src-alpha",t.glParameters.blend=!0,t.glParameters.blendEquation=ir.GL.FUNC_ADD,t.glParameters.blendFunc=[ir.GL.SRC_ALPHA,ir.GL.ONE_MINUS_SRC_ALPHA,ir.GL.ONE,ir.GL.ONE_MINUS_SRC_ALPHA]}}(e,n,i),i}function cr(e,n,t,r,i){var o,a,s=n.texture.source.image;a=s.compressed?s:{data:s};var l=Object.assign({wrapS:10497,wrapT:10497},null==n||null==(o=n.texture)?void 0:o.sampler),c=e.createTexture(Object.assign({id:n.uniformName||n.id,sampler:or(l)},a));i.bindings[t]=c,r&&(i.defines[r]=!0),i.generatedTextures.push(c)}var ur={modelOptions:{},pbrDebug:!1,imageBasedLightingEnvironment:void 0,lights:!0,useTangents:!1};function fr(e,n,t){void 0===t&&(t={});var r=Object.assign({},ur,t),i=n.scenes.map(function(t){return function(e,n,t,r){var i=n.nodes||[],o=i.map(function(n){return dr(e,n,t,r)}),a=new Yt({id:n.name||n.id,children:o});return a}(e,t,n.nodes,r)});return i}function dr(e,n,t,r){if(!n._node){var i=(n.children||[]).map(function(n){return dr(e,n,t,r)});n.mesh&&i.push(function(e,n,t){if(!n._mesh){var r=(n.primitives||[]).map(function(r,i){return function(e,n,t,r,i){var o=n.name||(r.name||r.id)+"-primitive-"+t,a=function(e){switch(e){case Qt.POINTS:return"point-list";case Qt.LINES:return"line-list";case Qt.LINE_STRIP:return"line-strip";case Qt.TRIANGLES:return"triangle-list";case Qt.TRIANGLE_STRIP:return"triangle-strip";default:throw new Error(String(e))}}(n.mode||4),s=n.indices?n.indices.count:function(){throw new Error("getVertexCount not implemented")}(n.attributes),l=pr(o,n,a),u=lr(e,n.material,l.attributes,i),f=function(e,n){var t=n.id,r=n.geometry,i=n.parsedPPBRMaterial,o=n.vertexCount,a=n.modelOptions,s=void 0===a?{}:a;c.R.info(4,"createGLTFModel defines: ",i.defines)();var l=Object.assign({id:t,source:"\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n",vs:"#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n",fs:"#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n",geometry:r,topology:r.topology,vertexCount:o,modules:[nr]},s,{defines:Object.assign({},i.defines,s.defines),parameters:Object.assign({},{depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},i.parameters,s.parameters)}),u=new Ge(e,l),f=Object.assign({},i.uniforms,s.uniforms,i.bindings,s.bindings),d=f.camera,p=(0,Kt.A)(f,rr);return u.shaderInputs.setProps({pbrMaterial:p,pbrProjection:{camera:d}}),new tr({managedResources:[],model:u})}(e,{id:o,geometry:pr(o,n,a),parsedPPBRMaterial:u,modelOptions:i.modelOptions,vertexCount:s});return f.bounds=[n.attributes.POSITION.min,n.attributes.POSITION.max],f}(e,r,i,n,t)}),i=new Yt({id:n.name||n.id,children:r});n._mesh=i}return n._mesh}(e,n.mesh,r));var o=new Yt({id:n.name||n.id,children:i});if(n.matrix)o.setMatrix(n.matrix);else{if(o.matrix.identity(),n.translation&&o.matrix.translate(n.translation),n.rotation){var a=(new en.k).fromQuaternion(n.rotation);o.matrix.multiplyRight(a)}n.scale&&o.matrix.scale(n.scale)}n._node=o}var s=t.find(function(e){return e.id===n.id});return s._node=n._node,n._node}function pr(e,n,t){for(var r={},i=0,o=Object.entries(n.attributes);i<o.length;i++){var a=o[i],s=a[0],l=a[1],c=l.components,u=l.size,f=l.value;r[s]={size:null!=u?u:c,value:f}}return new He({id:e,topology:t,indices:n.indices.value,attributes:r})}function hr(e,n,t,r){var i=[1,0,0];return void 0!==r&&r>0&&(i=[1,0,1/(r*r)]),{type:"point",position:e.translation?[].concat(e.translation):[0,0,0],color:n,intensity:t,attenuation:i}}function mr(e,n,t){var r=[0,0,-1];e.rotation&&(r=(new en.k).fromQuaternion(e.rotation).transformDirection([0,0,-1]));return{type:"directional",direction:r,color:n,intensity:t}}var gr=new(t(1633).P);function _r(e,n,t,r){var i=n.input,o=n.interpolation,a=n.output,s=e%i[i.length-1],l=i.findIndex(function(e){return e>=s}),u=Math.max(0,l-1);if(!Array.isArray(t[r]))switch(r){case"translation":t[r]=[0,0,0];break;case"rotation":t[r]=[0,0,0,1];break;case"scale":t[r]=[1,1,1];break;default:c.R.warn("Bad animation path "+r)()}var f=i[u],d=i[l];switch(o){case"STEP":!function(e,n,t){if(!e[n])throw new Error;for(var r=0;r<t.length;r++)e[n][r]=t[r]}(t,r,a[u]);break;case"LINEAR":if(d>f){var p=(s-f)/(d-f);!function(e,n,t,r,i){if(!e[n])throw new Error;if("rotation"===n){gr.slerp({start:t,target:r,ratio:i});for(var o=0;o<gr.length;o++)e[n][o]=gr[o]}else for(var a=0;a<t.length;a++)e[n][a]=i*r[a]+(1-i)*t[a]}(t,r,a[u],a[l],p)}break;case"CUBICSPLINE":if(d>f){var h=(s-f)/(d-f),m=d-f;!function(e,n,t){var r=t.p0,i=t.outTangent0,o=t.inTangent1,a=t.p1,s=t.tDiff,l=t.ratio;if(!e[n])throw new Error;for(var c=0;c<e[n].length;c++){var u=i[c]*s,f=o[c]*s;e[n][c]=(2*Math.pow(l,3)-3*Math.pow(l,2)+1)*r[c]+(Math.pow(l,3)-2*Math.pow(l,2)+l)*u+(-2*Math.pow(l,3)+3*Math.pow(l,2))*a[c]+(Math.pow(l,3)-Math.pow(l,2))*f}}(t,r,{p0:a[3*u+1],outTangent0:a[3*u+2],inTangent1:a[3*l+0],p1:a[3*l+1],tDiff:m,ratio:h})}break;default:c.R.warn("Interpolation "+o+" not supported")()}}var vr=function(){function e(e){var n;this.startTime=0,this.playing=!0,this.speed=1,this.animation=e.animation,(n=this.animation).name||(n.name="unnamed"),Object.assign(this,e)}return e.prototype.setTime=function(e){if(this.playing){var n=(e/1e3-this.startTime)*this.speed;this.animation.channels.forEach(function(e){var t=e.sampler,r=e.target,i=e.path;_r(n,t,r,i),function(e,n){n.matrix.identity(),e.translation&&n.matrix.translate(e.translation);if(e.rotation){var t=Er.fromQuaternion(e.rotation);n.matrix.multiplyRight(t)}e.scale&&n.matrix.scale(e.scale)}(r,r._node)})}},e}(),Ar=function(){function e(e){this.animations=e.animations.map(function(e,n){var t=e.name||"Animation-"+n;return new vr({animation:{name:t,channels:e.channels}})})}var n=e.prototype;return n.animate=function(e){c.R.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")(),this.setTime(e)},n.setTime=function(e){this.animations.forEach(function(n){return n.setTime(e)})},n.getAnimations=function(){return this.animations},e}(),Er=new en.k;var Tr={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},br={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function xr(e){if(!e._animation){var n=function(e){var n,t,r=br[e.componentType],i=Tr[e.type],o=i*e.count,a=null!=(n=null==(t=e.bufferView)?void 0:t.data)?n:{},s=a.buffer,l=a.byteOffset;return{typedArray:new r(s,(void 0===l?0:l)+(e.byteOffset||0),o),components:i}}(e),t=n.typedArray,r=n.components;if(1===r)e._animation=Array.from(t);else{for(var i=[],o=0;o<t.length;o+=r)i.push(Array.from(t.slice(o,o+r)));e._animation=i}}return e._animation}function Rr(e){if(ArrayBuffer.isView(e)||e instanceof ArrayBuffer||e instanceof ImageBitmap)return e;if(Array.isArray(e))return e.map(Rr);if(e&&"object"==typeof e){var n={};for(var t in e)n[t]=Rr(e[t]);return n}return e}function Cr(e,n,t){var r=fr(e,n=Rr(n),t),i=function(e){return(e.animations||[]).map(function(n,t){var r=n.name||"Animation-"+t,i=n.samplers.map(function(n){var t=n.input,r=n.interpolation,i=void 0===r?"LINEAR":r,o=n.output;return{input:xr(e.accessors[t]),interpolation:i,output:xr(e.accessors[o])}});return{name:r,channels:n.channels.map(function(n){var t,r=n.sampler,o=n.target;return{sampler:i[r],target:e.nodes[null!=(t=o.node)?t:0],path:o.path}})}})}(n),o=new Ar({animations:i}),s=function(e){var n,t=null==(n=e.extensions)||null==(n=n.KHR_lights_punctual)?void 0:n.lights;if(!t||!Array.isArray(t)||0===t.length)return[];for(var r,i=[],o=(0,a.A)(e.nodes||[]);!(r=o()).done;){var s,l,c=r.value,u=null==(s=c.extensions)?void 0:s.KHR_lights_punctual;if(u&&"number"==typeof u.light){var f=t[u.light];if(f){var d=f.color||[1,1,1],p=null!=(l=f.intensity)?l:1,h=f.range;switch(f.type){case"directional":i.push(mr(c,d,p));break;case"point":case"spot":i.push(hr(c,d,p,h))}}}}return i}(n);return{scenes:r,animator:o,lights:s}}var Sr=t(2354),Ir=t(9737),Pr={ambientLight:{color:[255,133,133],intensity:1,type:"ambient"},directionalLights:[{color:[222,244,255],direction:[1,-.5,.5],intensity:10,type:"directional"}],pointLights:[{color:[255,222,222],position:[3,10,0],intensity:5,type:"point"}]},Nr=function(e){function n(n){var t,r,i=n.device;n.animationLoop;if((r=e.call(this)||this).scenes=[],r.center=[0,0,0],r.cameraPos=[0,0,0],r.time=0,r.options={cameraAnimation:!0,gltfAnimation:!1,pbr:!1},r.device=i,"webgl"!==i.type)throw new Error("This demo is only implemented for WebGL2");return null!=(t=window.localStorage)["last-gltf-model"]||(t["last-gltf-model"]="Avocado"),r.loadGLTF(window.localStorage["last-gltf-model"]),function(e){for(var n=function(){var n=r[t],i=document.getElementById(n);i.checked=e[n],i.addEventListener("change",function(t){e[n]=i.checked})},t=0,r=Object.keys(e);t<r.length;t++)n()}(r.options),r.fetchModelList().then(function(e){window.localStorage["last-gltf-model"];!function(e,n,t){var r=document.getElementById("model-select");null==r||r.addEventListener("change",function(e){var n=e.target.value;t(n)});var i=e.map(function(e){var n=document.createElement("option");return n.value=e,n.textContent=e,n});r.append.apply(r,i)}(e.map(function(e){return e.name}),0,function(e){r.loadGLTF(e),window.localStorage["last-gltf-model"]=e})}),r}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.scenes[0].traverse(function(e){return e.model.destroy()})},t.onRender=function(e){var n,t=e.aspect,r=e.device,i=e.time;if(null!=(n=this.scenes)&&n.length){var o,a=r.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1}),s=2*this.cameraPos[0],l=s/1e3,c=(new en.k).perspective({fovy:Math.PI/3,aspect:t,near:l,far:s}),u=this.options.cameraAnimation?i:0,f=[this.cameraPos[0]*Math.sin(.001*u),this.cameraPos[1],this.cameraPos[2]*Math.cos(.001*u)];if(this.options.gltfAnimation)null==(o=this.animator)||o.setTime(i);var d=(new en.k).lookAt({eye:f,center:this.center});this.scenes[0].traverse(function(e,n){var t=n.worldMatrix,r=e.model,i=new en.k(c).multiplyRight(d).multiplyRight(t);r.shaderInputs.setProps({lighting:Pr,pbrProjection:{camera:f,modelViewProjectionMatrix:i,modelMatrix:t,normalMatrix:new en.k(t).invert().transpose()}}),r.draw(a)}),a.end()}},t.fetchModelList=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(){var n,t;return(0,Ce.A)().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,fetch("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/model-index.json");case 1:return n=e.v,e.n=2,n.json();case 2:return t=e.v,e.a(2,t)}},e)}));return function(){return e.apply(this,arguments)}}(),t.loadGLTF=function(){var e=(0,Se.A)((0,Ce.A)().m(function e(n){var t,r,i,o,a,s,l,c;return(0,Ce.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:return e.p=0,(t=this.device.getDefaultCanvasContext().canvas).style.opacity="0.1",e.n=1,(0,jt.H)("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models//"+n+"/glTF/"+n+".gltf",Sr.B);case 1:r=e.v,i=(0,Ir.R)(r),o=Cr(this.device,i,{lights:!0,imageBasedLightingEnvironment:void 0,pbrDebug:!1}),a=o.scenes,s=o.animator,this.scenes=a,this.animator=s,l=[1/0,1/0,1/0],c=[0,0,0],this.scenes[0].traverse(function(e){var n=e.bounds;l=l.map(function(e,t){return Math.min(e,n[0][t],n[1][t])}),c=c.map(function(e,t){return Math.max(e,n[0][t],n[1][t])})}),this.cameraPos=[2*(c[0]+c[2]),c[1],2*(c[0]+c[2])],this.center=[.5*(l[0]+c[0]),.5*(l[1]+c[1]),.5*(l[2]+c[2])],t.style.opacity="1",yr(),e.n=3;break;case 2:e.p=2,yr(e.v);case 3:return e.a(2)}},e,this,[[0,2]])}));return function(n){return e.apply(this,arguments)}}(),n}(Je);function yr(e){var n=document.getElementById("error");n.innerHTML=e?"Error loading model "+e.message:"",n.style.display=e?"block":"hidden"}var Lr={name:"phongMaterial",dependencies:[Jt],source:"struct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n",vs:"uniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n",fs:"#define MAX_LIGHTS 3\n\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n",defines:{LIGHTING_FRAGMENT:!0},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms:function(e){var n=Object.assign({},e);return n.specularColor&&(n.specularColor=n.specularColor.map(function(e){return e/255})),Object.assign({},Lr.defaultUniforms,n)}},Fr={name:"app",uniformTypes:{modelMatrix:"mat4x4<f32>",mvpMatrix:"mat4x4<f32>",eyePosition:"vec3<f32>"}},Mr=[0,0,5],Or=function(e){function n(n){var t,r=n.device;(t=e.call(this)||this).shaderInputs=new Re({app:Fr,lighting:Jt,phongMaterial:Lr}),t.modelMatrix=new en.k,t.viewMatrix=(new en.k).lookAt({eye:Mr}),t.mvpMatrix=new en.k,t.shaderInputs.setProps({lighting:{lights:[{type:"ambient",color:[255,255,255]},{type:"point",color:[255,120,10],position:[2,4,3]},{type:"point",color:[0,255,10],position:[-2,1,3]}]},phongMaterial:{specularColor:[255,255,255],shininess:100}});var i=new Ue(r,{data:(0,an.Dt)("vis-logo.png")});return t.model=new Ge(r,{source:"\nstruct Uniforms {\n  modelMatrix : mat4x4<f32>,\n  mvpMatrix : mat4x4<f32>,\n  eyePosition : vec3<f32>,\n};\n\n@binding(0) @group(0) var<uniform> app : Uniforms;\n@group(0) @binding(1) var uTexture : texture_2d<f32>;\n@group(0) @binding(2) var uTextureSampler : sampler;\n\nstruct VertexInputs {\n  // CUBE GEOMETRY\n  @location(0) positions : vec3<f32>,\n  @location(1) normals : vec3<f32>,\n  @location(2) texCoords : vec2<f32>\n};\n\nstruct FragmentInputs {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n  @location(1) fragPosition: vec3<f32>,\n  @location(2) fragNormal: vec3<f32>\n}\n\n@vertex\nfn vertexMain(inputs: VertexInputs) -> FragmentInputs {\n  var outputs : FragmentInputs;\n  outputs.Position = app.mvpMatrix * app.modelMatrix * vec4<f32>(inputs.positions, 1);\n  outputs.fragUV = inputs.texCoords;\n  outputs.fragPosition = (app.modelMatrix * vec4<f32>(inputs.positions, 1.0)).xyz;\n  // NOTE: WGSL lacks conversion syntax: https://github.com/gpuweb/gpuweb/issues/2399\n  let mat3 = mat3x3(app.modelMatrix[0].xyz, app.modelMatrix[1].xyz, app.modelMatrix[2].xyz);\n  outputs.fragNormal = mat3 * inputs.normals;\n  return outputs;\n  //   vPosition = (app.modelMatrix * vec4(positions, 1.0)).xyz;\n  //   vNormal = mat3(app.modelMatrix) * normals;\n  //   vUV = texCoords;\n  //   gl_Position = app.mvpMatrix * vec4(positions, 1.0);\n}\n\n@fragment\nfn fragmentMain(inputs: FragmentInputs) -> @location(0) vec4<f32> {\n  // return inputs.fragPosition;\n  return textureSample(uTexture, uTextureSampler, inputs.fragUV);\n//   vec3 surfaceColor = texture(uTexture, vec2(vUV.x, 1.0 - vUV.y)).rgb;\n//   surfaceColor = lighting_getLightColor(surfaceColor, uApp.eyePosition, vPosition, normalize(vNormal));\n//   fragColor = vec4(surfaceColor, 1.0);\n}\n",vs:"#version 300 es\n\nin vec3 positions;\nin vec3 normals;\nin vec2 texCoords;\n\nout vec3 vPosition;\nout vec3 vNormal;\nout vec2 vUV;\nout vec3 vColor;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 mvpMatrix;\n  vec3 eyePosition;\n} app;\n\nvoid main(void) {\n  vPosition = (app.modelMatrix * vec4(positions, 1.0)).xyz;\n  vNormal = mat3(app.modelMatrix) * normals;\n  vUV = texCoords;\n\n  #ifdef LIGHTING_VERTEX\n  vColor = lighting_getLightColor(vec3(1.0), app.eyePosition, vPosition, normalize(vNormal));\n  #endif\n  gl_Position = app.mvpMatrix * vec4(positions, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nin vec3 vPosition;\nin vec3 vNormal;\nin vec2 vUV;\nin vec3 vColor;\n\nuniform sampler2D uTexture;\n\nuniform appUniforms {\n  mat4 modelMatrix;\n  mat4 mvpMatrix;\n  vec3 eyePosition;\n} app;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  #ifdef LIGHTING_FRAGMENT\n  vec3 surfaceColor = texture(uTexture, vec2(vUV.x, 1.0 - vUV.y)).rgb;\n  surfaceColor = lighting_getLightColor(surfaceColor, app.eyePosition, vPosition, normalize(vNormal));\n  fragColor = vec4(surfaceColor, 1.0);\n  #endif\n\n  #ifdef LIGHTING_VERTEX\n  fragColor = vec4(vColor, 1.0);\n  #endif\n}\n",shaderInputs:t.shaderInputs,geometry:new Ve,instanceCount:1,bindings:{uTexture:i},parameters:{depthWriteEnabled:!0,depthCompare:"less-equal"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model.destroy()},t.onRender=function(e){var n=e.device,t=e.aspect,r=e.tick;this.modelMatrix.identity().rotateX(.01*r).rotateY(.013*r),this.mvpMatrix.perspective({fovy:Math.PI/3,aspect:t}).multiplyRight(this.viewMatrix).multiplyRight(this.modelMatrix),this.shaderInputs.setProps({app:{mvpMatrix:this.mvpMatrix,modelMatrix:this.modelMatrix}});var i=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:!0});this.model.draw(i),i.end()},n}(Je);Or.info="<p>\nDrawing a phong-shaded cube\n</p>\n";var wr="#version 300 es\n\nin vec2 position;\n\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n  OFFSET_POSITION(gl_Position);\n}\n",Ur="#version 300 es\n\nuniform appUniforms {  \n  vec3 color;\n} app;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(app.color, 1.0);\n}\n",Dr={name:"offsetLeft",inject:{"vs:OFFSET_POSITION":"position.x -= 0.5;"}},Br={name:"offsetRight",inject:{"vs:OFFSET_POSITION":"position.x += 0.5;"}},Gr=function(e){function n(n){var t,r=n.device;n.animationLoop;if((t=e.call(this)||this).uniformStore=new g({app:{uniformTypes:{color:"vec3<f32>"}}}),"webgl"!==r.type)throw new Error("This demo is only implemented for WebGL2");var i=le.getDefaultShaderAssembler();i.addShaderHook("vs:OFFSET_POSITION(inout vec4 position)"),t.positionBuffer=r.createBuffer(new Float32Array([-.3,-.5,.3,-.5,0,.5])),t.uniformBuffer1=t.uniformStore.createUniformBuffer(r,"app",{app:{color:[1,0,0]}});var o=t.uniformStore.getUniformBufferData("app");return t.uniformBuffer1.write(o),t.uniformBuffer2=t.uniformStore.createUniformBuffer(r,"app",{app:{color:[0,0,1]}}),t.model1=new Ge(r,{vs:wr,fs:Ur,shaderAssembler:i,modules:[Dr],bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:t.positionBuffer},vertexCount:3,bindings:{app:t.uniformBuffer1}}),t.model2=new Ge(r,{vs:wr,fs:Ur,shaderAssembler:i,modules:[Br],bufferLayout:[{name:"position",format:"float32x2"}],vertexCount:3,attributes:{position:t.positionBuffer},bindings:{app:t.uniformBuffer2}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model1.destroy(),this.model2.destroy(),this.positionBuffer.destroy(),this.uniformStore.destroy(),this.uniformBuffer1.destroy(),this.uniformBuffer2.destroy()},t.onRender=function(e){var n=e.device.beginRenderPass({clearColor:[0,0,0,1]});this.model1.draw(n),this.model2.draw(n),n.end()},n}(Je);Gr.info="\nModifying shader behavior with shader hooks\n";var Xr={name:"color",source:"fn color_hsv2rgb(hsv: vec3<f32>) -> vec3<f32> {\n  let K = vec4<f32>(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  let p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n  let rgb = hsv.z * mix(K.xxx, clamp(p - K.xxx, vec3<f32>(0.0), vec3<f32>(1.0)), hsv.y);\n  return rgb;\n}\n",fs:"vec3 color_hsv2rgb(vec3 hsv) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);\n  vec3 rgb = hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);\n  return rgb;\n}\n  ",uniformTypes:{hsv:"vec3<f32>"}},Hr=function(e){function n(n){var t,r=n.device;return(t=e.call(this)||this).shaderInputs1=new Re({color:Xr}),t.shaderInputs2=new Re({color:Xr}),t.positionBuffer=r.createBuffer(new Float32Array([-.3,-.5,.3,-.5,0,.5])),t.shaderInputs1.setProps({color:{hsv:[.7,1,1]}}),t.shaderInputs2.setProps({color:{hsv:[1,1,1]}}),t.model1=new Ge(r,{id:"model1",source:"struct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n};\n\n@vertex\nfn vertexMain(@location(0) position: vec2<f32>) -> VertexOutput {\n  var output: VertexOutput;\n  output.position = vec4<f32>(position - vec2<f32>(0.5, 0.0), 0.0, 1.0);\n  return output;\n}\n\nstruct ColorUniforms {\n  hsv: vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> color: ColorUniforms;\n\n@fragment\nfn fragmentMain() -> @location(0) vec4<f32> {\n  return vec4<f32>(color_hsv2rgb(color.hsv), 1.0);\n}\n",vs:"#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position - vec2(0.5, 0.0), 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nuniform colorUniforms {\n  vec3 hsv;\n} color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(color_hsv2rgb(color.hsv), 1.0);\n}\n",shaderInputs:t.shaderInputs1,bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:t.positionBuffer},vertexCount:3,parameters:{depthWriteEnabled:!0,depthCompare:"less"}}),t.model2=new Ge(r,{id:"model2",source:"struct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n};\n\n@vertex\nfn vertexMain(@location(0) position: vec2<f32>) -> VertexOutput {\n  var output: VertexOutput;\n  output.position = vec4<f32>(position + vec2<f32>(0.5, 0.0), 0.0, 1.0);\n  return output;\n}\n\nstruct ColorUniforms {\n  hsv: vec3<f32>,\n};\n\n@group(0) @binding(0) var<uniform> color: ColorUniforms;\n\n@fragment\nfn fragmentMain() -> @location(0) vec4<f32> {\n  return vec4<f32>(color_hsv2rgb(color.hsv) - vec3<f32>(0.3), 1.0);\n}\n",vs:"#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position + vec2(0.5, 0.0), 0.0, 1.0);\n}\n",fs:"#version 300 es\n\nprecision highp float;\n\nuniform colorUniforms {\n  vec3 hsv;\n} color;\n\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = vec4(color_hsv2rgb(color.hsv) - 0.3, 1.0);\n}\n",shaderInputs:t.shaderInputs2,bufferLayout:[{name:"position",format:"float32x2"}],attributes:{position:t.positionBuffer},vertexCount:3,parameters:{depthWriteEnabled:!0,depthCompare:"less"}}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.model1.destroy(),this.model2.destroy(),this.positionBuffer.destroy()},t.onRender=function(e){var n=e.device.beginRenderPass({clearColor:[0,0,0,1]});this.model1.draw(n),this.model2.draw(n),n.end()},n}(Je);Hr.info="\nRe-using shader code with shader modules\n";function Vr(e){var n=e||{},t=n.input,r=n.inputChannels,i=n.output;if(!t)return"#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";if(!r)throw new Error("inputChannels");return"#version 300 es\nin "+function(e){switch(e){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error("invalid channels: "+e)}}(r)+" "+t+";\nout vec4 "+i+";\nvoid main() {\n  "+i+" = "+function(e,n){switch(n){case 1:return"vec4("+e+", 0.0, 0.0, 1.0)";case 2:return"vec4("+e+", 0.0, 1.0)";case 3:return"vec4("+e+", 1.0)";case 4:return e;default:throw new Error("invalid channels: "+n)}}(t,r)+";\n}"}var kr=function(){function e(n,t){if(void 0===t&&(t=e.defaultProps),!e.isSupported(n))throw new Error("BufferTransform not yet implemented on WebGPU");this.device=n,this.model=new Ge(this.device,Object.assign({id:t.id||"buffer-transform-model",fs:t.fs||Vr(),topology:t.topology||"point-list",varyings:t.outputs||t.varyings},t)),this.transformFeedback=this.device.createTransformFeedback({layout:this.model.pipeline.shaderLayout,buffers:t.feedbackBuffers}),this.model.setTransformFeedback(this.transformFeedback),Object.seal(this)}e.isSupported=function(e){var n;return"webgl"===(null==e||null==(n=e.info)?void 0:n.type)};var n=e.prototype;return n.destroy=function(){this.model&&this.model.destroy()},n.delete=function(){this.destroy()},n.run=function(e){null!=e&&e.inputBuffers&&this.model.setAttributes(e.inputBuffers),null!=e&&e.outputBuffers&&this.transformFeedback.setBuffers(e.outputBuffers);var n=this.device.beginRenderPass(e);this.model.draw(n),n.end()},n.getBuffer=function(e){return this.transformFeedback.getBuffer(e)},n.readAsync=function(e){var n=this.getBuffer(e);if(!n)throw new Error("BufferTransform#getBuffer");if(n instanceof l.h)return n.readAsync();var t=n.buffer,r=n.byteOffset,i=void 0===r?0:r,o=n.byteLength,a=void 0===o?t.byteLength:o;return t.readAsync(i,a)},e}();kr.defaultProps=Object.assign({},Ge.defaultProps,{outputs:void 0,feedbackBuffers:void 0});var zr=function(e){function n(n){var t,r=n.device;n.animationLoop;if(t=e.call(this)||this,"webgl"!==r.type)throw new Error("This demo is only implemented for WebGL2");return t.positionBuffers=new ot({current:r.createBuffer(new Float32Array([-.5,-.5,.5,-.5,0,.5])),next:r.createBuffer(new Float32Array(6))}),t.colorBuffer=r.createBuffer(new Float32Array([1,0,0,0,1,0,0,0,1])),t.transform=new kr(r,{vs:"#version 300 es\n#define SIN2 0.03489949\n#define COS2 0.99939082\n\nmat2 rotation = mat2(\n  COS2, SIN2,\n  -SIN2, COS2\n);\n\nin vec2 oldPositions;\nout vec2 newPositions;\n\nvoid main() {\n  newPositions = rotation * oldPositions;\n}\n",bufferLayout:[{name:"oldPositions",format:"float32x2"}],outputs:["newPositions"],vertexCount:3}),t.model=new Ge(r,{vs:"#version 300 es\n\nin vec2 position;\nin vec3 color;\nout vec3 vColor;\n\nvoid main() {\n    vColor = color;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",fs:"#version 300 es\nprecision highp float;\n\nin vec3 vColor;\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vec4(vColor, 1.0);\n}\n",attributes:{color:t.colorBuffer},bufferLayout:[{name:"position",format:"float32x2"},{name:"color",format:"float32x3"}],vertexCount:3}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.transform.destroy(),this.model.destroy(),this.positionBuffers.destroy(),this.colorBuffer.destroy()},t.onRender=function(e){var n=e.device;this.transform.run({inputBuffers:{oldPositions:this.positionBuffers.current},outputBuffers:{newPositions:this.positionBuffers.next}}),this.positionBuffers.swap();var t=n.beginRenderPass({clearColor:[0,0,0,1]});this.model.setAttributes({position:this.positionBuffers.current}),this.model.draw(t),t.end()},n}(Je);zr.info="\nAnimation via transform feedback.\n";var jr={props:{},uniforms:{},name:"picking",uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:[0,0,0],highlightColor:[0,1,1,1]},vs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n",getUniforms:function(e,n){void 0===e&&(e={});var t={};if(void 0===e.highlightedObjectColor);else if(null===e.highlightedObjectColor)t.isHighlightActive=!1;else{t.isHighlightActive=!0;var r=e.highlightedObjectColor.slice(0,3);t.highlightedObjectColor=r}if(e.highlightColor){var i=Array.from(e.highlightColor,function(e){return e/255});Number.isFinite(i[3])||(i[3]=1),t.highlightColor=i}void 0!==e.isActive&&(t.isActive=Boolean(e.isActive),t.isAttribute=Boolean(e.isAttribute));void 0!==e.useFloatColors&&(t.useFloatColors=Boolean(e.useFloatColors));return t}};var Wr=_(),Yr=1e3,Qr=function(e){function n(n){var t,r=n.device;n.width,n.height,n.animationLoop;if(t=e.call(this)||this,"webgl"!==r.type)throw new Error("This demo is only implemented for WebGL2");for(var i=new Float32Array([.015,0,-.01,.01,-.01,-.01]),o=new Float32Array(2e3),a=new Float32Array(Yr),s=new Float32Array(3e3),l=new Float32Array(2e3),c=0;c<Yr;++c){o[2*c]=2*Wr()-1,o[2*c+1]=2*Wr()-1,a[c]=2*Wr()*Math.PI,Wr()>.5?(s[3*c+1]=1,s[3*c+2]=1):(s[3*c]=1,s[3*c+2]=1),l[2*c]=Math.floor(c/255),l[2*c+1]=c-255*l[2*c]}return t.positionBuffer=r.createBuffer({data:i}),t.instanceColorBuffer=r.createBuffer({data:s}),t.instancePositionBuffers=new ot({current:r.createBuffer({data:o}),next:r.createBuffer({data:o})}),t.instanceRotationBuffers=new ot({current:r.createBuffer({data:a}),next:r.createBuffer({data:a})}),t.instancePickingColorBuffer=r.createBuffer({data:l}),t.renderModel=new Ge(r,{id:"RenderModel",vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n#define POSITION_LOCATION 2\n#define COLOR_LOCATION 3\nprecision highp float;\nprecision highp int;\nlayout(location = POSITION_LOCATION) in vec2 positions;\nlayout(location = ROTATION_LOCATION) in float instanceRotations;\nlayout(location = OFFSET_LOCATION) in vec2 instancePositions;\nlayout(location = COLOR_LOCATION) in vec3 instanceColors;\nin vec2 instancePickingColors;\nout vec3 vColor;\nvoid main()\n{\n    vColor = instanceColors;\n\n    float cos_r = cos(instanceRotations);\n    float sin_r = sin(instanceRotations);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n    gl_Position = vec4(rot * positions + instancePositions, 0.0, 1.0);\n    picking_setPickingColor(vec3(0., instancePickingColors));\n}\n",fs:"#version 300 es\n#define ALPHA 0.9\nprecision highp float;\nprecision highp int;\nin vec3 vColor;\nout vec4 fragColor;\nvoid main()\n{\n    fragColor = vec4(vColor * ALPHA, ALPHA);\n    fragColor = picking_filterColor(fragColor);\n}\n",modules:[jr],topology:"triangle-list",vertexCount:3,isInstanced:!0,instanceCount:Yr,attributes:{positions:t.positionBuffer,instanceColors:t.instanceColorBuffer,instancePickingColors:t.instancePickingColorBuffer},bufferLayout:[{name:"positions",format:"float32x2"},{name:"instancePositions",format:"float32x2"},{name:"instanceRotations",format:"float32"},{name:"instanceColors",format:"float32x3"},{name:"instancePickingColors",format:"float32x2"}]}),t.transform=new kr(r,{vs:"#version 300 es\n#define OFFSET_LOCATION 0\n#define ROTATION_LOCATION 1\n\n#define M_2PI 6.28318530718\n\n#define MAP_HALF_LENGTH 1.01\n#define WANDER_CIRCLE_R 0.01\n#define WANDER_CIRCLE_OFFSET 0.04\n#define MOVE_DELTA 0.001\nprecision highp float;\nprecision highp int;\n\nuniform appUniforms{\n  float time;\n} app;\n\nlayout(location = OFFSET_LOCATION) in vec2 oldPositions;\nlayout(location = ROTATION_LOCATION) in float oldRotations;\n\nout vec2 newOffsets;\nout float newRotations;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    float theta = M_2PI * rand(vec2(app.time, oldRotations + oldPositions.x + oldPositions.y));\n    float cos_r = cos(oldRotations);\n    float sin_r = sin(oldRotations);\n    mat2 rot = mat2(\n        cos_r, sin_r,\n        -sin_r, cos_r\n    );\n\n    vec2 p = WANDER_CIRCLE_R * vec2(cos(theta), sin(theta)) + vec2(WANDER_CIRCLE_OFFSET, 0.0);\n    \n    vec2 move = normalize(rot * p);\n    newRotations = atan(move.y, move.x);\n    newOffsets = oldPositions + MOVE_DELTA * move;\n\n    // wrapping at edges\n    newOffsets = vec2 (\n        newOffsets.x > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( newOffsets.x < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : newOffsets.x ) ,\n        newOffsets.y > MAP_HALF_LENGTH ? - MAP_HALF_LENGTH :\n          ( newOffsets.y < - MAP_HALF_LENGTH ? MAP_HALF_LENGTH : newOffsets.y )\n        );\n\n    gl_Position = vec4(newOffsets, 0.0, 1.0);\n}\n",vertexCount:Yr,bufferLayout:[{name:"oldPositions",format:"float32x2"},{name:"oldRotations",format:"float32"}],outputs:["newOffsets","newRotations"]}),t}(0,s.A)(n,e);var t=n.prototype;return t.onFinalize=function(){this.renderModel.destroy(),this.transform.destroy()},t.onRender=function(e){var n=e.device,t=(e.width,e.height,e.time);this.transform.model.shaderInputs.setProps({app:{time:t}}),this.transform.run({inputBuffers:{oldPositions:this.instancePositionBuffers.current,oldRotations:this.instanceRotationBuffers.current},outputBuffers:{newOffsets:this.instancePositionBuffers.next,newRotations:this.instanceRotationBuffers.next}}),this.instancePositionBuffers.swap(),this.instanceRotationBuffers.swap(),this.renderModel.setAttributes({instancePositions:this.instancePositionBuffers.current,instanceRotations:this.instanceRotationBuffers.current});var r=n.beginRenderPass({clearColor:[0,0,0,1],clearDepth:1});this.renderModel.draw(r)},n}(Je);Qr.info='\n<p>\n  Instanced triangles animated on the GPU using a luma.gl <code>BufferTransform</code> object.\n\n  This is a port of an example from\n  <a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/transform_feedback_instanced.html">\n    WebGL2Samples\n  </a>\n';var Kr=t(4848),Zr={},qr=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"instancing",directory:"showcase",template:Dn,config:Zr},e))},Jr=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"persistence",directory:"showcase",template:it,config:Zr},e))},$r=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"postprocessing",directory:"showcase",template:Lt,config:Zr},e))},ei=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"animation",directory:"api",template:on,config:Zr},e))},ni=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"cubemap",directory:"api",template:un,config:Zr},e))},ti=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"texture-3d",directory:"api-3d",template:vn,config:Zr},e))},ri=function(){var e=(0,i.useRef)(null),n=(0,i.useState)(null),t=n[0],r=n[1];return(0,i.useEffect)(function(){var n=e.current;if(n){var t=null;return Cn({container:n}).then(function(e){t=e}).catch(function(e){r(e.message)}),function(){var e;null==(e=t)||e.destroy()}}},[]),(0,Kr.jsxs)("div",{style:{position:"relative",width:"100%",minHeight:"640px"},children:[(0,Kr.jsx)("div",{ref:e,style:{position:"absolute",inset:0}}),(0,Kr.jsxs)("div",{style:{position:"absolute",top:16,right:16,maxWidth:320,padding:12,background:"rgba(255, 255, 255, 0.92)",borderRadius:8,boxShadow:"0 2px 6px rgba(0, 0, 0, 0.25)"},children:[(0,Kr.jsx)("h3",{children:"External WebGL Context"}),(0,Kr.jsxs)("p",{style:{marginTop:0},children:["This example attaches a ",(0,Kr.jsx)("code",{children:"WebGLDevice"})," to the WebGL2 context created by MapLibre GL JS and renders a luma.gl overlay through the MapLibre render loop."]}),(0,Kr.jsx)("p",{style:{marginBottom:0},children:"The map uses CARTO basemaps that do not require an access token. The overlay uses the map view-projection matrix so it stays anchored in world space."}),t&&(0,Kr.jsxs)("p",{style:{color:"#b00020"},children:["Error: ",t]})]})]})},ii=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"hello-triangle",directory:"tutorials",template:Mt,config:Zr},e))},oi=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"hello-triangle-geometry",directory:"tutorials",template:Ft,config:Zr},e))},ai=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"hello-cube",directory:"tutorials",template:Ut,config:Zr},e))},si=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"instanced-cubes",directory:"tutorials",template:Bt,config:Zr},e))},li=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"two-cubes",directory:"tutorials",template:Dt,config:Zr},e))},ci=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"lighting",directory:"tutorials",template:Or,config:Zr},e))},ui=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"hello-gltf",directory:"tutorials",template:Nr,config:Zr},e))},fi=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"hello-instancing",directory:"tutorials",template:zt,config:Zr},e))},di=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"shader-hooks",directory:"tutorials",template:Gr,config:Zr},e))},pi=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"shader-modules",directory:"tutorials",template:Hr,config:Zr},e))},hi=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"transform-feedback",directory:"tutorials",template:zr,config:Zr},e))},mi=function(e){return(0,Kr.jsx)(o.fo,Object.assign({id:"transform",directory:"tutorials",template:Qr,config:Zr},e))}},4327:(e,n,t)=>{t.d(n,{Dt:()=>s,Qj:()=>a});var r=t(2444),i=t(467),o="";function a(e){o=e}function s(e,n){return l.apply(this,arguments)}function l(){return(l=(0,i.A)((0,r.A)().m(function e(n,t){var i,a;return(0,r.A)().w(function(e){for(;;)switch(e.n){case 0:return(i=new Image).crossOrigin=(null==t?void 0:t.crossOrigin)||"anonymous",i.src=n.startsWith("http")?n:o+n,e.n=1,i.decode();case 1:if(!t){e.n=3;break}return e.n=2,createImageBitmap(i,t);case 2:a=e.v,e.n=5;break;case 3:return e.n=4,createImageBitmap(i);case 4:a=e.v;case 5:return e.a(2,a)}},e)}))).apply(this,arguments)}},4353:(e,n,t)=>{t.d(n,{X:()=>a});var r=t(8696),i=t(7387),o=t(7862),a=function(e){function n(t,r){return e.call(this,t,r,n.defaultProps)||this}return(0,i.A)(n,e),(0,r.A)(n,[{key:Symbol.toStringTag,get:function(){return"TextureView"}}])}(o.F);a.defaultProps=Object.assign({},o.F.defaultProps,{format:void 0,dimension:void 0,aspect:"all",baseMipLevel:0,mipLevelCount:void 0,baseArrayLayer:0,arrayLayerCount:void 0})},4569:(e,n,t)=>{t.d(n,{Y:()=>o});var r=t(8696),i=t(6769),o=function(){return(0,r.A)(function(){},[{key:"pageLoaded",get:function(){return function(){l||(l=s()||"undefined"==typeof window?Promise.resolve():new Promise(function(e){return window.addEventListener("load",function(){return e()})}));return l}()}}])}(),a=(0,i.B)()&&"undefined"!=typeof document,s=function(){return a&&"complete"===document.readyState},l=null},5056:(e,n,t)=>{t.d(n,{h:()=>a});var r=t(8696),i=t(7387),o=t(7862),a=function(e){function n(t,r){var i,o=Object.assign({},r);return(r.usage||0)&n.INDEX&&!r.indexType&&(r.data instanceof Uint32Array?o.indexType="uint32":r.data instanceof Uint16Array&&(o.indexType="uint16")),delete o.data,(i=e.call(this,t,o,n.defaultProps)||this).debugData=new ArrayBuffer(0),i.usage=o.usage||0,i.indexType=o.indexType,i.updateTimestamp=t.incrementTimestamp(),i}(0,i.A)(n,e);var t=n.prototype;return t.clone=function(e){return this.device.createBuffer(Object.assign({},this.props,e))},t._setDebugData=function(e,t,r){var i=ArrayBuffer.isView(e)?e.buffer:e,o=Math.min(e?e.byteLength:r,n.DEBUG_DATA_MAX_LENGTH);null===i?this.debugData=new ArrayBuffer(o):0===t&&r===i.byteLength?this.debugData=i.slice(0,o):this.debugData=i.slice(t,t+o)},(0,r.A)(n,[{key:Symbol.toStringTag,get:function(){return"Buffer"}}])}(o.F);a.INDEX=16,a.VERTEX=32,a.UNIFORM=64,a.STORAGE=128,a.INDIRECT=256,a.QUERY_RESOLVE=512,a.MAP_READ=1,a.MAP_WRITE=2,a.COPY_SRC=4,a.COPY_DST=8,a.DEBUG_DATA_MAX_LENGTH=32,a.defaultProps=Object.assign({},o.F.defaultProps,{usage:0,byteLength:0,byteOffset:0,data:null,indexType:"uint16",onMapped:void 0})},5768:(e,n,t)=>{t.d(n,{L:()=>a});var r=t(8696),i=t(7387),o=t(7862),a=function(e){function n(t,r){return r=n.normalizeProps(t,r),e.call(this,t,r,n.defaultProps)||this}return(0,i.A)(n,e),n.normalizeProps=function(e,n){return n},(0,r.A)(n,[{key:Symbol.toStringTag,get:function(){return"Sampler"}}])}(o.F);a.defaultProps=Object.assign({},o.F.defaultProps,{type:"color-sampler",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge",magFilter:"nearest",minFilter:"nearest",mipmapFilter:"none",lodMinClamp:0,lodMaxClamp:32,compare:"less-equal",maxAnisotropy:1})},7083:(e,n,t)=>{t.d(n,{g:()=>f});var r,i=t(8696),o=t(7387),a=t(7862),s=t(5768),l=t(3522),c=t(116),u={"1d":"1d","2d":"2d","2d-array":"2d",cube:"2d","cube-array":"2d","3d":"3d"},f=function(e){function n(t,r,i){var o;if(r=n.normalizeProps(t,r),(o=e.call(this,t,r,n.defaultProps)||this).ready=Promise.resolve(o),o.isReady=!0,o.dimension=o.props.dimension,o.baseDimension=u[o.dimension],o.format=o.props.format,o.width=o.props.width,o.height=o.props.height,o.depth=o.props.depth,o.mipLevels=o.props.mipLevels,"cube"===o.dimension&&(o.depth=6),void 0===o.props.width||void 0===o.props.height)if(t.isExternalImage(r.data)){var a=t.getExternalImageSize(r.data);o.width=(null==a?void 0:a.width)||1,o.height=(null==a?void 0:a.height)||1}else o.width=1,o.height=1,void 0!==o.props.width&&void 0!==o.props.height||l.R.warn(o+" created with undefined width or height. This is deprecated. Use DynamicTexture instead.")();return o.byteAlignment=(null==i?void 0:i.byteAlignment)||1,o.updateTimestamp=t.incrementTimestamp(),o}(0,o.A)(n,e);var t=n.prototype;return t.toString=function(){return"Texture("+this.id+","+this.format+","+this.width+"x"+this.height+")"},t.clone=function(e){return this.device.createTexture(Object.assign({},this.props,e))},t.setSampler=function(e){this.sampler=e instanceof s.L?e:this.device.createSampler(e)},t.computeMemoryLayout=function(e){void 0===e&&(e={});var n=this._normalizeTextureReadOptions(e),t=n.width,r=void 0===t?this.width:t,i=n.height,o=void 0===i?this.height:i,a=n.depthOrArrayLayers,s=void 0===a?this.depth:a,l=this.format,u=this.byteAlignment;return c.vz.computeMemoryLayout({format:l,width:r,height:o,depth:s,byteAlignment:u})},t.readBuffer=function(e,n){throw new Error("readBuffer not implemented")},t.readDataAsync=function(e){throw new Error("readBuffer not implemented")},t.writeBuffer=function(e,n){throw new Error("readBuffer not implemented")},t.writeData=function(e,n){throw new Error("readBuffer not implemented")},t.readDataSyncWebGL=function(e){throw new Error("readDataSyncWebGL not available")},t.generateMipmapsWebGL=function(){throw new Error("generateMipmapsWebGL not available")},n.normalizeProps=function(e,n){var t=Object.assign({},n),r=t.width,i=t.height;return"number"==typeof r&&(t.width=Math.max(1,Math.ceil(r))),"number"==typeof i&&(t.height=Math.max(1,Math.ceil(i))),t},t._initializeData=function(e){this.device.isExternalImage(e)?this.copyExternalImage({image:e,width:this.width,height:this.height,depth:this.depth,mipLevel:0,x:0,y:0,z:0,aspect:"all",colorSpace:"srgb",premultipliedAlpha:!1,flipY:!1}):e&&this.copyImageData({data:e,mipLevel:0,x:0,y:0,z:0,aspect:"all"})},t._normalizeCopyImageDataOptions=function(e){var t=this.width,r=this.height,i=this.depth,o=Object.assign({},n.defaultCopyDataOptions,{width:t,height:r,depth:i},e),a=this.device.getTextureFormatInfo(this.format);if(!e.bytesPerRow&&!a.bytesPerPixel)throw new Error("bytesPerRow must be provided for texture format "+this.format);return o.bytesPerRow=e.bytesPerRow||t*(a.bytesPerPixel||4),o.rowsPerImage=e.rowsPerImage||r,o},t._normalizeCopyExternalImageOptions=function(e){var t=this.device.getExternalImageSize(e.image),r=Object.assign({},n.defaultCopyExternalImageOptions,t,e);return r.width=Math.min(r.width,this.width-r.x),r.height=Math.min(r.height,this.height-r.y),r},t._normalizeTextureReadOptions=function(e){var t=this.width,r=this.height,i=Object.assign({},n.defaultTextureReadOptions,{width:t,height:r},e);return i.width=Math.min(i.width,this.width-i.x),i.height=Math.min(i.height,this.height-i.y),i},t._normalizeTextureWriteOptions=function(e){var t=this.width,r=this.height,i=Object.assign({},n.defaultTextureReadOptions,{width:t,height:r},e);return i.width=Math.min(i.width,this.width-i.x),i.height=Math.min(i.height,this.height-i.y),i},(0,i.A)(n,[{key:Symbol.toStringTag,get:function(){return"Texture"}}])}(a.F);r=f,f.SAMPLE=4,f.STORAGE=8,f.RENDER=16,f.COPY_SRC=1,f.COPY_DST=2,f.TEXTURE=4,f.RENDER_ATTACHMENT=16,f.defaultProps=Object.assign({},a.F.defaultProps,{data:null,dimension:"2d",format:"rgba8unorm",usage:r.SAMPLE|r.RENDER|r.COPY_DST,width:void 0,height:void 0,depth:1,mipLevels:1,samples:void 0,sampler:{},view:void 0}),f.defaultCopyDataOptions={data:void 0,byteOffset:0,bytesPerRow:void 0,rowsPerImage:void 0,mipLevel:0,x:0,y:0,z:0,aspect:"all"},f.defaultCopyExternalImageOptions={image:void 0,sourceX:0,sourceY:0,width:void 0,height:void 0,depth:1,mipLevel:0,x:0,y:0,z:0,aspect:"all",colorSpace:"srgb",premultipliedAlpha:!1,flipY:!1},f.defaultTextureReadOptions={x:0,y:0,z:0,width:void 0,height:void 0,depthOrArrayLayers:1,mipLevel:0,aspect:"all"}},7221:(e,n,t)=>{t.d(n,{l:()=>A});var r=t(3845),i=t(2444),o=t(467),a=t(7387),s=t(8174),l=t(3522),c=t(4569),u=t(3369),f={WEBGL_depth_texture:{UNSIGNED_INT_24_8_WEBGL:u.GL.UNSIGNED_INT_24_8},OES_element_index_uint:{},OES_texture_float:{},OES_texture_half_float:{HALF_FLOAT_OES:u.GL.HALF_FLOAT},EXT_color_buffer_float:{},OES_standard_derivatives:{FRAGMENT_SHADER_DERIVATIVE_HINT_OES:u.GL.FRAGMENT_SHADER_DERIVATIVE_HINT},EXT_frag_depth:{},EXT_blend_minmax:{MIN_EXT:u.GL.MIN,MAX_EXT:u.GL.MAX},EXT_shader_texture_lod:{}},d=function(e){return{drawBuffersWEBGL:function(n){return e.drawBuffers(n)},COLOR_ATTACHMENT0_WEBGL:u.GL.COLOR_ATTACHMENT0,COLOR_ATTACHMENT1_WEBGL:u.GL.COLOR_ATTACHMENT1,COLOR_ATTACHMENT2_WEBGL:u.GL.COLOR_ATTACHMENT2,COLOR_ATTACHMENT3_WEBGL:u.GL.COLOR_ATTACHMENT3}},p=function(e){return{VERTEX_ARRAY_BINDING_OES:u.GL.VERTEX_ARRAY_BINDING,createVertexArrayOES:function(){return e.createVertexArray()},deleteVertexArrayOES:function(n){return e.deleteVertexArray(n)},isVertexArrayOES:function(n){return e.isVertexArray(n)},bindVertexArrayOES:function(n){return e.bindVertexArray(n)}}},h=function(e){return{VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:35070,drawArraysInstancedANGLE:function(){return e.drawArraysInstanced.apply(e,arguments)},drawElementsInstancedANGLE:function(){return e.drawElementsInstanced.apply(e,arguments)},vertexAttribDivisorANGLE:function(){return e.vertexAttribDivisor.apply(e,arguments)}}};function m(e){void 0===e&&(e=!0);var n=HTMLCanvasElement.prototype;if(!e&&n.originalGetContext)return n.getContext=n.originalGetContext,void(n.originalGetContext=void 0);n.originalGetContext=n.getContext,n.getContext=function(e,n){if("webgl"===e||"experimental-webgl"===e){var t=this.originalGetContext("webgl2",n);return t instanceof HTMLElement&&function(e){e.getExtension("EXT_color_buffer_float");var n=Object.assign({},f,{WEBGL_disjoint_timer_query:e.getExtension("EXT_disjoint_timer_query_webgl2"),WEBGL_draw_buffers:d(e),OES_vertex_array_object:p(e),ANGLE_instanced_arrays:h(e)}),t=e.getExtension;e.getExtension=function(r){var i=t.call(e,r);return i||(r in n?n[r]:null)};var r=e.getSupportedExtensions;e.getSupportedExtensions=function(){var t=r.apply(e)||[];return null==t?void 0:t.concat(Object.keys(n))}}(t),t}return this.originalGetContext(e,n)}}var g=t(7528),_=t(3492);function v(e){return"undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||Boolean(e&&Number.isFinite(e._version))}var A=new(function(e){function n(){var n;return(n=e.call(this)||this).type="webgl",s.pF.defaultProps=Object.assign({},s.pF.defaultProps,g.ic),n}(0,a.A)(n,e);var c=n.prototype;return c.enforceWebGL2=function(e){m(e)},c.isSupported=function(){return"undefined"!=typeof WebGL2RenderingContext},c.isDeviceHandle=function(e){return"undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||("undefined"!=typeof WebGLRenderingContext&&e instanceof WebGLRenderingContext&&l.R.warn("WebGL1 is not supported",e)(),!1)},c.attach=function(){var e=(0,o.A)((0,i.A)().m(function e(n,r){var o,a,s;return(0,i.A)().w(function(e){for(;;)switch(e.n){case 0:return void 0===r&&(r={}),e.n=1,t.e(3449).then(t.bind(t,3449));case 1:if(o=e.v,a=o.WebGLDevice,!(n instanceof a)){e.n=2;break}return e.a(2,n);case 2:if(!((null==n?void 0:n.device)instanceof a)){e.n=3;break}return e.a(2,n.device);case 3:if(v(n)){e.n=4;break}throw new Error("Invalid WebGL2RenderingContext");case 4:return s=!0===r.createCanvasContext?{}:r.createCanvasContext,e.a(2,new a(Object.assign({},r,{_handle:n,createCanvasContext:Object.assign({canvas:n.canvas,autoResize:!1},s)})))}},e)}));return function(n,t){return e.apply(this,arguments)}}(),c.create=function(){var e=(0,o.A)((0,i.A)().m(function e(n){var o,a,s,c,u,f,d,p,h;return(0,i.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:return void 0===n&&(n={}),e.n=1,t.e(5830).then(t.bind(t,3449));case 1:return o=e.v,a=o.WebGLDevice,s=[],(n.debugWebGL||n.debug)&&s.push((0,_.$)()),n.debugSpectorJS&&s.push((0,g._G)(n)),e.n=2,Promise.allSettled(s);case 2:for(c=e.v,u=(0,r.A)(c);!(f=u()).done;)"rejected"===(d=f.value).status&&l.R.error("Failed to initialize debug libraries "+d.reason)();return e.p=3,p=new a(n),l.R.groupCollapsed(1,"WebGLDevice "+p.id+" created")(),h=(p._reused?"Reusing":"Created")+" device with WebGL2 "+(p.props.debug?"debug ":"")+"context: "+p.info.vendor+", "+p.info.renderer+" for canvas: "+p.canvasContext.id,l.R.probe(1,h)(),l.R.table(1,p.info)(),e.a(2,p);case 4:return e.p=4,l.R.groupEnd(1)(),l.R.info(1,"%cWebGL call tracing: luma.log.set('debug-webgl') ","color: white; background: blue; padding: 2px 6px; border-radius: 3px;")(),e.f(4);case 5:return e.a(2)}},e,null,[[3,,4,5]])}));return function(n){return e.apply(this,arguments)}}(),n}(c.Y))},7468:(e,n,t)=>{t.d(n,{M:()=>d});var r=t(2444),i=t(467),o=t(8696),a=t(7387),s=t(7862),l=t(1166),c=t(3845);function u(e,n,t,r){if(null!=r&&r.inlineSource){var i=function(e,n,t){for(var r="",i=n-2;i<=n;i++){var o=e[i-1];void 0!==o&&(r+=f(o,n,t))}return r}(n,t);return"\n"+i+(e.linePos>0?" ".repeat(e.linePos+5)+"^^^\n":"")+e.type.toUpperCase()+": "+e.message+"\n\n"}var o="error"===e.type?"red":"#8B4000";return null!=r&&r.html?"<div class='luma-compiler-log-error' style=\"color:"+o+';"><b> '+e.type.toUpperCase()+": "+e.message+"</b></div>":e.type.toUpperCase()+": "+e.message}function f(e,n,t){var r=null!=t&&t.html?e.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;"):e;return function(e,n){for(var t="",r=e.length;r<n;++r)t+=" ";return t+e}(String(n),4)+": "+r+(null!=t&&t.html?"<br/>":"\n")}var d=function(e){function n(t,r){var i;return r=Object.assign({},r,{debugShaders:r.debugShaders||t.props.debugShaders||"errors"}),(i=e.call(this,t,Object.assign({id:p(r)},r),n.defaultProps)||this).compilationStatus="pending",i.stage=i.props.stage,i.source=i.props.source,i}(0,a.A)(n,e);var t=n.prototype;return t.getCompilationInfoSync=function(){return null},t.getTranslatedSource=function(){return null},t.debugShader=function(){var e=(0,i.A)((0,r.A)().m(function e(){var n,t,i;return(0,r.A)().w(function(e){for(;;)switch(e.n){case 0:n=this.props.debugShaders,i=n,e.n="never"===i?1:"errors"===i?2:"warnings"===i||"always"===i?4:5;break;case 1:return e.a(2);case 2:if("success"!==this.compilationStatus){e.n=3;break}return e.a(2);case 3:case 4:return e.a(3,5);case 5:return e.n=6,this.getCompilationInfo();case 6:if(t=e.v,"warnings"!==n||0!==(null==t?void 0:t.length)){e.n=7;break}return e.a(2);case 7:this._displayShaderLog(t,this.id);case 8:return e.a(2)}},e,this)}));return function(){return e.apply(this,arguments)}}(),t._displayShaderLog=function(e,n){var t,r,i=this;if("undefined"!=typeof document&&null!=(t=document)&&t.createElement){var o=n,a=this.stage+' shader "'+o+'"',s=function(e,n,t){var r="",i=n.split(/\r?\n/),o=e.slice().sort(function(e,n){return e.lineNum-n.lineNum});switch((null==t?void 0:t.showSourceCode)||"no"){case"all":for(var a=0,s=1;s<=i.length;s++)for(r+=f(i[s-1],s,t);o.length>a&&o[a].lineNum===s;){var l=o[a++];r+=u(l,i,l.lineNum,Object.assign({},t,{inlineSource:!1}))}for(;o.length>a;)r+=u(o[a++],[],0,Object.assign({},t,{inlineSource:!1}));return r;case"issues":case"no":for(var d,p=(0,c.A)(e);!(d=p()).done;){var h=d.value;r+=u(h,i,h.lineNum,{inlineSource:"no"!==(null==t?void 0:t.showSourceCode)})}return r}}(e,this.source,{showSourceCode:"all",html:!0}),l=this.getTranslatedSource();l&&(s+='<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>'+l+"</pre></code>");var d=document.createElement("Button");d.innerHTML="\n<h1>Compilation error in "+a+'</h1><br /><br />\n<code style="user-select:text;"><pre>\n'+s+"\n</pre></code>",d.style.top="10px",d.style.left="10px",d.style.position="absolute",d.style.zIndex="9999",d.style.width="100%",d.style.textAlign="left",document.body.appendChild(d),null==(r=document.getElementsByClassName("luma-compiler-log-error")[0])||r.scrollIntoView(),d.onclick=function(){var e="data:text/plain,"+encodeURIComponent(i.source);navigator.clipboard.writeText(e)}}},(0,o.A)(n,[{key:Symbol.toStringTag,get:function(){return"Shader"}}])}(s.F);function p(e){return function(e,n){void 0===n&&(n="unnamed");var t=/#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(e);return t?t[1]:n}(e.source)||e.id||(0,l.L)("unnamed "+e.stage+"-shader")}d.defaultProps=Object.assign({},s.F.defaultProps,{language:"auto",stage:void 0,source:"",sourceMap:null,entryPoint:"main",debugShaders:void 0})},7528:(e,n,t)=>{t.d(n,{_G:()=>f,ic:()=>u,k2:()=>p});var r=t(2444),i=t(467),o=t(3522),a=t(8942),s=1,l=null,c=!1,u={debugSpectorJS:o.R.get("debug-spectorjs"),debugSpectorJSUrl:"https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",gl:void 0};function f(e){return d.apply(this,arguments)}function d(){return(d=(0,i.A)((0,r.A)().m(function e(n){var t;return(0,r.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:if(globalThis.SPECTOR){e.n=4;break}return e.p=1,e.n=2,(0,a.k)(n.debugSpectorJSUrl||u.debugSpectorJSUrl);case 2:e.n=4;break;case 3:e.p=3,t=e.v,o.R.warn(String(t));case 4:return e.a(2)}},e,null,[[1,3]])}))).apply(this,arguments)}function p(e){var n,t,r;if(!(e=Object.assign({},u,e)).debugSpectorJS)return null;if(!l&&globalThis.SPECTOR&&(null==(n=globalThis.luma)||!n.spector)){o.R.probe(s,"SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();var i=globalThis.SPECTOR.Spector;l=new i,globalThis.luma&&(globalThis.luma.spector=l)}if(!l)return null;c||(c=!0,l.spyCanvases(),null==(t=l)||t.onCaptureStarted.add(function(e){return o.R.info("Spector capture started:",e)()}),null==(r=l)||r.onCapture.add(function(e){var n,t,r;o.R.info("Spector capture complete:",e)(),null==(n=l)||n.getResultUI(),null==(t=l)||t.resultView.display(),null==(r=l)||r.resultView.addCapture(e)}));if(e.gl){var a,f=e.gl,d=f.device;null==(a=l)||a.startCapture(e.gl,500),f.device=d,new Promise(function(e){return setTimeout(e,2e3)}).then(function(e){var n;o.R.info("Spector capture stopped after 2 seconds")(),null==(n=l)||n.stopCapture()})}return l}},7862:(e,n,t)=>{t.d(n,{F:()=>i});var r=t(1166),i=function(){function e(e,n,t){if(this.userData={},this.destroyed=!1,this.allocatedBytes=0,this._attachedResources=new Set,!e)throw new Error("no device");this._device=e,this.props=function(e,n){var t=Object.assign({},n);for(var r in e)void 0!==e[r]&&(t[r]=e[r]);return t}(n,t);var i="undefined"!==this.props.id?this.props.id:(0,r.L)(this[Symbol.toStringTag]);this.props.id=i,this.id=i,this.userData=this.props.userData||{},this.addStats()}var n=e.prototype;return n.toString=function(){return(this[Symbol.toStringTag]||this.constructor.name)+':"'+this.id+'"'},n.destroy=function(){this.destroyResource()},n.delete=function(){return this.destroy(),this},n.getProps=function(){return this.props},n.attachResource=function(e){this._attachedResources.add(e)},n.detachResource=function(e){this._attachedResources.delete(e)},n.destroyAttachedResource=function(e){this._attachedResources.delete(e)&&e.destroy()},n.destroyAttachedResources=function(){for(var e=0,n=Object.values(this._attachedResources);e<n.length;e++){n[e].destroy()}this._attachedResources=new Set},n.destroyResource=function(){this.destroyAttachedResources(),this.removeStats(),this.destroyed=!0},n.removeStats=function(){var e=this._device.statsManager.getStats("Resource Counts"),n=this[Symbol.toStringTag];e.get(n+"s Active").decrementCount()},n.trackAllocatedMemory=function(e,n){void 0===n&&(n=this[Symbol.toStringTag]);var t=this._device.statsManager.getStats("Resource Counts");t.get("GPU Memory").addCount(e),t.get(n+" Memory").addCount(e),this.allocatedBytes=e},n.trackDeallocatedMemory=function(e){void 0===e&&(e=this[Symbol.toStringTag]);var n=this._device.statsManager.getStats("Resource Counts");n.get("GPU Memory").subtractCount(this.allocatedBytes),n.get(e+" Memory").subtractCount(this.allocatedBytes),this.allocatedBytes=0},n.addStats=function(){var e=this._device.statsManager.getStats("Resource Counts"),n=this[Symbol.toStringTag];e.get("Resources Created").incrementCount(),e.get(n+"s Created").incrementCount(),e.get(n+"s Active").incrementCount()},e}();i.defaultProps={id:"undefined",handle:void 0,userData:void 0}},8174:(e,n,t)=>{t.d(n,{I7:()=>h,PI:()=>p,pF:()=>m});var r=t(8696),i=t(9321),o=t(2444),a=t(9489),s=t(3522),l=t(1166),c=t(5056),u=t(1990),f=t(116),d=t(9141),p=function(){},h=function(){function e(e,n){void 0===e&&(e=[]),this.features=new Set(e),this.disabledFeatures=n||{}}var n=e.prototype;return n[Symbol.iterator]=(0,o.A)().m(function e(){return(0,o.A)().w(function(e){for(;;)switch(e.n){case 0:return e.d((0,i.A)(this.features),1);case 1:return e.a(2)}},e,this)}),n.has=function(e){var n;return!(null!=(n=this.disabledFeatures)&&n[e])&&this.features.has(e)},e}(),m=function(){function e(n){this.userData={},this.statsManager=a.d,this.timestamp=0,this._reused=!1,this._lumaData={},this._textureCaps={},this.props=Object.assign({},e.defaultProps,n),this.id=this.props.id||(0,l.L)(this[Symbol.toStringTag].toLowerCase())}var n=e.prototype;return n.toString=function(){return"Device("+this.id+")"},n.getVertexFormatInfo=function(e){return(0,u.yx)(e)},n.isVertexFormatSupported=function(e){return!0},n.getTextureFormatInfo=function(e){return f.vz.getInfo(e)},n.getTextureFormatCapabilities=function(e){var n=this._textureCaps[e];if(!n){var t=this._getDeviceTextureFormatCapabilities(e);n=this._getDeviceSpecificTextureFormatCapabilities(t),this._textureCaps[e]=n}return n},n.getMipLevelCount=function(e,n,t){void 0===t&&(t=1);var r=Math.max(e,n,t);return 1+Math.floor(Math.log2(r))},n.isExternalImage=function(e){return(0,d.x)(e)},n.getExternalImageSize=function(e){return(0,d.c)(e)},n.isTextureFormatSupported=function(e){return this.getTextureFormatCapabilities(e).create},n.isTextureFormatFilterable=function(e){return this.getTextureFormatCapabilities(e).filter},n.isTextureFormatRenderable=function(e){return this.getTextureFormatCapabilities(e).render},n.isTextureFormatCompressed=function(e){return f.vz.isCompressed(e)},n.pushDebugGroup=function(e){this.commandEncoder.pushDebugGroup(e)},n.popDebugGroup=function(){var e;null==(e=this.commandEncoder)||e.popDebugGroup()},n.insertDebugMarker=function(e){var n;null==(n=this.commandEncoder)||n.insertDebugMarker(e)},n.loseDevice=function(){return!1},n.incrementTimestamp=function(){return this.timestamp++},n.reportError=function(e,n){if(!this.props.onError(e,n)){for(var t=arguments.length,r=new Array(t>2?t-2:0),i=2;i<t;i++)r[i-2]=arguments[i];return s.R.error.apply(s.R,["webgl"===this.type?"%cWebGL":"%cWebGPU","color: white; background: red; padding: 2px 6px; border-radius: 3px;",e.message,n].concat(r))}return function(){}},n.debug=function(){if(this.props.debug);else{s.R.once(0,"'Type luma.log.set({debug: true}) in console to enable debug breakpoints',\nor create a device with the 'debug: true' prop.")()}},n.getDefaultCanvasContext=function(){if(!this.canvasContext)throw new Error("Device has no default CanvasContext. See props.createCanvasContext");return this.canvasContext},n.createFence=function(){throw new Error("createFence() not implemented")},n.beginRenderPass=function(e){return this.commandEncoder.beginRenderPass(e)},n.beginComputePass=function(e){return this.commandEncoder.beginComputePass(e)},n.getCanvasContext=function(){return this.getDefaultCanvasContext()},n.readPixelsToArrayWebGL=function(e,n){throw new Error("not implemented")},n.readPixelsToBufferWebGL=function(e,n){throw new Error("not implemented")},n.setParametersWebGL=function(e){throw new Error("not implemented")},n.getParametersWebGL=function(e){throw new Error("not implemented")},n.withParametersWebGL=function(e,n){throw new Error("not implemented")},n.clearWebGL=function(e){throw new Error("not implemented")},n.resetWebGL=function(){throw new Error("not implemented")},e._getCanvasContextProps=function(e){return!0===e.createCanvasContext?{}:e.createCanvasContext},n._getDeviceTextureFormatCapabilities=function(e){var n=this,t=f.vz.getCapabilities(e),r=function(e){var t;return null==(t="string"==typeof e?n.features.has(e):e)||t},i=r(t.create);return{format:e,create:i,render:i&&r(t.render),filter:i&&r(t.filter),blend:i&&r(t.blend),store:i&&r(t.store)}},n._normalizeBufferProps=function(e){(e instanceof ArrayBuffer||ArrayBuffer.isView(e))&&(e={data:e});var n=Object.assign({},e);if((e.usage||0)&c.h.INDEX&&(e.indexType||(e.data instanceof Uint32Array?n.indexType="uint32":e.data instanceof Uint16Array&&(n.indexType="uint16")),!n.indexType))throw new Error("indices buffer content must be of type uint16 or uint32");return n},(0,r.A)(e,[{key:Symbol.toStringTag,get:function(){return"Device"}}])}();m.defaultProps={id:null,powerPreference:"high-performance",failIfMajorPerformanceCaveat:!1,createCanvasContext:void 0,webgl:{},onError:function(e,n){},onResize:function(e,n){var t=e.getDevicePixelSize(),r=t[0],i=t[1];s.R.log(1,e+" resized => "+r+"x"+i+"px")()},onPositionChange:function(e,n){var t=e.getPosition(),r=t[0],i=t[1];s.R.log(1,e+" repositioned => "+r+","+i)()},onVisibilityChange:function(e){return s.R.log(1,e+" Visibility changed "+e.isVisible)()},onDevicePixelRatioChange:function(e,n){return s.R.log(1,e+" DPR changed "+n.oldRatio+" => "+e.devicePixelRatio)()},debug:s.R.get("debug")||void 0,debugShaders:s.R.get("debug-shaders")||void 0,debugFramebuffers:Boolean(s.R.get("debug-framebuffers")),debugFactories:Boolean(s.R.get("debug-factories")),debugWebGL:Boolean(s.R.get("debug-webgl")),debugSpectorJS:void 0,debugSpectorJSUrl:void 0,_reuseDevices:!1,_requestMaxLimits:!0,_cacheShaders:!1,_cachePipelines:!1,_cacheDestroyPolicy:"unused",_initializeFeatures:!0,_disabledFeatures:{"compilation-status-async-webgl":!0},_handle:void 0}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}},8482:(e,n,t)=>{t.d(n,{xN:()=>X,Xj:()=>Q,dJ:()=>q,yL:()=>Z,R2:()=>W,I$:()=>Y,fo:()=>se,dw:()=>J,ql:()=>K});var r=t(6540),i=t(8587),o=t(7387),a=t(5556),s=t.n(a),l=t(4848),c=["height","width","viewBox","style","children","predefinedClassName","className","colors","totalColor"],u=function(e){function n(){return e.apply(this,arguments)||this}return(0,o.A)(n,e),n.prototype.render=function(){var e=this.props,n=e.height,t=e.width,r=e.viewBox,o=e.style,a=void 0===o?{}:o,s=e.children,u=e.predefinedClassName,f=e.className,d=e.colors,p=e.totalColor,h=(0,i.A)(e,c),m=n,g=t||m;a.fill="currentColor";var _=Array.isArray(d)&&p&&function(e,n){return new Array(e).fill(1).reduce(function(e,t,r){return e+".cr"+(r+1)+" {fill:"+n[r%n.length]+";}"},"")}(p,d);return(0,l.jsxs)("svg",Object.assign({viewBox:r,width:g,height:m,style:a,className:u+" "+f},h,{children:[_?(0,l.jsx)("style",{type:"text/css",children:_}):null,s]}))},n}(r.Component);u.displayName="Base Icon",u.propTypes={height:s().string,width:s().string,viewBox:s().string,children:s().node,predefinedClassName:s().string,className:s().string},u.defaultProps={height:null,width:null,viewBox:"0 0 64 64",predefinedClassName:"",className:""};var f=function(e){return(0,l.jsx)(u,Object.assign({},e,{children:(0,l.jsx)("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M5.02167 13.7625C4.69623 13.4459 4.69623 12.9325 5.02167 12.6159L9.76574 8.00002L5.02167 3.38416C4.69623 3.06752 4.69623 2.55415 5.02167 2.2375C5.3471 1.92086 5.87474 1.92086 6.20018 2.2375L11.5335 7.42669C11.6898 7.57875 11.7776 7.78498 11.7776 8.00002C11.7776 8.21506 11.6898 8.4213 11.5335 8.57335L6.20018 13.7625C5.87474 14.0792 5.3471 14.0792 5.02167 13.7625Z"})}))};f.propTypes={height:s().string},f.defaultProps={height:"16px",viewBox:"0 0 17 16",predefinedClassName:"unfolded-icons-arrowbigright"};var d=t(2444),p=t(467),h=t(4745),m=t(3845),g=t(8174),_=t(9489),v=t(3522),A="No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.",E=function(){function e(){if(this.stats=_.d,this.log=v.R,this.VERSION="undefined"!=typeof __VERSION__?__VERSION__:"running from source",this.preregisteredAdapters=new Map,globalThis.luma){if(globalThis.luma.VERSION!==this.VERSION)throw v.R.error("Found luma.gl "+globalThis.luma.VERSION+" while initialzing "+this.VERSION)(),v.R.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(),new Error("luma.gl - multiple versions detected: see console log");v.R.error("This version of luma.gl has already been initialized")()}v.R.log(1,this.VERSION+" - set luma.log.level=1 (or higher) to trace rendering")(),globalThis.luma=this}var n=e.prototype;return n.createDevice=function(){var n=(0,p.A)((0,d.A)().m(function n(t){var r,i;return(0,d.A)().w(function(n){for(;;)switch(n.n){case 0:if(void 0===t&&(t={}),r=Object.assign({},e.defaultProps,t),i=this.selectAdapter(r.type,r.adapters)){n.n=1;break}throw new Error(A);case 1:if(!r.waitForPageLoad){n.n=2;break}return n.n=2,i.pageLoaded;case 2:return n.n=3,i.create(r);case 3:return n.a(2,n.v)}},n,this)}));return function(e){return n.apply(this,arguments)}}(),n.attachDevice=function(){var e=(0,p.A)((0,d.A)().m(function e(n,t){var r,i;return(0,d.A)().w(function(e){for(;;)switch(e.n){case 0:if(r=this._getTypeFromHandle(n,t.adapters),i=r&&this.selectAdapter(r,t.adapters)){e.n=1;break}throw new Error(A);case 1:return e.n=2,null==i||null==i.attach?void 0:i.attach(n,t);case 2:return e.a(2,e.v)}},e,this)}));return function(n,t){return e.apply(this,arguments)}}(),n.registerAdapters=function(e){for(var n,t=(0,m.A)(e);!(n=t()).done;){var r=n.value;this.preregisteredAdapters.set(r.type,r)}},n.getSupportedAdapters=function(e){void 0===e&&(e=[]);var n=this._getAdapterMap(e);return Array.from(n).map(function(e){return e[1]}).filter(function(e){return null==e.isSupported?void 0:e.isSupported()}).map(function(e){return e.type})},n.getBestAvailableAdapterType=function(e){void 0===e&&(e=[]);for(var n=this._getAdapterMap(e),t=0,r=["webgpu","webgl","null"];t<r.length;t++){var i,o=r[t];if(null!=(i=n.get(o))&&null!=i.isSupported&&i.isSupported())return o}return null},n.selectAdapter=function(e,n){void 0===n&&(n=[]);var t=e;"best-available"===e&&(t=this.getBestAvailableAdapterType(n));var r=this._getAdapterMap(n);return t&&r.get(t)||null},n.enforceWebGL2=function(e,n){void 0===e&&(e=!0),void 0===n&&(n=[]);var t=this._getAdapterMap(n).get("webgl");t||v.R.warn("enforceWebGL2: webgl adapter not found")(),null==t||null==t.enforceWebGL2||t.enforceWebGL2(e)},n.setDefaultDeviceProps=function(n){Object.assign(e.defaultProps,n)},n._getAdapterMap=function(e){void 0===e&&(e=[]);for(var n,t=new Map(this.preregisteredAdapters),r=(0,m.A)(e);!(n=r()).done;){var i=n.value;t.set(i.type,i)}return t},n._getTypeFromHandle=function(e,n){return void 0===n&&(n=[]),e instanceof WebGL2RenderingContext?"webgl":"undefined"!=typeof GPUDevice&&e instanceof GPUDevice||null!=e&&e.queue?"webgpu":null===e?"null":(e instanceof WebGLRenderingContext?v.R.warn("WebGL1 is not supported",e)():v.R.warn("Unknown handle type",e)(),null)},e}();E.defaultProps=Object.assign({},g.pF.defaultProps,{type:"best-available",adapters:void 0,waitForPageLoad:!0});var T,b=new E,x=t(7221),R=function(e){function n(){for(var n,t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];return(n=e.call.apply(e,[this].concat(r))||this).type="webgpu",n}(0,o.A)(n,e);var r=n.prototype;return r.isSupported=function(){return Boolean("undefined"!=typeof navigator&&navigator.gpu)},r.isDeviceHandle=function(e){return"undefined"!=typeof GPUDevice&&e instanceof GPUDevice||!(null==e||!e.queue)},r.create=function(){var e=(0,p.A)((0,d.A)().m(function e(n){var r,i,o,a,s,l,c,u,f,p,h,g,_,A,E;return(0,d.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:if(navigator.gpu){e.n=1;break}throw new Error("WebGPU not available. Recent Chrome browsers should work.");case 1:return e.n=2,navigator.gpu.requestAdapter({powerPreference:"high-performance"});case 2:if(r=e.v){e.n=3;break}throw new Error("Failed to request WebGPU adapter");case 3:if(E=r.info){e.n=5;break}return e.n=4,null==r.requestAdapterInfo?void 0:r.requestAdapterInfo();case 4:E=e.v;case 5:if(i=E,o=[],a={},n._requestMaxLimits)for(o.push.apply(o,Array.from(r.features)),s=Object.keys(r.limits).filter(function(e){return!["minSubgroupSize","maxSubgroupSize"].includes(e)}),l=(0,m.A)(s);!(c=l()).done;)u=c.value,f=u,"number"==typeof(p=r.limits[f])&&(a[f]=p);return e.n=6,r.requestDevice({requiredFeatures:o,requiredLimits:a});case 6:return h=e.v,e.n=7,Promise.all([t.e(9759),t.e(6996)]).then(t.bind(t,6996));case 7:return g=e.v,_=g.WebGPUDevice,v.R.groupCollapsed(1,"WebGPUDevice created")(),e.p=8,A=new _(n,h,r,i),v.R.probe(1,"Device created. For more info, set chrome://flags/#enable-webgpu-developer-features")(),v.R.table(1,A.info)(),e.a(2,A);case 9:return e.p=9,v.R.groupEnd(1)(),e.f(9);case 10:return e.a(2)}},e,null,[[8,,9,10]])}));return function(n){return e.apply(this,arguments)}}(),r.attach=function(){var e=(0,p.A)((0,d.A)().m(function e(n){return(0,d.A)().w(function(e){for(;;)switch(e.n){case 0:throw new Error("WebGPUAdapter.attach() not implemented");case 1:return e.a(2)}},e)}));return function(n){return e.apply(this,arguments)}}(),n}(t(4569).Y),C=new R,S={};function I(){return T||((T=document.createElement("div")).style.display="none",document.body.appendChild(T)),T}function P(e){return N.apply(this,arguments)}function N(){return(N=(0,p.A)((0,d.A)().m(function e(n){return(0,d.A)().w(function(e){for(;;)switch(e.n){case 0:return S[n]=S[n]||b.createDevice({adapters:[x.l,C],type:n,height:0,createCanvasContext:{container:I(),alphaMode:"opaque"}}),e.n=1,S[n];case 1:return e.a(2,e.v)}},e)}))).apply(this,arguments)}var y=(0,h.vt)(function(e){return{deviceType:void 0,deviceError:void 0,device:void 0,setDeviceType:(n=(0,p.A)((0,d.A)().m(function n(t){var r,i,o;return(0,d.A)().w(function(n){for(;;)switch(n.p=n.n){case 0:return n.p=0,n.n=1,P(t);case 1:i=n.v,n.n=3;break;case 2:n.p=2,o=n.v,r=o.message;case 3:return n.a(2,e(function(e){return{deviceType:t,deviceError:r,device:i}}))}},n,null,[[0,2]])})),function(e){return n.apply(this,arguments)})};var n});y.getState().setDeviceType("webgpu");var L=t(6065),F=L.Ay.div.withConfig({displayName:"tabs__Header",componentId:"sc-1sp8y0p-0"})(["display:flex;flex-direction:row;& > * + *{margin-left:2px;}"]),M=L.Ay.div.withConfig({displayName:"tabs__HeaderItem",componentId:"sc-1sp8y0p-1"})(function(e){return"\n  cursor: pointer;\n  padding: 10px 20px;\n  font-weight: bold;\n  &:hover {\n    background-color: #eeefef;\n  }\n  "+(e.isSelected?"\n    color: #276EF1;\n    border-bottom: 4px solid #276EF1;\n  ":"")+"\n"}),O=L.Ay.div.withConfig({displayName:"tabs__Body",componentId:"sc-1sp8y0p-2"})(["background-color:rgb(250,248,245);"]),w=function(e){var n,t,i=e.children,o=r.Children.toArray(i),a=(0,r.useState)((null==(n=o[0])?void 0:n.props.tag)||(null==(t=o[0])?void 0:t.props.title)),s=a[0],c=a[1],u=void 0!==e.selectedItem?e.selectedItem:s,f=void 0!==e.setSelectedItem?e.setSelectedItem:c;return o.some(function(e){return(e.props.tag||e.props.title)===u})||(u=s),(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(F,{children:o.map(function(e){return(0,l.jsx)(M,{isSelected:(e.props.tag||e.props.title)===u,onClick:function(){return f(e.props.tag||e.props.title)},children:e.props.title},e.props.title)})}),(0,l.jsx)(O,{children:o.find(function(e){return(e.props.tag||e.props.title)===u})})]})},U=function(e){var n=e.children;return(0,l.jsx)(l.Fragment,{children:n})},D=t(9813),B={devices:["webgl2","webgpu"]},G=function(e){e=Object.assign({},B,e);var n=y(function(e){return e.deviceType}),t=y(function(e){return e.deviceError}),r=y(function(e){return e.setDeviceType});return(0,l.jsxs)(w,{selectedItem:n,setSelectedItem:r,children:[e.devices.includes("webgpu")&&(0,l.jsx)(U,{title:"WebGPU",tag:"webgpu",children:t},"WebGPU"),e.devices.includes("webgl2")&&(0,l.jsx)(U,{title:"WebGL2",tag:"webgl",children:t},"WebGL2")]})},X=function(e){return(0,l.jsx)(D.A,{children:function(){return(0,l.jsx)(G,Object.assign({},e))}})};function H(e,n){return e?e.limits[n]?String(e.limits[n]):"0 \u274c":"N/A"}function V(e,n){return e?e.features.has(n)?"\u2705":"\u274c":"N/A"}function k(e,n){try{var t=e&&e.isVertexFormatSupported(n);return e?t?"\u2705":"\u274c":"N/A"}catch(r){return"\u274c"}}function z(e,n){try{var t=e&&e.isTextureFormatSupported(n);return e?t?"\u2705":"\u274c":"N/A"}catch(r){return"\u274c"}}function j(e,n){try{var t=e&&e.isTextureFormatSupported(n)&&e.isTextureFormatFilterable(n);return e?t?"\u2705":"\u274c":"N/A"}catch(r){return"\u274c"}}var W=function(e){var n=e.f,t=y(function(e){return e.device}),r=t?t.info[n]:"N/A";return(0,l.jsx)("code",{style:{color:"darkgreen"},children:r})},Y=function(e){var n=e.f,t=y(function(e){return e.device});return(0,l.jsx)("code",{style:{color:"darkgreen"},children:H(t,n)})},Q=function(e){var n=e.f,t=y(function(e){return e.device});return(0,l.jsx)("span",{children:V(t,n)})},K=function(e){var n=e.f,t=y(function(e){return e.device});return(0,l.jsx)("span",{children:k(t,n)},n)},Z=function(e){var n=e.f,t=y(function(e){return e.device});return(0,l.jsx)("span",{children:z(t,n)},n)},q=function(e){var n=e.f,t=y(function(e){return e.device});return(0,l.jsx)("span",{children:j(t,n)})},J=function(e){var n=e.f,t=y(function(e){return e.device}),r=n;try{var i=t&&t.isTextureFormatSupported(r)&&t.isTextureFormatRenderable(r);return t?i?"\u2705":"\u274c":"N/A"}catch(o){return"\u274c"}};var $,ee=t(6237),ne=0,te=function(){function e(n){if(this.device=null,this.canvas=null,this.animationProps=null,this.timeline=null,this._needsRedraw="initialized",this._initialized=!1,this._running=!1,this._animationFrameId=null,this._nextFramePromise=null,this._resolveNextFrame=null,this._cpuStartTime=0,this._error=null,this.props=Object.assign({},e.defaultAnimationLoopProps,n),!(n=this.props).device)throw new Error("No device provided");this.stats=n.stats||new ee.A({id:"animation-loop-stats"}),this.cpuTime=this.stats.get("CPU Time"),this.gpuTime=this.stats.get("GPU Time"),this.frameRate=this.stats.get("Frame Rate"),this.setProps({autoResizeViewport:n.autoResizeViewport}),this.start=this.start.bind(this),this.stop=this.stop.bind(this),this._onMousemove=this._onMousemove.bind(this),this._onMouseleave=this._onMouseleave.bind(this)}var n=e.prototype;return n.destroy=function(){this.stop(),this._setDisplay(null)},n.delete=function(){this.destroy()},n.reportError=function(e){this.props.onError(e),this._error=e},n.setNeedsRedraw=function(e){return this._needsRedraw=this._needsRedraw||e,this},n.needsRedraw=function(){var e=this._needsRedraw;return this._needsRedraw=!1,e},n.setProps=function(e){return"autoResizeViewport"in e&&(this.props.autoResizeViewport=e.autoResizeViewport||!1),this},n.start=function(){var e=(0,p.A)((0,d.A)().m(function e(){var n,t;return(0,d.A)().w(function(e){for(;;)switch(e.p=e.n){case 0:if(!this._running){e.n=1;break}return e.a(2,this);case 1:if(this._running=!0,e.p=2,this._initialized){e.n=4;break}return this._initialized=!0,e.n=3,this._initDevice();case 3:return this._initialize(),e.n=4,this.props.onInitialize(this._getAnimationProps());case 4:if(this._running){e.n=5;break}return e.a(2,null);case 5:return this._cancelAnimationFrame(),this._requestAnimationFrame(),e.a(2,this);case 6:throw e.p=6,t=e.v,n=t instanceof Error?t:new Error("Unknown error"),this.props.onError(n),n;case 7:return e.a(2)}},e,this,[[2,6]])}));return function(){return e.apply(this,arguments)}}(),n.stop=function(){return this._running&&(this.animationProps&&!this._error&&this.props.onFinalize(this.animationProps),this._cancelAnimationFrame(),this._nextFramePromise=null,this._resolveNextFrame=null,this._running=!1),this},n.redraw=function(){var e;return null!=(e=this.device)&&e.isLost||this._error||(this._beginFrameTimers(),this._setupFrame(),this._updateAnimationProps(),this._renderFrame(this._getAnimationProps()),this._clearNeedsRedraw(),this._resolveNextFrame&&(this._resolveNextFrame(this),this._nextFramePromise=null,this._resolveNextFrame=null),this._endFrameTimers()),this},n.attachTimeline=function(e){return this.timeline=e,this.timeline},n.detachTimeline=function(){this.timeline=null},n.waitForRender=function(){var e=this;return this.setNeedsRedraw("waitForRender"),this._nextFramePromise||(this._nextFramePromise=new Promise(function(n){e._resolveNextFrame=n})),this._nextFramePromise},n.toDataURL=function(){var e=(0,p.A)((0,d.A)().m(function e(){return(0,d.A)().w(function(e){for(;;)switch(e.n){case 0:return this.setNeedsRedraw("toDataURL"),e.n=1,this.waitForRender();case 1:if(!(this.canvas instanceof HTMLCanvasElement)){e.n=2;break}return e.a(2,this.canvas.toDataURL());case 2:throw new Error("OffscreenCanvas");case 3:return e.a(2)}},e,this)}));return function(){return e.apply(this,arguments)}}(),n._initialize=function(){this._startEventHandling(),this._initializeAnimationProps(),this._updateAnimationProps(),this._resizeViewport()},n._setDisplay=function(e){this.display&&(this.display.destroy(),this.display.animationLoop=null),e&&(e.animationLoop=this),this.display=e},n._requestAnimationFrame=function(){var e;this._running&&(this._animationFrameId=(e=this._animationFrame.bind(this),"undefined"!=typeof window&&window.requestAnimationFrame?window.requestAnimationFrame(e):setTimeout(e,1e3/60)))},n._cancelAnimationFrame=function(){var e;null!==this._animationFrameId&&(e=this._animationFrameId,"undefined"!=typeof window&&window.cancelAnimationFrame?window.cancelAnimationFrame(e):clearTimeout(e),this._animationFrameId=null)},n._animationFrame=function(){this._running&&(this.redraw(),this._requestAnimationFrame())},n._renderFrame=function(e){var n;this.display?this.display._renderFrame(e):(this.props.onRender(this._getAnimationProps()),null==(n=this.device)||n.submit())},n._clearNeedsRedraw=function(){this._needsRedraw=!1},n._setupFrame=function(){this._resizeViewport()},n._initializeAnimationProps=function(){var e,n=null==(e=this.device)?void 0:e.getDefaultCanvasContext();if(!this.device||!n)throw new Error("loop");var t=null==n?void 0:n.canvas,r=n.props.useDevicePixels;this.animationProps={animationLoop:this,device:this.device,canvasContext:n,canvas:t,useDevicePixels:r,timeline:this.timeline,needsRedraw:!1,width:1,height:1,aspect:1,time:0,startTime:Date.now(),engineTime:0,tick:0,tock:0,_mousePosition:null}},n._getAnimationProps=function(){if(!this.animationProps)throw new Error("animationProps");return this.animationProps},n._updateAnimationProps=function(){if(this.animationProps){var e=this._getSizeAndAspect(),n=e.width,t=e.height,r=e.aspect;n===this.animationProps.width&&t===this.animationProps.height||this.setNeedsRedraw("drawing buffer resized"),r!==this.animationProps.aspect&&this.setNeedsRedraw("drawing buffer aspect changed"),this.animationProps.width=n,this.animationProps.height=t,this.animationProps.aspect=r,this.animationProps.needsRedraw=this._needsRedraw,this.animationProps.engineTime=Date.now()-this.animationProps.startTime,this.timeline&&this.timeline.update(this.animationProps.engineTime),this.animationProps.tick=Math.floor(this.animationProps.time/1e3*60),this.animationProps.tock++,this.animationProps.time=this.timeline?this.timeline.getTime():this.animationProps.engineTime}},n._initDevice=function(){var e=(0,p.A)((0,d.A)().m(function e(){return(0,d.A)().w(function(e){for(;;)switch(e.n){case 0:return e.n=1,this.props.device;case 1:if(this.device=e.v,this.device){e.n=2;break}throw new Error("No device provided");case 2:this.canvas=this.device.getDefaultCanvasContext().canvas||null;case 3:return e.a(2)}},e,this)}));return function(){return e.apply(this,arguments)}}(),n._createInfoDiv=function(){if(this.canvas&&this.props.onAddHTML){var e=document.createElement("div");document.body.appendChild(e),e.style.position="relative";var n=document.createElement("div");n.style.position="absolute",n.style.left="10px",n.style.bottom="10px",n.style.width="300px",n.style.background="white",this.canvas instanceof HTMLCanvasElement&&e.appendChild(this.canvas),e.appendChild(n);var t=this.props.onAddHTML(n);t&&(n.innerHTML=t)}},n._getSizeAndAspect=function(){var e,n;if(!this.device)return{width:1,height:1,aspect:1};var t=(null==(e=this.device)?void 0:e.getDefaultCanvasContext().getDevicePixelSize())||[1,1],r=t[0],i=t[1],o=1,a=null==(n=this.device)?void 0:n.getDefaultCanvasContext().canvas;return a&&a.clientHeight?o=a.clientWidth/a.clientHeight:r>0&&i>0&&(o=r/i),{width:r,height:i,aspect:o}},n._resizeViewport=function(){this.props.autoResizeViewport&&this.device.gl&&this.device.gl.viewport(0,0,this.device.gl.drawingBufferWidth,this.device.gl.drawingBufferHeight)},n._beginFrameTimers=function(){this.frameRate.timeEnd(),this.frameRate.timeStart(),this.cpuTime.timeStart()},n._endFrameTimers=function(){this.cpuTime.timeEnd()},n._startEventHandling=function(){this.canvas&&(this.canvas.addEventListener("mousemove",this._onMousemove.bind(this)),this.canvas.addEventListener("mouseleave",this._onMouseleave.bind(this)))},n._onMousemove=function(e){e instanceof MouseEvent&&(this._getAnimationProps()._mousePosition=[e.offsetX,e.offsetY])},n._onMouseleave=function(e){this._getAnimationProps()._mousePosition=null},e}();function re(e,n){var t=this,r=null,i=(null==n?void 0:n.device)||b.createDevice({id:"animation-loop",adapters:null==n?void 0:n.adapters,createCanvasContext:!0}),o=new te(Object.assign({},n,{device:i,onInitialize:function(n){return(0,p.A)((0,d.A)().m(function t(){var i,o;return(0,d.A)().w(function(t){for(;;)switch(t.p=t.n){case 0:return oe(n.animationLoop.device),t.p=1,r=new e(n),t.n=2,null==(i=r)?void 0:i.onInitialize(n);case 2:return t.a(2,t.v);case 3:return t.p=3,o=t.v,ie(n.animationLoop.device,o),t.a(2,null)}},t,null,[[1,3]])}))()},onRender:function(e){var n;return null==(n=r)?void 0:n.onRender(e)},onFinalize:function(e){var n;return null==(n=r)?void 0:n.onFinalize(e)}}));return o.getInfo=function(){return t.AnimationLoopTemplateCtor.info},o}function ie(e,n){var t=null==e?void 0:e.getDefaultCanvasContext().canvas;if(t instanceof HTMLCanvasElement){var r,i;t.style.overflow="visible";var o=document.getElementById("animation-loop-error");null==(r=o)||r.remove(),(o=document.createElement("h1")).id="animation-loop-error",o.innerHTML=n.message,o.style.position="absolute",o.style.top="10px",o.style.left="10px",o.style.color="black",o.style.backgroundColor="red",null==(i=t.parentElement)||i.appendChild(o)}}function oe(e){var n=document.getElementById("animation-loop-error");n&&n.remove()}te.defaultAnimationLoopProps={device:null,onAddHTML:function(){return""},onInitialize:($=(0,p.A)((0,d.A)().m(function e(){return(0,d.A)().w(function(e){for(;;)if(0===e.n)return e.a(2,null)},e)})),function(){return $.apply(this,arguments)}),onRender:function(){},onFinalize:function(){},onError:function(e){return console.error(e)},stats:b.stats.get("animation-loop-"+ne++),autoResizeViewport:!1};var ae=t(4327);"undefined"!=typeof window&&(window.website=!0);var se=function(e){var n,t,i=(0,r.useState)(null),o=i[0],a=i[1],s=(0,r.useRef)(new WeakMap),c=(0,r.useRef)(null),u=y(function(e){return e.deviceType});t=e.container||"luma-example-container-"+u,(0,r.useEffect)(function(){if(o&&!s.current.get(o)){s.current.set(o,!0);var n=null,r=null,i=function(){var i=(0,p.A)((0,d.A)().m(function i(){var a,s;return(0,d.A)().w(function(i){for(;;)switch(i.n){case 0:return i.n=1,b.createDevice({adapters:[x.l,C],type:u,createCanvasContext:{canvas:o,container:t}});case 1:r=i.v,n=re(e.template,{device:r,autoResizeViewport:!0,autoResizeDrawingBuffer:!0}),null==(a=n)||a.start(),s="https://raw.githubusercontent.com/visgl/luma.gl/master",e.directory?(0,ae.Qj)(s+"/examples/"+e.directory+"/"+e.id+"/"):(0,ae.Qj)(s+"/website/static/images/");case 2:return i.a(2)}},i)}));return function(){return i.apply(this,arguments)}}();return c.current=Promise.resolve(c.current).then(function(){i().catch(function(e){console.error("start "+u+" failed",e)})}),function(){c.current=Promise.resolve(c.current).then(function(){n&&(n.destroy(),n=null),r&&r.destroy()}).catch(function(e){console.error("unmounting "+u+" failed",e)})}}},[u,o]);var f,h,m=null==(n=e.template)?void 0:n.info;return(0,l.jsxs)("div",{style:{position:"relative"},children:[(0,l.jsx)("canvas",{ref:a,style:{width:"100%",height:"100%"}},u),(0,l.jsxs)("div",{style:{position:"absolute",boxShadow:"5px 5px 4px grey",backgroundColor:"#F0F0F0F0",top:20,right:20,width:200,height:250,padding:10},children:[(0,l.jsx)("h3",{children:(f=e.id,h=f.split("-"),h.map(le).join(" "))}),m&&(0,l.jsx)("div",{dangerouslySetInnerHTML:{__html:m}}),e.children]})]})};function le(e){return e.charAt(0).toUpperCase()+e.slice(1)}},8942:(e,n,t)=>{t.d(n,{k:()=>o});var r=t(2444),i=t(467);function o(e,n){return a.apply(this,arguments)}function a(){return(a=(0,i.A)((0,r.A)().m(function e(n,t){var i,o;return(0,r.A)().w(function(e){for(;;)switch(e.n){case 0:if(i=document.getElementsByTagName("head")[0]){e.n=1;break}throw new Error("loadScript");case 1:return(o=document.createElement("script")).setAttribute("type","text/javascript"),o.setAttribute("src",n),t&&(o.id=t),e.a(2,new Promise(function(e,t){o.onload=e,o.onerror=function(e){return t(new Error("Unable to load script '"+n+"': "+e))},i.appendChild(o)}))}},e)}))).apply(this,arguments)}},9141:(e,n,t)=>{function r(e){return"undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement||"undefined"!=typeof VideoFrame&&e instanceof VideoFrame||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas}function i(e){if("undefined"!=typeof ImageData&&e instanceof ImageData||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas)return{width:e.width,height:e.height};if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)return{width:e.naturalWidth,height:e.naturalHeight};if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)return{width:e.videoWidth,height:e.videoHeight};if("undefined"!=typeof VideoFrame&&e instanceof VideoFrame)return{width:e.displayWidth,height:e.displayHeight};throw new Error("Unknown image type")}t.d(n,{c:()=>i,x:()=>r})},9316:(e,n,t)=>{t.d(n,{C:()=>a});var r=t(8696),i=t(7387),o=t(7862),a=function(e){function n(t,r){var i;return(i=e.call(this,t,r,n.defaultProps)||this).hash="",i.shaderLayout=r.shaderLayout,i}return(0,i.A)(n,e),(0,r.A)(n,[{key:Symbol.toStringTag,get:function(){return"ComputePipeline"}}])}(o.F);a.defaultProps=Object.assign({},o.F.defaultProps,{shader:void 0,entryPoint:void 0,constants:{},shaderLayout:void 0})},9489:(e,n,t)=>{t.d(n,{d:()=>i});var r=t(6237),i=new(function(){function e(){this.stats=new Map}var n=e.prototype;return n.getStats=function(e){return this.get(e)},n.get=function(e){return this.stats.has(e)||this.stats.set(e,new r.A({id:e})),this.stats.get(e)},e}())}}]);