/*! For license information please see 2b6c378d.28954d92.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[4748],{336:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>a});var r=n(4848),d=n(8453);const i={},o="Shader Modules",l={id:"api-guide/shaders/shader-modules",title:"Shader Modules",description:'luma.device provides a GLSL shader module system (through the @luma.device/shadertools module) that allows you build modular shaders. The system is built around a GLSL "assembler", and addresses the lack of a module/import system in the GLSL language. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.',source:"@site/../docs/api-guide/shaders/shader-modules.md",sourceDirName:"api-guide/shaders",slug:"/api-guide/shaders/shader-modules",permalink:"/docs/api-guide/shaders/shader-modules",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-guide/shaders/shader-modules.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Uniforms",permalink:"/docs/api-guide/gpu/gpu-uniforms"},next:{title:"Shader Transpilation",permalink:"/docs/api-guide/shaders/shader-transpilation"}},t={},a=[{value:"Usage",id:"usage",level:2},{value:"Structure of a Shader Module",id:"structure-of-a-shader-module",level:2},{value:"Shader Module Type",id:"shader-module-type",level:3},{value:"Shader Module Descriptor",id:"shader-module-descriptor",level:3},{value:"GLSL Code",id:"glsl-code",level:3},{value:"getUniforms",id:"getuniforms",level:3},{value:"uniforms",id:"uniforms",level:3},{value:"inject",id:"inject",level:2},{value:"GLSL Versions",id:"glsl-versions",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h1,{id:"shader-modules",children:"Shader Modules"}),"\n",(0,r.jsxs)(s.p,{children:["luma.device provides a GLSL shader module system (through the ",(0,r.jsx)(s.code,{children:"@luma.device/shadertools"}),' module) that allows you build modular shaders. The system is built around a GLSL "assembler", and addresses the lack of a module/import system in the GLSL language. The shader assembler allows you to import chunks of reusable shader code from separately defined shader fragments into your shader program source code, which allows you to organize your shader code in reusable modules.']}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:'Enables you to import and "inject" prepackaged modules of shader code into your shaders.'}),"\n",(0,r.jsx)(s.li,{children:"Allows you to package up reusable GLSL code as shader modules."}),"\n",(0,r.jsx)(s.li,{children:"Adds GPU detection and a measure of portability your shaders."}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(s.p,{children:["To add/inject existing modules into your shaders, just add the modules parameter to your ",(0,r.jsx)(s.code,{children:"assembleShaders"})," call:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"import {shaderModule} from 'library-of-shader-modules';\nconst {vs, fs, getUniforms, moduleMap} = assembleShaders(device, {\n  fs: '...',\n  vs: '...',\n  modules: [shaderModule],\n  ...\n})\n"})}),"\n",(0,r.jsx)(s.p,{children:"To create a new shader module, you need to create a descriptor object."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"const MY_SHADER_MODULE = {\n  name: 'my-shader-module',\n  vs: ....\n  fs: null,\n  inject: {},\n  dependencies: [],\n  deprecations: [],\n  getUniforms\n};\n"})}),"\n",(0,r.jsx)(s.p,{children:"This object can be used as shader module directly:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"assembleShaders(device, {..., modules: [MY_SHADER_MODULE]});\n"})}),"\n",(0,r.jsx)(s.h2,{id:"structure-of-a-shader-module",children:"Structure of a Shader Module"}),"\n",(0,r.jsx)(s.h3,{id:"shader-module-type",children:"Shader Module Type"}),"\n",(0,r.jsx)(s.p,{children:"A shader module is either:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Generic"})," - a set of generic GLSL functions that can be included either in a fragment shader or a vertex shader (or both). The ",(0,r.jsx)(s.code,{children:"fp64"})," module is a good example of this type of module."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Functional"}),' - Contains specific vertex and/or fragment shader "chunks", often set up so that the vertex shader part sets up a ',(0,r.jsx)(s.code,{children:"varying"})," used by the fragment shader part."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"shader-module-descriptor",children:"Shader Module Descriptor"}),"\n",(0,r.jsx)(s.p,{children:"To define a new shader module, you create a descriptor object that brings together all the necessary pieces:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"export const MY_SHADER_MODULE = {\n  name: 'my-shader-module',\n  vs: '...',\n  fs: '...',\n  inject: {},\n  dependencies: [],\n  deprecations: [],\n  getUniforms\n};\n"})}),"\n",(0,r.jsx)(s.p,{children:"Descriptor objects can define the following fields:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"name"})," (",(0,r.jsx)(s.em,{children:"String"}),", Required) - The name of the shader module."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"vs"})," - (String | null)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"fs"})," - (String | null)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"getUniforms"})," JavaScript function that maps JavaScript parameter keys to uniforms used by this module"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"uniforms"})," (",(0,r.jsx)(s.em,{children:"Object"}),") - a light alternative to ",(0,r.jsx)(s.code,{children:"getUniforms"}),", see below"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"inject"})," (",(0,r.jsx)(s.em,{children:"Object"}),") - injections the module will make into shader hooks, see below"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"dependencies"})," (",(0,r.jsx)(s.em,{children:"Array"}),") - a list of other shader modules that this module is dependent on"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"deprecations"})," (",(0,r.jsx)(s.em,{children:"Array"}),") - a list of deprecated APIs."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["If ",(0,r.jsx)(s.code,{children:"deprecations"})," is supplied, ",(0,r.jsx)(s.code,{children:"assembleShaders"})," will scan GLSL source code for the deprecated constructs and issue a console warning if found. Each API is described in the following format:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"type"}),": ",(0,r.jsx)(s.code,{children:"uniform <type>"})," or ",(0,r.jsx)(s.code,{children:"function"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"old"}),": name of the deprecated uniform/function"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"new"}),": name of the new uniform/function"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"deprecated"}),": whether the old API is still supported."]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"glsl-code",children:"GLSL Code"}),"\n",(0,r.jsx)(s.p,{children:"The GLSL code for a shader module typically contains:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"a mix of uniform and varying declarations"}),"\n",(0,r.jsx)(s.li,{children:"one or more GLSL function definitions"}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"getuniforms",children:"getUniforms"}),"\n",(0,r.jsx)(s.p,{children:"Each shader module provides a method to get a map of uniforms for the shader. This function will be called with two arguments:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"opts"})," - the module settings to update. This argument may not be provided when ",(0,r.jsx)(s.code,{children:"getUniforms"})," is called to generate a set of default uniform values."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"context"})," - the uniforms generated by this module's dependencies."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"The function should return a JavaScript object with keys representing uniform names and values representing uniform values."}),"\n",(0,r.jsxs)(s.p,{children:["The function should expect the shape of the dependency uniforms to vary based on what's passed in ",(0,r.jsx)(s.code,{children:"opts"}),". This behavior is intended because we only want to recalculate a uniform if the uniforms that it depends on are changed. An example is the ",(0,r.jsx)(s.code,{children:"project"})," and ",(0,r.jsx)(s.code,{children:"project64"})," modules in deck.device. When ",(0,r.jsx)(s.code,{children:"opts.viewport"})," is provided, ",(0,r.jsx)(s.code,{children:"project64"})," will receive the updated projection matrix generated by the ",(0,r.jsx)(s.code,{children:"project"})," module. If ",(0,r.jsx)(s.code,{children:"opts.viewport"})," is empty, then the ",(0,r.jsx)(s.code,{children:"project"})," module generates nothing and so should ",(0,r.jsx)(s.code,{children:"project64"}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"uniforms",children:"uniforms"}),"\n",(0,r.jsxs)(s.p,{children:["If the uniforms of this module can be directly pulled from user settings, they may declaratively defined by a ",(0,r.jsx)(s.code,{children:"uniforms"})," object:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"{\n  name: 'my-shader-module',\n  uniforms: {\n    strength: {type: 'number', value: 1, min: 0, max: 1},\n    center: [0.5, 0.5]\n  }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["At runtime, this map will be used to generate the uniforms needed by the shaders. If either ",(0,r.jsx)(s.code,{children:"strength"})," or ",(0,r.jsx)(s.code,{children:"center"})," is present in the user's module settings, then the user's value will be used; otherwise, the default value in the original definition will be used."]}),"\n",(0,r.jsx)(s.p,{children:"Each uniform definition may contain the following fields:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"type"})," (",(0,r.jsx)(s.em,{children:"String"}),") - one of ",(0,r.jsx)(s.code,{children:"number"}),", ",(0,r.jsx)(s.code,{children:"boolean"}),", ",(0,r.jsx)(s.code,{children:"array"})," or ",(0,r.jsx)(s.code,{children:"object"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"value"})," - the default value of this uniform"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["With ",(0,r.jsx)(s.code,{children:"type: 'number'"}),", the following additional fields may be added for validation:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"min"})," (",(0,r.jsx)(s.em,{children:"Number"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"max"})," (",(0,r.jsx)(s.em,{children:"Number"}),")"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Note: ",(0,r.jsx)(s.code,{children:"uniforms"})," is ignored if ",(0,r.jsx)(s.code,{children:"getUniforms"})," is provided."]}),"\n",(0,r.jsx)(s.h2,{id:"inject",children:"inject"}),"\n",(0,r.jsxs)(s.p,{children:["A map of hook function signatures to either the injection code string, or an object containing the injection code and an ",(0,r.jsx)(s.code,{children:"order"})," option indicating ordering within the hook function. See ",(0,r.jsx)(s.a,{href:"/docs/api-reference/shadertools/shader-assembler",children:"assembleShaders"})," documentation for more information on shader hooks."]}),"\n",(0,r.jsx)(s.p,{children:"For example:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-typescript",children:"{\n  picking: {\n    'vs:VERTEX_HOOK_FUNCTION': 'picking_setPickingColor(color.rgb);',\n    'fs:FRAGMENT_HOOK_FUNCTION': {\n      injection: 'color = picking_filterColor(color);',\n      order: Number.POSITIVE_INFINITY\n    },\n    'fs:#main-end': 'gl_FragColor = picking_filterColor(gl_FragColor);'\n  }\n}\n"})}),"\n",(0,r.jsx)(s.h2,{id:"glsl-versions",children:"GLSL Versions"}),"\n",(0,r.jsxs)(s.p,{children:["Shader modules will undergo some basic text transformations in order to match the GLSL version of the shaders they are injected into. These transformations are generally limited to the naming of input variables, output variables and texture sampling functions. See ",(0,r.jsx)(s.a,{href:"/docs/api-reference/shadertools/shader-assembler",children:"assembleShaders"})," documentation for more information."]})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1020:(e,s,n)=>{var r=n(6540),d=Symbol.for("react.element"),i=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,l=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,t={key:!0,ref:!0,__self:!0,__source:!0};function a(e,s,n){var r,i={},a=null,c=null;for(r in void 0!==n&&(a=""+n),void 0!==s.key&&(a=""+s.key),void 0!==s.ref&&(c=s.ref),s)o.call(s,r)&&!t.hasOwnProperty(r)&&(i[r]=s[r]);if(e&&e.defaultProps)for(r in s=e.defaultProps)void 0===i[r]&&(i[r]=s[r]);return{$$typeof:d,type:e,key:a,ref:c,props:i,_owner:l.current}}s.Fragment=i,s.jsx=a,s.jsxs=a},4848:(e,s,n)=>{e.exports=n(1020)},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>l});var r=n(6540);const d={},i=r.createContext(d);function o(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:o(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);