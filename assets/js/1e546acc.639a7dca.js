/*! For license information please see 1e546acc.639a7dca.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[3487],{3458:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>t});var d=s(4848),o=s(8453);const r={},i="ShaderAssembler",l={id:"api-reference/shadertools/shader-assembler",title:"ShaderAssembler",description:"The functionality of the shadertools module shader system is primarily exposed",source:"@site/../docs/api-reference/shadertools/shader-assembler.md",sourceDirName:"api-reference/shadertools",slug:"/api-reference/shadertools/shader-assembler",permalink:"/docs/api-reference/shadertools/shader-assembler",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/api-reference/shadertools/shader-assembler.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"ShaderModule",permalink:"/docs/api-reference/shadertools/shader-module"},next:{title:"Shader Parsing",permalink:"/docs/api-reference/shadertools/shader-info"}},a={},t=[{value:"Types",id:"types",level:2},{value:"<code>AssembleShaderOptions</code>",id:"assembleshaderoptions",level:2},{value:"Static Methods",id:"static-methods",level:2},{value:"<code>getDefaultShaderAssembler()</code>",id:"getdefaultshaderassembler",level:3},{value:"Methods",id:"methods",level:2},{value:"<code>addDefaultModule(module: ShaderModule)</code>",id:"adddefaultmodulemodule-shadermodule",level:3},{value:"<code>removeDefaultModule(module: ShaderModule)</code>",id:"removedefaultmodulemodule-shadermodule",level:3},{value:"<code>addShaderHook(hook: string, [opts: Object])</code>",id:"addshaderhookhook-string-opts-object",level:3},{value:"<code>assembleShader(options: AssembleShaderOptions)</code>",id:"assembleshaderoptions-assembleshaderoptions",level:3},{value:"<code>assembleShaderPair(options: AssembleShaderOptions)</code>",id:"assembleshaderpairoptions-assembleshaderoptions",level:3},{value:"Shader Module Assembly",id:"shader-module-assembly",level:2},{value:"Shader Hooks and Module Injections",id:"shader-hooks-and-module-injections",level:2},{value:"Constants and Values",id:"constants-and-values",level:2},{value:"Predefined Injection Hooks",id:"predefined-injection-hooks",level:3},{value:"Usage",id:"usage",level:2},{value:"Injection Map",id:"injection-map",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.h1,{id:"shaderassembler",children:"ShaderAssembler"}),"\n",(0,d.jsxs)(n.p,{children:["The functionality of the ",(0,d.jsx)(n.code,{children:"shadertools"})," module shader system is primarily exposed\nvia the ",(0,d.jsx)(n.code,{children:"ShaderAssembler"})," class."]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"shaderAssebler.assembleShaders()"})," composes base vertex and fragment shader source with"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"shader modules"}),"\n",(0,d.jsx)(n.li,{children:"hook functions"}),"\n",(0,d.jsx)(n.li,{children:"and injections\nto generate the final vertex and fragment shader source that can be used to create a program."}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"types",children:"Types"}),"\n",(0,d.jsx)(n.h2,{id:"assembleshaderoptions",children:(0,d.jsx)(n.code,{children:"AssembleShaderOptions"})}),"\n",(0,d.jsx)(n.p,{children:"For single shader compilation"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"source"})," - single shader source (always WGSL)"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"For shader pair compilation"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vs"})," - vertex shader source"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"fs"})," - fragment shader source code"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Common options"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"prologue"}),"=",(0,d.jsx)(n.code,{children:"true"})," (Boolean) - Will inject platform prologue (see below)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"defines"}),"=",(0,d.jsx)(n.code,{children:"{}"})," (Object) - a map of key/value pairs representing custom ",(0,d.jsx)(n.code,{children:"#define"}),"s to be injected into the shader source"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"modules"}),"=",(0,d.jsx)(n.code,{children:"[]"})," (Array) - list of shader modules (either objects defining the module, or names of previously registered modules)"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inject"}),"=",(0,d.jsx)(n.code,{children:"{}"})," (Object) - map of substituions,"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"hookFunctions"}),"=",(0,d.jsx)(n.code,{children:"[]"})," Array of hook functions descriptions. Descriptions can simply be the hook function signature (with a prefix ",(0,d.jsx)(n.code,{children:"vs"})," for vertex shader, or ",(0,d.jsx)(n.code,{children:"fs"})," for fragment shader) or an object with the hook signature, and a header and footer that will always appear in the hook function."]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Example of hook function"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"[\n  'vs:MY_HOOK_FUNCTION1(inout vec4 color)',\n  {\n    hook: 'fs:MY_HOOK_FUNCTION2(inout vec4 color)',\n    header: 'if (color.a == 0.0) discard;\\n',\n    footer: 'color.a *= 1.2;\\n'\n  }\n];\n"})}),"\n",(0,d.jsx)(n.h2,{id:"static-methods",children:"Static Methods"}),"\n",(0,d.jsx)(n.h3,{id:"getdefaultshaderassembler",children:(0,d.jsx)(n.code,{children:"getDefaultShaderAssembler()"})}),"\n",(0,d.jsxs)(n.p,{children:["Most applications that register default modules and hooks will want to use a single ",(0,d.jsx)(n.code,{children:"Shader"})]}),"\n",(0,d.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsx)(n.h3,{id:"adddefaultmodulemodule-shadermodule",children:(0,d.jsx)(n.code,{children:"addDefaultModule(module: ShaderModule)"})}),"\n",(0,d.jsx)(n.p,{children:"Add a module that will automatically be added to any programs created by the program manager."}),"\n",(0,d.jsx)(n.h3,{id:"removedefaultmodulemodule-shadermodule",children:(0,d.jsx)(n.code,{children:"removeDefaultModule(module: ShaderModule)"})}),"\n",(0,d.jsx)(n.p,{children:"Remove a module that is automatically being added to programs created by the program manager."}),"\n",(0,d.jsx)(n.h3,{id:"addshaderhookhook-string-opts-object",children:(0,d.jsx)(n.code,{children:"addShaderHook(hook: string, [opts: Object])"})}),"\n",(0,d.jsx)(n.p,{children:"Creates a shader hook function that shader modules can injection code into. Shaders can call these functions, which will be no-ops by default. If a shader module injects code it will be executed upon the hook function call. This mechanism allows the application to create shaders that can be automatically extended by included shader modules."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"hook"}),": ",(0,d.jsx)(n.code,{children:"vs:"})," or ",(0,d.jsx)(n.code,{children:"fs:"})," followed by the name and arguments of the function, e.g. ",(0,d.jsx)(n.code,{children:"vs:MYHOOK_func(inout vec4 value)"}),". Hook name without arguments\nwill also be used as the name of the shader hook"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"opts.header"})," (optional): code always included at the beginning of a hook function"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"opts.footer"})," (optional): code always included at the end of a hook function"]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"assembleshaderoptions-assembleshaderoptions",children:(0,d.jsx)(n.code,{children:"assembleShader(options: AssembleShaderOptions)"})}),"\n",(0,d.jsx)(n.p,{children:"generate the shader source that can be used to create a shader and then a pipeline."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"composes a single shader source (compute or unified vertex/fragment WGSL shader) with source from shader modules,"}),"\n",(0,d.jsx)(n.li,{children:"resolving hook functions and injections to"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Returns:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vs"})," - the resolved vertex shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"fs"})," - the resolved fragment shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getUniforms"})," - a combined ",(0,d.jsx)(n.code,{children:"getUniforms"})," function covering all modules."]}),"\n"]}),"\n",(0,d.jsx)(n.h3,{id:"assembleshaderpairoptions-assembleshaderoptions",children:(0,d.jsx)(n.code,{children:"assembleShaderPair(options: AssembleShaderOptions)"})}),"\n",(0,d.jsx)(n.p,{children:"Generate the final vertex and fragment shader source that can be compiled to create two shaders and then link them into a pipeline."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"composes base vertex and fragment shader source with source from shader modules"}),"\n",(0,d.jsx)(n.li,{children:"resolves hook functions and injections"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Takes the source code of a vertex shader and a fragment shader, and a list of modules, defines, etc. Outputs resolved source code for both shaders, after adding prologue, adding defines, and importing modules, and injecting any shader fragments)."}),"\n",(0,d.jsx)(n.p,{children:"Returns:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vs"})," - the resolved vertex shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"fs"})," - the resolved fragment shader"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getUniforms"})," - a combined ",(0,d.jsx)(n.code,{children:"getUniforms"})," function covering all modules."]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"shader-module-assembly",children:"Shader Module Assembly"}),"\n",(0,d.jsxs)(n.p,{children:["luma.gl's module shader system is primarily exposed via the function ",(0,d.jsx)(n.code,{children:"assembleShaders"})," which composes base vertex and fragment shader source with shader modules, hook functions and injections to generate the final vertex and fragment shader source that can be used to create a program."]}),"\n",(0,d.jsx)(n.h2,{id:"shader-hooks-and-module-injections",children:"Shader Hooks and Module Injections"}),"\n",(0,d.jsxs)(n.p,{children:["Shader hooks and module injections are a system that allows for shader to be written in a generic manner, with behaviour modified when modules are included. For example if we define a shader hook as ",(0,d.jsx)(n.code,{children:"fs:MY_HOOK_FUNCTION(inout vec4 color)"}),", ",(0,d.jsx)(n.code,{children:"assembleShader"})," will inject the following function automatically into our fragment shader:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"void MY_HOOK_FUNCTION(inout vec4 color) {\n\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"We can the write our fragment shader as follows:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"precision highp float;\n\nvoid main() {\n  vec4 color = vec4(1.0);\n  gl_FragColor = MY_HOOK_FUNCTION(color)\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"By default, the hook function is a no-op, so this doesn't do anything. However, if we add a module injection like the following:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"{\n  picking: {\n    'fs:VERTEX_HOOK_FUNCTION': 'color = vec4(1.0, 0.0, 0.0, 1.0);'\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["And pass the ",(0,d.jsx)(n.code,{children:"picking"})," module to ",(0,d.jsx)(n.code,{children:"assembledShaders"}),", the hook function will be updated as follows:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-c",children:"void MY_HOOK_FUNCTION(inout vec4 color) {\n  color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"The hook function now changes the color from white to red."}),"\n",(0,d.jsx)(n.h2,{id:"constants-and-values",children:"Constants and Values"}),"\n",(0,d.jsx)(n.h3,{id:"predefined-injection-hooks",children:"Predefined Injection Hooks"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Key"}),(0,d.jsx)(n.th,{children:"Shader"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#decl"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Inject at top of shader (declarations)"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#main-start"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Injected at the very beginning of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vs:#main-end"})}),(0,d.jsx)(n.td,{children:"Vertex"}),(0,d.jsx)(n.td,{children:"Injected at the very end of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#decl"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Inject at top of shader (declarations)"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#main-start"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Injected at the very beginning of main function"})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"fs:#main-end"})}),(0,d.jsx)(n.td,{children:"Fragment"}),(0,d.jsx)(n.td,{children:"Injected at the very end of main function"})]})]})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"NOTE"}),": Injections assume that the ",(0,d.jsx)(n.code,{children:"main"})," function appears last in a shader."]}),"\n",(0,d.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,d.jsx)(n.h3,{id:"injection-map",children:"Injection Map"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"assembleShaders"})," (and ",(0,d.jsx)(n.code,{children:"Model"})," constructor) will take an ",(0,d.jsx)(n.code,{children:"inject"})," argument that contains a map of:"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"keys indicating hooks (predefined or functions)"}),"\n",(0,d.jsxs)(n.li,{children:["values representing code to be injected. This can be either a simple string or an object containing the ",(0,d.jsx)(n.code,{children:"injection"})," string and an ",(0,d.jsx)(n.code,{children:"order"})," indicating its priority."]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"Examples:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"  inject: {\n    'fs:#main-end': '  gl_FragColor = picking_filterColor(gl_FragColor)'\n  }\n"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-typescript",children:"ProgramManager.getDefaultProgramManager(gl).addShaderHook('fs:MYHOOK_fragmentColor(inout vec4 color)');\n\nnew Model(gl, {\n  vs,\n  fs: `void main() {\n    MYHOOK_fragmentColor(gl_FragColor);\n  }`,\n  modules: [picking]\n  inject: {\n    'fs:#main-start': 'gl_FragColor = vec4(1., 0., 0., 1.);';\n    'fs:MYHOOK_fragmentColor': {\n      injection: '  color = picking_filterColor(color);',\n      order: 9999\n  }\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}},1020:(e,n,s)=>{var d=s(6540),o=Symbol.for("react.element"),r=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,l=d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function t(e,n,s){var d,r={},t=null,c=null;for(d in void 0!==s&&(t=""+s),void 0!==n.key&&(t=""+n.key),void 0!==n.ref&&(c=n.ref),n)i.call(n,d)&&!a.hasOwnProperty(d)&&(r[d]=n[d]);if(e&&e.defaultProps)for(d in n=e.defaultProps)void 0===r[d]&&(r[d]=n[d]);return{$$typeof:o,type:e,key:t,ref:c,props:r,_owner:l.current}}n.Fragment=r,n.jsx=t,n.jsxs=t},4848:(e,n,s)=>{e.exports=s(1020)},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>l});var d=s(6540);const o={},r=d.createContext(o);function i(e){const n=d.useContext(r);return d.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),d.createElement(r.Provider,{value:n},e.children)}}}]);