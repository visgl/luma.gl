/*! For license information please see 04e3dbfa.eb4fd2db.js.LICENSE.txt */
"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[5334],{4876:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(4848),t=n(8453);const i={},s="Profiling",l={id:"developer-guide/profiling",title:"Profiling",description:"GPU programming is all about performance, so having tools to systematically",source:"@site/../docs/developer-guide/profiling.md",sourceDirName:"developer-guide",slug:"/developer-guide/profiling",permalink:"/docs/developer-guide/profiling",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/main/docs/../docs/developer-guide/profiling.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Testing",permalink:"/docs/developer-guide/testing"},next:{title:"Bundling",permalink:"/docs/developer-guide/bundling"}},a={},c=[{value:"probe.gl Stats",id:"probegl-stats",level:2},{value:"Memory Profiling",id:"memory-profiling",level:2},{value:"Performance Profiling",id:"performance-profiling",level:2}];function d(e){const r={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.h1,{id:"profiling",children:"Profiling"}),"\n",(0,o.jsx)(r.p,{children:"GPU programming is all about performance, so having tools to systematically\nmeasure the performance impact of code changes is critical. luma.gl offers\nseveral built-in facilities."}),"\n",(0,o.jsx)(r.h2,{id:"probegl-stats",children:"probe.gl Stats"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.code,{children:"probe.gl"})," is a companion framework focused on instrumentation and logging of\nJavaScript applications. It provides a ",(0,o.jsx)(r.code,{children:"Stats"}),' class which can be thought of\nas a "bag" of different stats (or performance measurements), and luma.gl itself\nautomatically populates ',(0,o.jsx)(r.code,{children:"Stats"})," objects that can be inspected by the application."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-typescript",children:"import {luma} from '@luma.gl/core';\n\nconsole.log(luma.stats.getTable());\n"})}),"\n",(0,o.jsx)(r.h2,{id:"memory-profiling",children:"Memory Profiling"}),"\n",(0,o.jsx)(r.p,{children:"luma.gl automatically tracks GPU memory usage."}),"\n",(0,o.jsxs)(r.p,{children:["Note that JavaScript is a garbage collected language and while memory allocations can\nalways be tracked, it is only possible for luma.gl to track GPU memory deallocations if\nthey are performed through the luma.gl API (by calling the ",(0,o.jsx)(r.code,{children:".destroy()"})," methods on ",(0,o.jsx)(r.code,{children:"Buffer"})," and ",(0,o.jsx)(r.code,{children:"Texture"})," objects)."]}),"\n",(0,o.jsx)(r.p,{children:"Apart from GPU memory tracking for luma.gl also maintain counts of the various\nother luma.gl API objects. Such object generally do not consume a lot of memory,\nhowever tracking allocations can help spot resource leaks or unnecessary work being done."}),"\n",(0,o.jsx)(r.h2,{id:"performance-profiling",children:"Performance Profiling"}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.code,{children:"device.createQuerySet()"})," can be used to create GPU queries that"]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Occlusion Queries always supported."}),"\n",(0,o.jsxs)(r.li,{children:["Timestamp Queries are supported if the ",(0,o.jsx)(r.code,{children:"timestamp-query"})," feature is available, check with ",(0,o.jsx)(r.code,{children:"device.features.has('timestamp-query')"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.code,{children:"QuerySet"})," instances can be supplied when creating ",(0,o.jsx)(r.code,{children:"RenderPass"})," and ",(0,o.jsx)(r.code,{children:"ComputePass"})," instances."]}),"\n",(0,o.jsxs)(r.p,{children:["Results are available through\n",(0,o.jsx)(r.code,{children:"commandEncoder.resolveQuerySet()"})]})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1020:(e,r,n)=>{var o=n(6540),t=Symbol.for("react.element"),i=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,l=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function c(e,r,n){var o,i={},c=null,d=null;for(o in void 0!==n&&(c=""+n),void 0!==r.key&&(c=""+r.key),void 0!==r.ref&&(d=r.ref),r)s.call(r,o)&&!a.hasOwnProperty(o)&&(i[o]=r[o]);if(e&&e.defaultProps)for(o in r=e.defaultProps)void 0===i[o]&&(i[o]=r[o]);return{$$typeof:t,type:e,key:c,ref:d,props:i,_owner:l.current}}r.Fragment=i,r.jsx=c,r.jsxs=c},4848:(e,r,n)=>{e.exports=n(1020)},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>l});var o=n(6540);const t={},i=o.createContext(t);function s(e){const r=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(i.Provider,{value:r},e.children)}}}]);