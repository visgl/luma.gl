"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[8384],{8218:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>s,contentTitle:()=>l,default:()=>a,frontMatter:()=>c,metadata:()=>o,toc:()=>d});var r=n(4848),t=n(8453);const c={},l="gpuPicking",o={id:"api-reference/shadertools/shader-modules/gpu-picking",title:"gpuPicking",description:"Provides support for GPU-based picking.",source:"@site/../docs/api-reference/shadertools/shader-modules/gpu-picking.md",sourceDirName:"api-reference/shadertools/shader-modules",slug:"/api-reference/shadertools/shader-modules/gpu-picking",permalink:"/docs/api-reference/shadertools/shader-modules/gpu-picking",draft:!1,unlisted:!1,editUrl:"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/shadertools/shader-modules/gpu-picking.md",tags:[],version:"current",frontMatter:{}},s={},d=[{value:"Under the Hood",id:"under-the-hood",level:2},{value:"About GPU based picking",id:"about-gpu-based-picking",level:2},{value:"Usage",id:"usage",level:2},{value:"JavaScript Functions",id:"javascript-functions",level:2},{value:"getUniforms()",id:"getuniforms",level:3},{value:"Vertex Shader Functions",id:"vertex-shader-functions",level:2},{value:"picking_setPickingColor()",id:"picking_setpickingcolor",level:3},{value:"picking_setPickingAttribute",id:"picking_setpickingattribute",level:3},{value:"Fragment Shader Functions",id:"fragment-shader-functions",level:2},{value:"picking_filterColor",id:"picking_filtercolor",level:3},{value:"picking_filterPickingColor()",id:"picking_filterpickingcolor",level:3},{value:"picking_filterPickingColor()",id:"picking_filterpickingcolor-1",level:3},{value:"Remarks",id:"remarks",level:2}];function h(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"gpupicking",children:"gpuPicking"})}),"\n",(0,r.jsx)("p",{class:"badges",children:(0,r.jsx)("img",{src:"https://img.shields.io/badge/From-v9.1-blue.svg?style=flat-square",alt:"From v9.1"})}),"\n",(0,r.jsx)(i.p,{children:"Provides support for GPU-based picking."}),"\n",(0,r.jsxs)(i.p,{children:["Picking is a key capability for most interactive applications. Consult the API guide learn more about ",(0,r.jsx)(i.a,{href:"/docs/api-guide/engine/interactivity",children:"picking"}),"."]}),"\n",(0,r.jsx)(i.p,{children:'GPU picking is based on the conclusion that each pixel on the screen was generated while rendering some "object", which in luma.gl can often be thought of as one row in an a data table being rendered.'}),"\n",(0,r.jsx)(i.h2,{id:"under-the-hood",children:"Under the Hood"}),"\n",(0,r.jsxs)(i.p,{children:["Depending on the structure of the shader, each object can either correspond to an ",(0,r.jsx)(i.code,{children:"instance"})," or a group of vertexes."]}),"\n",(0,r.jsx)(i.p,{children:"An additional consideration"}),"\n",(0,r.jsx)(i.p,{children:"li"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"gpuPicking"})," modules supports:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"picking of object indexes"}),"\n",(0,r.jsx)(i.li,{children:"highlighting of objects"}),"\n",(0,r.jsxs)(i.li,{children:["pick a specific ",(0,r.jsx)(i.em,{children:"instance"})," in an instanced draw call"]}),"\n",(0,r.jsxs)(i.li,{children:["highlight all fragments of an ",(0,r.jsx)(i.em,{children:"instance"})," based on its picking color"]}),"\n",(0,r.jsx)(i.li,{children:'pick "group of primitives" with the same picking color in non-instanced draw-calls'}),"\n",(0,r.jsx)(i.li,{children:'highlight "group of primitives" with the same picking color in non-instanced draw-calls'}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Highlighting allows applications to specify a picking color corresponding to an object that need to be highlighted and the highlight color to be used."}),"\n",(0,r.jsx)(i.h2,{id:"about-gpu-based-picking",children:"About GPU based picking"}),"\n",(0,r.jsx)(i.p,{children:"GPU based picking has a couple of significant advantage over CPU-based picking:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"GPU-based picking is a picking technique that can be performed entirely on the GPU, meaning that it is very performant, especially when picking is done every frame."}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"can be added to any existing shaders"}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"and is independent of the structure of the input geometry or rendering without requiring any additional picking logic to that shader, beyond calling one function in the vertex shader and one function in the fragment shader."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Note that GPU-based picking does comes with some limitations:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Picking occluding objects require re-rendering and discarding the already picked objects."}),"\n",(0,r.jsx)(i.li,{children:"On WebGL-specific: the read back of the picking data from the picking texture can only be done synchronously, causing a GPU pipeline stall, which can defeat some of the performance advantages."}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Traditional 3d frameworks often support CPU-based picking. While luma.gl does not include an CPU-based picking algorithms, CPU based picking techniques do have advantages:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"They can often provide precise intersection points on objects and they are better at handling picking of multiple objects, especially for objects that are occluded."}),"\n",(0,r.jsx)(i.li,{children:"However CPU based picking techniques are slower and can require more data on the CPU or they may need to be customized to the structure of the input data."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(i.p,{children:"In your vertex shader, your inform the picking module what object we are currently rendering by supplying a picking color, perhaps from an attribute."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"attribute vec3 aPickingColor;\nmain() {\n  picking_setPickingColor(aPickingColor);\n  ...\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["In your fragment shader, you simply apply (call) the ",(0,r.jsx)(i.code,{children:"picking_filterColor"})," filter function at the very end of the shader. This will return the normal color, or the highlight color, or the picking color, as appropriate."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"main() {\n  gl_FragColor = ...\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["In your fragment shader, you simply apply (call) the ",(0,r.jsx)(i.code,{children:"picking_filterPickingColor"})," filter function at the very end of the shader. This will return the normal color, or the highlight color, or the picking color, as appropriate."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-glsl",children:"main() {\n  gl_FragColor = ...\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["If highlighting is not needed, you simply apply (call) the ",(0,r.jsx)(i.code,{children:"picking_filterPickingColor"})," filter function at the very end of the shader. This will return the normal color or the picking color, as appropriate."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"main() {\n  gl_FragColor = ...\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["If you would like to apply the highlight color to the currently selected element call ",(0,r.jsx)(i.code,{children:"picking_filterHighlightColor"})," before calling ",(0,r.jsx)(i.code,{children:"picking_filterPickingColor"}),". You can also apply other filters on the non-picking color (vertex or highlight color) by placing those instruction between these two function calls."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"main() {\n  gl_FragColor = ...\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n   ... apply any filters on gl_FragColor ...\n gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"javascript-functions",children:"JavaScript Functions"}),"\n",(0,r.jsx)(i.h3,{id:"getuniforms",children:"getUniforms()"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"getUniforms()"})," takes an object with key/value pairs, returns an object with key/value pairs representing the uniforms that the ",(0,r.jsx)(i.code,{children:"gpuPicking"})," module shaders need."]}),"\n",(0,r.jsx)(i.p,{children:'Uniforms for the picking module, which renders picking colors and highlighted item.\nWhen active, renders picking colors, assumed to be rendered to off-screen "picking" buffer.\nWhen inactive, renders normal colors, with the exception of selected object which is rendered with highlight'}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Setting"}),(0,r.jsx)(i.th,{children:"Description"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"isActive"}),"?: boolean"]}),(0,r.jsx)(i.td,{children:"Whether in picking or normal rendering (+highlighting) mode"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"isAttribute"}),": boolean"]}),(0,r.jsx)(i.td,{children:"Set to true when picking an attribute value instead of object index"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"useFloatColors"}),"?: boolean"]}),(0,r.jsx)(i.td,{children:"Color range 0-1 or 0-255"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"isHighlightActive"}),"?: boolean"]}),(0,r.jsx)(i.td,{children:"Do we have a highlighted item?"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"highlightedObjectColor"}),"?: NumberArray"]}),(0,r.jsx)(i.td,{children:"Set to a picking color to visually highlight that item"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.code,{children:"highlightColor"}),"?: NumberArray"]}),(0,r.jsx)(i.td,{children:'Color of visual highlight of "selected" item'})]})]})]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"isActive"}),' - When true, renders picking colors. Set when rendering to off-screen "picking" buffer. When false, renders normal colors, with the exception of selected object which is rendered with highlight']}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"vertex-shader-functions",children:"Vertex Shader Functions"}),"\n",(0,r.jsx)(i.h3,{id:"picking_setpickingcolor",children:"picking_setPickingColor()"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"void picking_setPickingColor(vec3 pickingColor)\n"})}),"\n",(0,r.jsxs)(i.p,{children:["Sets the color that will be returned by the fragment shader if color based picking is enabled. Typically set from a ",(0,r.jsx)(i.code,{children:"pickingColor"})," uniform or a ",(0,r.jsx)(i.code,{children:"pickingColors"})," attribute (e.g. when using instanced rendering, to identify the actual instance that was picked)."]}),"\n",(0,r.jsx)(i.h3,{id:"picking_setpickingattribute",children:"picking_setPickingAttribute"}),"\n",(0,r.jsx)(i.p,{children:"Sets the attribute value that needs to be picked."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"void picking_setPickingAttribute(float value)"}),"\n",(0,r.jsx)(i.code,{children:"void picking_setPickingAttribute(vec2 value)"}),"\n",(0,r.jsx)(i.code,{children:"void picking_setPickingAttribute(vec3 value)"})]}),"\n",(0,r.jsx)(i.h2,{id:"fragment-shader-functions",children:"Fragment Shader Functions"}),"\n",(0,r.jsx)(i.h3,{id:"picking_filtercolor",children:"picking_filterColor"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"fn picking_filterColor(color: vec4<f32>) -> vec4<f32>\nvec4 picking_filterColor(vec4 color)\n"})}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Picking Enabled"}),(0,r.jsx)(i.th,{children:"Item Highlighted"}),(0,r.jsx)(i.th,{children:"Returned color"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"\u2705"}),(0,r.jsx)(i.td,{children:"\u2013"}),(0,r.jsx)(i.td,{children:"Returns picking color (representing index of this color)"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"\u274c"}),(0,r.jsx)(i.td,{children:"\u2705"}),(0,r.jsx)(i.td,{children:'Returns the current highlight color (to show this item as "selected")'})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"\u274c"}),(0,r.jsx)(i.td,{children:"\u274c"}),(0,r.jsxs)(i.td,{children:["returns the original color (unmodified ",(0,r.jsx)(i.code,{children:"color"})," argument)"]})]})]})]}),"\n",(0,r.jsx)(i.h3,{id:"picking_filterpickingcolor",children:"picking_filterPickingColor()"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-ts",children:"vec4 picking_filterPickingColor(vec4 color)\n"})}),"\n",(0,r.jsxs)(i.p,{children:["If picking active, returns the current vertex's picking color set by ",(0,r.jsx)(i.code,{children:"picking_setPickingColor"}),", otherwise returns its argument unmodified."]}),"\n",(0,r.jsx)(i.p,{children:"Returns picking highlight color if the pixel belongs to currently selected model, otherwise returns its argument unmodified."}),"\n",(0,r.jsx)(i.h3,{id:"picking_filterpickingcolor-1",children:"picking_filterPickingColor()"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.code,{children:"vec4 picking_filterPickingColor(vec4 color)"})}),"\n",(0,r.jsxs)(i.p,{children:["If picking active, returns the current vertex's picking color set by ",(0,r.jsx)(i.code,{children:"picking_setPickingColor"}),", otherwise returns its argument unmodified."]}),"\n",(0,r.jsx)(i.h2,{id:"remarks",children:"Remarks"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["It is recommended that ",(0,r.jsx)(i.code,{children:"picking_filterPickingColor()"})," is called last in a fragment shader, as the picking color (returned when picking is enabled) must not be modified in any way (and alpha must remain 1) or picking results will not be correct."]}),"\n"]})]})}function a(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var r=n(6540);const t={},c=r.createContext(t);function l(e){const i=r.useContext(c);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(c.Provider,{value:i},e.children)}}}]);