"use strict";(self.webpackChunkwebsite_docusaurus=self.webpackChunkwebsite_docusaurus||[]).push([[3610],{7208:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"api-reference/gltf/gltf-extensions","title":"glTF Extensions","description":"Below is a table covering most published glTF 2.0 extensions (both Khronos KHR and vendor\u2010specific EXT/MSFT_ etc.) and whether luma.gl currently offers \u201cbuilt in\u201d handling for them.","source":"@site/../docs/api-reference/gltf/gltf-extensions.md","sourceDirName":"api-reference/gltf","slug":"/api-reference/gltf/gltf-extensions","permalink":"/docs/api-reference/gltf/gltf-extensions","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/luma.gl/tree/master/docs/../docs/api-reference/gltf/gltf-extensions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Overview","permalink":"/docs/api-reference/gltf/"},"next":{"title":"fp32 (32-bit Floating Point)","permalink":"/docs/api-reference/shadertools/shader-modules/fp32"}}');var n=s(4848),d=s(8453);const l={},i="glTF Extensions",a={},c=[{value:"Summary",id:"summary",level:2},{value:"loaders.gl glTF support",id:"loadersgl-gltf-support",level:2}];function o(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"gltf-extensions",children:"glTF Extensions"})}),"\n",(0,n.jsx)(t.p,{children:"Below is a table covering most published glTF 2.0 extensions (both Khronos KHR_ and vendor\u2010specific EXT_/MSFT_ etc.) and whether luma.gl currently offers \u201cbuilt in\u201d handling for them."}),"\n",(0,n.jsx)(t.p,{children:"glTF extension support in luma.gl"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Extension"}),(0,n.jsx)(t.th,{children:"Status"}),(0,n.jsx)(t.th,{children:"Notes"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_draco_mesh_compression"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"DRACO-compressed meshes are decompressed via loaders.gl before scenegraph creation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_lights_punctual"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"luma.gl\u2019s ScenegraphNode and material system handle punctual lights if present in the glTF."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_pbrSpecularGlossiness"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Materials with the specular-glossiness workflow are parsed by loaders.gl; luma.gl treats them as material parameters on the built scenegraph nodes."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_unlit"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Unlit materials are supported (rendered without lighting calculations)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_texture_basisu"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"BasisU textures are extracted by loaders.gl and passed as compressed textures to luma.gl where possible."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_texture_transform"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Extra texture UV transforms (offset, scale, rotation) are respected by luma.gl\u2019s material code."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_clearcoat"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"luma.gl\u2019s material system exposes clearcoat parameters but rendering support depends on the chosen shader model."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_ior"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Values are loaded but luma.gl shaders generally do not yet implement IOR-based effects."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_specular"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Parameters are parsed but currently ignored by built\u2013in PBR shaders."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_sheen"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Sheen factors currently ignored unless the application provides custom shaders."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_transmission"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"luma.gl does not implement refraction or transmissive materials at this time."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_volume"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Volume/thickness/attenuation features not implemented in the stock shader pipeline."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_iridescence"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Experimental. Requires custom material/shader code to render."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_anisotropy"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Exposed on the parsed material but no built-in shading support."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_emissive_strength"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Overwrites emissive intensity value if present."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_variants"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Variant mapping is parsed. Application must choose the active variant at runtime."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_mesh_quantization"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Loaders.gl unpacks quantized attribute data back to floats before handing to luma.gl."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_animation_pointer"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Loaders.gl can expose the data; luma.gl does not currently map these pointers to runtime animations."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_xmp_json_ld"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Loader exposes metadata but luma.gl does not interpret it."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_variants"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"See above."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_materials_translucency"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Not widely used\tSome engines treat as prototype/experimental: no current luma.gl support."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_meshopt_compression"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Loaders.gl decompresses meshopt data; luma.gl then works with the decompressed results."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_mesh_gpu_instancing"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"Instanced mesh attributes produce luma.gl InstancedModel/Instanced geometry."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_texture_webp"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"WebP textures loaded via loaders.gl and passed to luma.gl Texture2D."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_texture_avif"})}),(0,n.jsx)(t.td,{children:"\u2705"}),(0,n.jsx)(t.td,{children:"(if browser supports AVIF)\tDependent on browser support; once decoded the texture works like any other."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_lights_image_based"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Partial\tluma.gl has environment light constructs; ability to build from EXT_lights_image_based data is minimal without custom code."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_primitive_bounding_box"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Data available\tBounding boxes present in the glTF object; can be consumed for culling but no automatic pipeline."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"EXT_texture_video"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Not supported\tVideo textures are not automatically created; would require application level integration."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"MSFT_lod\tNot supported"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"luma.gl does not parse/use MSFT_lod extension by default."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"MSFT_packing_occlusion"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Not consumed by default."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"KHR_xxx"})}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"Many experimental proposals exists, they would need custom integrations."})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsx)(t.p,{children:"All the extensions marked as supported are at least parsed out of the loaded glTF data\nthanks to loaders.gl and mapped to luma.gl scenegraph constructs where possible."}),"\n",(0,n.jsx)(t.p,{children:"luma.gl at present focuses on common real-time PBR material parameters\n(KHR_materials_* where noted), Draco & Meshopt mesh compression, and typical\ntexture/UV/misc feature extensions."}),"\n",(0,n.jsxs)(t.p,{children:["Many K",(0,n.jsx)(t.code,{children:"HR_materials_*"})," extensions (especially those adding new BRDF properties)\nare parsed but are effectively ignored in the default luma.gl shader code.\nApplication code could provide custom shaders to interpret them if needed."]}),"\n",(0,n.jsx)(t.p,{children:"Vendor\u2010specific or rarely seen extensions (for example MSFT_lod,\nMSFT_packing_occlusion, EXT_texture_video, etc.) generally have no built-in\nhandling in luma.gl out of the box."}),"\n",(0,n.jsx)(t.p,{children:"If you rely heavily on any of the more recent or experimental extensions,\nconsider using loaders.gl to parse them and then implement the features in\ncustom luma.gl shaders or pipeline stages. The list above should match (and\nextend) the shorter table normally shown in the loaders.gl documentation."}),"\n",(0,n.jsx)(t.h2,{id:"loadersgl-gltf-support",children:"loaders.gl glTF support"}),"\n",(0,n.jsx)(t.p,{children:"The loaders.gl GLTF loader handles most of the data manipulation (DRACO compression,\nBasisU textures, extracting textures, etc.) so luma.gl generally relies on the loader results.\nFor some extensions - e.g. advanced material models - luma.gl does not yet provide specific\nruntime support even if the loader can parse them."}),"\n",(0,n.jsx)(t.p,{children:"The table below is a superset of that list and collects the other officially\nregistered extensions as well."})]})}function h(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>i});var r=s(6540);const n={},d=r.createContext(n);function l(e){const t=r.useContext(d);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),r.createElement(d.Provider,{value:t},e.children)}}}]);